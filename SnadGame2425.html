

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="author" content="Patrik Harag">
    <meta property="og:site_name" content="SandSaga.com">
    <meta name="Description" content="The Sand Saga is a unique falling-sand game. It allows players to experiment with various elements, such as sand, soil, water and fire. Cheese Game by Mecanix is one of its scenarios.">
    <meta property="og:description" content="The Sand Saga is a unique falling-sand game. It allows players to experiment with various elements, such as sand, soil, water and fire. Cheese Game by Mecanix is one of its scenarios.">
    <meta property="og:title" content="Cheese Game by Mecanix">
    <meta property="og:image" content="/social-preview.png">

    <!-- icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=1">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=1">
    <link rel="manifest" href="/site.webmanifest?v=1">
    <link rel="mask-icon" href="/safari-pinned-tab.svg?v=1" color="#ffc40d">
    <link rel="shortcut icon" href="/favicon.ico?v=1">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">

    <title>Sand Saga - Cheese Game by Mecanix</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-V8NDXLE87V"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-V8NDXLE87V');
    </script>
  <link rel="stylesheet" type="text/css" href="https://files.harag.cz/www/app/sand-game-js/prod/24w19a/sand-game-js.css">

  <script defer>/* Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved */
    (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
        typeof define === 'function' && define.amd ? define(['exports'], factory) :
        (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.SandGameJS = {}));
    })(this, (function (exports) { 'use strict';
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-03-24
         */
        class SizeUtils {
    
            static #determineSize(root, maxWidthPx = 1400, maxHeightPx = 800) {
                let parentWidth;
                if (window.innerWidth <= 575) {
                    parentWidth = window.innerWidth;  // no margins
                } else {
                    parentWidth = root.clientWidth;  // including padding
                }
    
                let width = Math.min(maxWidthPx, parentWidth);
                let height = Math.min(maxHeightPx, Math.trunc(window.innerHeight * 0.70));
                if (width / height < 0.75) {
                    height = Math.trunc(width / 0.75);
                }
                return {width, height};
            }
    
            static #determineMaxNumberOfPoints() {
                if (navigator.maxTouchPoints || 'ontouchstart' in document.documentElement) {
                    // probably a smartphone
                    return 75000;
                } else {
                    // bigger screen => usually more powerful (or newer) computer
                    if (window.screen.width >= 2560 && window.screen.height >= 1440) {
                        return 200000;  // >= QHD
                    } else if (window.screen.width >= 2048 && window.screen.height >= 1080) {
                        return 175000;  // >= 2k
                    } else if (window.screen.width >= 1920 && window.screen.height >= 1080) {
                        return 150000;
                    } else {
                        return 125000;
                    }
                }
            }
    
            static #determineOptimalScale(width, height, maxPoints) {
                function countPointsWithScale(scale) {
                    return Math.trunc(width * scale) * Math.trunc(height * scale);
                }
    
                if (countPointsWithScale(0.750) < maxPoints) {
                    return 0.750;
                } else if (countPointsWithScale(0.5) < maxPoints) {
                    return 0.5;
                } else if (countPointsWithScale(0.375) < maxPoints) {
                    return 0.375;
                } else {
                    return 0.25;
                }
            }
    
            static determineOptimalSizes(parentNode, canvasConfig = undefined) {
                const maxWidthPx = (canvasConfig !== undefined) ? canvasConfig.maxWidthPx : undefined;
                const maxHeightPx = (canvasConfig !== undefined) ? canvasConfig.maxHeightPx : undefined;
    
                const {width, height} = SizeUtils.#determineSize(parentNode, maxWidthPx, maxHeightPx);
    
                const scaleOverride = (canvasConfig !== undefined) ? canvasConfig.scale : undefined;
                const scale = (scaleOverride === undefined)
                    ? SizeUtils.#determineOptimalScale(width, height, SizeUtils.#determineMaxNumberOfPoints())
                    : scaleOverride;
                return { width, height, scale };
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2022-09-09
         */
        class Element {
            elementHead;
            elementTail;
    
            constructor(elementHead = 0, elementTail = 0) {
                this.elementHead = elementHead;
                this.elementTail = elementTail;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * Tools for working with the element head.
         *
         * The element head structure: <code>0x[type][beh.][flags][temp.]</code> (32b)
         * <pre>
         *     | type class   3b  | type modifiers                 5b  |
         *     | behaviour             4b  | special               4b  |
         *     | heat modifiers index                              8b  |
         *     | temperature                                       8b  |
         * </pre>
         *
         * Type modifier for powder-like types: (5b)
         * <pre>
         *     | sliding  1b |  direction  1b  | momentum  3b  |
         * </pre>
         *
         * Type modifier for solid-like types: (5b)
         * <pre>
         *     | neighbourhood type  1b |  body id  4b  |
         * </pre>
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class ElementHead {
    
            static FIELD_TYPE_CLASS_SIZE = 3;  // bits
            static TYPE_AIR = 0x0;
            static TYPE_EFFECT = 0x1;
            static TYPE_GAS = 0x2;
            static TYPE_POWDER_FLOATING = 0x3;   // floating, not wet, can turn into wet
            static TYPE_FLUID = 0x4;
            static TYPE_POWDER = 0x5;  // not wet, can turn into wet
            static TYPE_POWDER_WET = 0x6;  // wet
            static TYPE_STATIC = 0x7;
    
            static FIELD_TYPE_MODIFIERS_SIZE = 5;  // bits
    
            static FIELD_BEHAVIOUR_SIZE = 4;  // bits
            static BEHAVIOUR_NONE = 0x0;
            static BEHAVIOUR_SOIL = 0x1;
            static BEHAVIOUR_GRASS = 0x2;
            static BEHAVIOUR_FISH = 0x3;  // unused
            static BEHAVIOUR_FISH_BODY = 0x4;  // unused
            static BEHAVIOUR_TREE = 0x5;
            static BEHAVIOUR_TREE_ROOT = 0x6;
            static BEHAVIOUR_TREE_TRUNK = 0x7;
            static BEHAVIOUR_TREE_LEAF = 0x8;
            static BEHAVIOUR_FIRE = 0x9;
            static BEHAVIOUR_FIRE_SOURCE = 0xA;
            static BEHAVIOUR_METEOR = 0xB;
            static BEHAVIOUR_WATER = 0xC;
            static BEHAVIOUR_ENTITY = 0xD;
    
            static FIELD_SPECIAL_SIZE = 4;  // bits
    
            static FIELD_HMI_SIZE = 8;  // bits
    
            static FIELD_TEMPERATURE_SIZE = 8;  // bits
    
    
            static of(type8, behaviour8 = 0, modifiers8 = 0, temperature = 0) {
                let value = temperature << 8;
                value = (value | modifiers8) << 8;
                value = (value | behaviour8) << 8;
                value = value | type8;
                return value;
            }
    
            static type8(typeClass, typeModifiers = 0) {
                return typeClass | (typeModifiers << 3);
            }
    
            static type8Powder(typeClass, momentum = 0, sliding = 0, direction = 0) {
                let value = momentum << 1;
                value = (value | direction) << 1;
                value = (value | sliding) << 3;
                value = value | typeClass;
                return value;
            }
    
            // TODO TYPE_FLUID: density, step size, ? viscosity, ? pressure
            static type8Fluid(typeClass) {
                return typeClass;
            }
    
            static type8Solid(typeClass, bodyId = 0, extendedNeighbourhood = true) {
                let value = bodyId << 1;
                value = (value | (extendedNeighbourhood ? 0 : 1)) << 3;
                value = value | typeClass;
                return value;
            }
    
            static behaviour8(behaviour = 0, special = 0) {
                return behaviour | (special << 4);
            }
    
            static modifiers8(heatModIndex = 0) {
                return heatModIndex;
            }
    
            // get methods
    
            static getType(elementHead) {
                return elementHead & 0x000000FF;
            }
    
            static getTypeClass(elementHead) {
                return elementHead & 0x00000007;
            }
    
            static getTypeModifierPowderSliding(elementHead) {
                return (elementHead >> 3) & 0x00000001;
            }
    
            static getTypeModifierPowderDirection(elementHead) {
                return (elementHead >> 4) & 0x00000001;
            }
    
            static getTypeModifierPowderMomentum(elementHead) {
                return (elementHead >> 5) & 0x00000007;
            }
    
            static getTypeModifierSolidNeighbourhoodType(elementHead) {
                return (elementHead >> 3) & 0x00000001;
            }
    
            static getTypeModifierSolidBodyId(elementHead) {
                return (elementHead >> 4) & 0x0000000F;
            }
    
            static getBehaviour(elementHead) {
                return (elementHead >> 8) & 0x0000000F;
            }
    
            static getSpecial(elementHead) {
                return (elementHead >> 12) & 0x0000000F;
            }
    
            static getHeatModIndex(elementHead) {
                return (elementHead >> 16) & 0x000000FF;
            }
    
            static getTemperature(elementHead) {
                return (elementHead >> 24) & 0x000000FF;
            }
    
            // set methods
    
            static setType(elementHead, type) {
                return (elementHead & 0xFFFFFF00) | type;
            }
    
            static setTypeClass(elementHead, type) {
                return (elementHead & 0xFFFFFFF8) | type;
            }
    
            static setTypeModifierPowderSliding(elementHead, val) {
                return (elementHead & 0xFFFFFFF7) | (val << 3);
            }
    
            static setTypeModifierPowderDirection(elementHead, val) {
                return (elementHead & 0xFFFFFFEF) | (val << 4);
            }
    
            static setTypeModifierPowderMomentum(elementHead, val) {
                return (elementHead & 0xFFFFFF1F) | (val << 5);
            }
    
            static setTypeModifierSolidNeighbourhoodType(elementHead, val) {
                return (elementHead & 0xFFFFFFF7) | (val << 3);
            }
    
            static setTypeModifierSolidBodyId(elementHead, val) {
                return (elementHead & 0xFFFFFF0F) | (val << 4);
            }
    
            static setBehaviour(elementHead, behaviour) {
                return (elementHead & 0xFFFFF0FF) | (behaviour << 8);
            }
    
            static setSpecial(elementHead, special) {
                return (elementHead & 0xFFFF0FFF) | (special << 12);
            }
    
            static setHeatModIndex(elementHead, heatModIndex) {
                return (elementHead & 0xFF00FFFF) | (heatModIndex << 16);
            }
    
            static setTemperature(elementHead, temperature) {
                return (elementHead & 0x00FFFFFF) | (temperature << 24);
            }
    
    
            // --- HEAT MODIFIERS ---
    
            static #HEAT_MODS_COUNT = 16;
            static #HEAT_MODS = Array(ElementHead.#HEAT_MODS_COUNT);
    
            static #defHeatMods({i, conductiveIndex = 0.2, heatLossChanceTo10000 = 2500,
                                    flammableChanceTo10000 = 0, selfIgnitionChanceTo10000 = 0,
                                    flameHeat = 0, burnDownChanceTo10000 = 0,
                                    meltingTemperature = 0xFF + 1, meltingHMI = 0,
                                    hardeningTemperature = 0, hardeningHMI = 0}) {
    
                const array = Array(10);
                array[0] = conductiveIndex;
                array[1] = heatLossChanceTo10000;
                array[2] = flammableChanceTo10000;
                array[3] = selfIgnitionChanceTo10000;
                array[4] = flameHeat;
                array[5] = burnDownChanceTo10000;
                array[6] = meltingTemperature;
                array[7] = meltingHMI;
                array[8] = hardeningTemperature;
                array[9] = hardeningHMI;
    
                ElementHead.#HEAT_MODS[i] = array;
                return i;
            }
    
            static HMI_DEFAULT = ElementHead.#defHeatMods({
                i: 0
                // default values
            });
    
            static HMI_CONDUCTIVE_1 = ElementHead.#defHeatMods({
                i: 1,
                conductiveIndex: 0.25,
                heatLossChanceTo10000: 500
            });
    
            static HMI_CONDUCTIVE_2 = ElementHead.#defHeatMods({
                i: 2,
                conductiveIndex: 0.3,
                heatLossChanceTo10000: 20
            });
    
            static HMI_CONDUCTIVE_3 = ElementHead.#defHeatMods({
                i: 3,
                conductiveIndex: 0.45,
                heatLossChanceTo10000: 10
            });
    
            static HMI_GRASS_LIKE = ElementHead.#defHeatMods({
                i: 4,
                flammableChanceTo10000: 4500,
                selfIgnitionChanceTo10000: 3,
                flameHeat: 165,
                burnDownChanceTo10000: 1000
            });
    
            static HMI_WOOD_LIKE = ElementHead.#defHeatMods({
                i: 5,
                flammableChanceTo10000: 100,
                selfIgnitionChanceTo10000: 2,
                flameHeat: 165,
                burnDownChanceTo10000: 2
            });
    
            static HMI_LEAF_LIKE = ElementHead.#defHeatMods({
                i: 6,
                flammableChanceTo10000: 4500,
                selfIgnitionChanceTo10000: 3,
                flameHeat: 165,
                burnDownChanceTo10000: 100
            });
    
            static HMI_METAL = ElementHead.#defHeatMods({
                i: 7,
                conductiveIndex: 0.45,
                heatLossChanceTo10000: 10,
                meltingTemperature: 200,
                meltingHMI: 8
            });
    
            static HMI_MOLTEN = ElementHead.#defHeatMods({
                i: 8,
                conductiveIndex: 0.45,
                heatLossChanceTo10000: 10,
                hardeningTemperature: 150,
                hardeningHMI: 7
            });
    
            static HMI_COAL = ElementHead.#defHeatMods({
                i: 9,
                conductiveIndex: 0.3,
                heatLossChanceTo10000: 20,
                flammableChanceTo10000: 500,
                selfIgnitionChanceTo10000: 3,
                flameHeat: 190,
                burnDownChanceTo10000: 50
            });
    
            static HMI_THERMITE = ElementHead.#defHeatMods({
                i: 10,
                conductiveIndex: 0.45,
                heatLossChanceTo10000: 10,
                flammableChanceTo10000: 8000,
                selfIgnitionChanceTo10000: 500,
                flameHeat: 250,
                burnDownChanceTo10000: 1000
            });
            static HMI_OIL = ElementHead.#defHeatMods({
                i: 11,
                conductiveIndex: 0.3,
                heatLossChanceTo10000: 0,
                flammableChanceTo10000: 8000,
                selfIgnitionChanceTo10000: 200,
                flameHeat: 250,
                burnDownChanceTo10000: 3000
            });
    
            static {
                // fill missing definitions - bounds checking is not needed then...
                for (let i = 0; i < ElementHead.#HEAT_MODS_COUNT; i++) {
                    if (ElementHead.#HEAT_MODS[i] === undefined) {
                        ElementHead.#defHeatMods(i);
                    }
                }
            }
    
            // ---
    
            static hmiToConductiveIndex(heatModIndex) {
                return ElementHead.#HEAT_MODS[heatModIndex & 0xF][0];
            }
    
            static hmiToHeatLossChanceTo10000(heatModIndex) {
                return ElementHead.#HEAT_MODS[heatModIndex & 0xF][1];
            }
    
            // how hard it is to ignite this element
            static hmiToFlammableChanceTo10000(heatModIndex) {
                return ElementHead.#HEAT_MODS[heatModIndex & 0xF][2];
            }
    
            // how hard it is to ignite this element
            static hmiToSelfIgnitionChanceTo10000(heatModIndex) {
                return ElementHead.#HEAT_MODS[heatModIndex & 0xF][3];
            }
    
            // how much heat this element produces while burning
            static hmiToFlameHeat(heatModIndex) {
                return ElementHead.#HEAT_MODS[heatModIndex & 0xF][4];
            }
    
            // how hard it is to burn down this element
            static hmiToBurnDownChanceTo10000(heatModIndex) {
                return ElementHead.#HEAT_MODS[heatModIndex & 0xF][5];
            }
    
            static hmiToMeltingTemperature(heatModIndex) {
                return ElementHead.#HEAT_MODS[heatModIndex & 0xF][6];
            }
    
            static hmiToMeltingHMI(heatModIndex) {
                return ElementHead.#HEAT_MODS[heatModIndex & 0xF][7];
            }
    
            static hmiToHardeningTemperature(heatModIndex) {
                return ElementHead.#HEAT_MODS[heatModIndex & 0xF][8];
            }
    
            static hmiToHardeningHMI(heatModIndex) {
                return ElementHead.#HEAT_MODS[heatModIndex & 0xF][9];
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * Custom random implementation: "Mulberry32"
         * https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript/47593316#47593316
         *
         * @author Patrik Harag
         * @version 2023-12-20
         */
        class DeterministicRandom {
    
            static DEFAULT = new DeterministicRandom(106244033);
    
            static next(seed) {
                let t = seed + 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
    
            /** @type number */
            #last;
    
            constructor(seed) {
                this.#last = seed;
            }
    
            /**
             *
             * @return {number} (0..1)
             */
            next() {
                let t = this.#last += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
    
            /**
             *
             * @param max
             * @return {number} <0..max)
             */
            nextInt(max) {
                return Math.trunc(this.next() * max);
            }
    
            /**
             * Generator state.
             *
             * @return {number} integer
             */
            getState() {
                return this.#last;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2023-12-20
         */
        class Brush {
    
            /**
             *
             * @param x
             * @param y
             * @param random {DeterministicRandom}
             * @param oldElement {Element}
             * @return {Element}
             */
            apply(x, y, random = undefined, oldElement = undefined) {
                throw 'Not implemented'
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-29
         */
        class RandomBrush extends Brush {
    
            /** @type Brush[] */
            #list;
    
            constructor(list) {
                super();
                this.#list = list;
            }
    
            apply(x, y, random, oldElement) {
                if (this.#list.length > 1) {
                    const i = ((random) ? random : DeterministicRandom.DEFAULT).nextInt(this.#list.length);
                    const item = this.#list[i];
                    return item.apply(x, y, random, oldElement);
                } else if (this.#list.length === 1) {
                    const item = this.#list[0];
                    return item.apply(x, y, random, oldElement);
                } else {
                    return null;
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-29
         */
        class RandomElementBrush extends Brush {
    
            /** @type Element[] */
            #elements;
    
            constructor(elements) {
                super();
                this.#elements = elements;
            }
    
            apply(x, y, random, oldElement) {
                if (this.#elements.length > 1) {
                    const i = ((random) ? random : DeterministicRandom.DEFAULT).nextInt(this.#elements.length);
                    return this.#elements[i];
                } else if (this.#elements.length === 1) {
                    return this.#elements[0];
                } else {
                    return null;
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-05
         */
        class AbstractEffectBrush extends Brush {
    
            /** @type Brush|undefined */
            #innerBrush;
            constructor(innerBrush) {
                super();
                this.#innerBrush = innerBrush;
            }
    
            _retrieveElement(x, y, random, oldElement) {
                if (this.#innerBrush !== undefined) {
                    // use inner brush
                    return this.#innerBrush.apply(x, y, random);
                } else {
                    // use old element
                    return oldElement;
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * Tools for working with the element tail.
         *
         * The element head structure: <code>0x[flags][red][green][blue]</code> (32b)
         * <pre>
         *     |            2b  |            2b  | burnt lvl  2b  | blur type  2b  |
         *     | color red                                                     8b  |
         *     | color green                                                   8b  |
         *     | color blue                                                    8b  |
         * </pre>
         *
         * @author Patrik Harag
         * @version 2023-12-04
         */
        class ElementTail {
    
            static BLUR_TYPE_NONE = 0x0;
            /** This element acts as a background = blur can be applied over this element */
            static BLUR_TYPE_BACKGROUND = 0x1;
            static BLUR_TYPE_1 = 0x2;
    
            static HEAT_EFFECT_NONE = 0x0;
            static HEAT_EFFECT_1 = 0x1;
            static HEAT_EFFECT_2 = 0x2;
            static HEAT_EFFECT_3 = 0x3;
    
            static of(r, g, b, blurType=ElementTail.BLUR_TYPE_NONE, heatEffect=0, burntLevel=0) {
                let value = 0;
                value = (value | (heatEffect & 0x03)) << 2;
                value = (value | (burntLevel & 0x03)) << 2;
                value = (value | (blurType & 0x03)) << 8;
                value = (value | (r & 0xFF)) << 8;
                value = (value | (g & 0xFF)) << 8;
                value = value | (b & 0xFF);
                return value;
            }
    
            static getColorRed(elementTail) {
                return (elementTail >> 16) & 0x000000FF;
            }
    
            static getColorGreen(elementTail) {
                return (elementTail >> 8) & 0x000000FF;
            }
    
            static getColorBlue(elementTail) {
                return elementTail & 0x000000FF;
            }
    
            static getBlurType(elementTail) {
                return (elementTail >> 24) & 0x00000003;
            }
    
            static getBurntLevel(elementTail) {
                return (elementTail >> 26) & 0x00000003;
            }
    
            static getHeatEffect(elementTail) {
                return (elementTail >> 28) & 0x00000003;
            }
    
            static setColor(elementTail, r, g, b) {
                elementTail = (elementTail & ~(0x00FF0000)) | (r << 16);
                elementTail = (elementTail & ~(0x0000FF00)) | (g << 8);
                elementTail = (elementTail & ~(0x000000FF)) | (b);
                return elementTail;
            }
    
            static setBlurType(elementTail, blurType) {
                return (elementTail & 0xFCFFFFFF) | (blurType << 24);
            }
    
            static setBurntLevel(elementTail, burntLevel) {
                return (elementTail & 0xF3FFFFFF) | (burntLevel << 26);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-05
         */
        class ColorBrush extends AbstractEffectBrush {
    
            #r; #g; #b;
    
            constructor(r, g, b, innerBrush) {
                super(innerBrush);
                this.#r = r;
                this.#g = g;
                this.#b = b;
            }
    
            apply(x, y, random, oldElement) {
                const element = this._retrieveElement(x, y, random, oldElement);
    
                const newElementTail = ElementTail.setColor(element.elementTail, this.#r, this.#g, this.#b);
                return new Element(element.elementHead, newElementTail);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-05
         */
        class ColorPaletteRandomBrush extends AbstractEffectBrush {
    
            /** @type number[][] */
            #palette;
    
            constructor(innerBrush, palette) {
                super(innerBrush);
                if (typeof palette === 'string') {
                    // parse
                    this.#palette = palette.split('\n').map(line => line.split(',').map(Number));
                } else {
                    this.#palette = palette;
                }
            }
    
            apply(x, y, random, oldElement) {
                const element = this._retrieveElement(x, y, random, oldElement);
    
                const i = ((random) ? random : DeterministicRandom.DEFAULT).nextInt(this.#palette.length);
                const [r, g, b] = this.#palette[i];
    
                const newElementTail = ElementTail.setColor(element.elementTail, r, g, b);
                return new Element(element.elementHead, newElementTail);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-09
         */
        class Assets {
    
            /**
             *
             * @param base64
             * @param maxWidth {number|undefined}
             * @param maxHeight {number|undefined}
             * @returns {Promise<ImageData>}
             */
            static asImageData(base64, maxWidth=undefined, maxHeight=undefined) {
                function countSize(imageWidth, imageHeight) {
                    let w = imageWidth;
                    let h = imageHeight;
    
                    if (maxWidth !== undefined && w > maxWidth) {
                        const wScale = w / maxWidth;
                        w = maxWidth;
                        h = h / wScale;
                    }
                    if (maxHeight !== undefined && h > maxHeight) {
                        const hScale = h / maxHeight;
                        h = maxHeight;
                        w = w / hScale;
                    }
    
                    return [Math.trunc(w), Math.trunc(h)];
                }
    
                return new Promise((resolve, reject) => {
                    try {
                        // http://stackoverflow.com/questions/3528299/get-pixel-color-of-base64-png-using-javascript
                        let image = new Image();
                        image.onload = () => {
                            let canvas = document.createElement('canvas');
                            let [w, h] = countSize(image.width, image.height);
                            canvas.width = w;
                            canvas.height = h;
    
                            let context = canvas.getContext('2d');
                            context.drawImage(image, 0, 0, canvas.width, canvas.height);
    
                            let imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                            resolve(imageData);
                        };
                        image.onerror = () => {
                            reject('Cannot load image');
                        };
                        image.src = base64;
                    } catch (e) {
                        reject(e);
                    }
                });
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-05
         */
        class ColorTextureBrush extends AbstractEffectBrush {
    
            /** @type ImageData|null */
            #imageData = null;
    
            constructor(innerBrush, base64) {
                super(innerBrush);
    
                Assets.asImageData(base64).then(imageData => this.#imageData = imageData);
            }
    
            apply(x, y, random, oldElement) {
                const element = this._retrieveElement(x, y, random, oldElement);
    
                if (this.#imageData != null) {
                    const cx = x % this.#imageData.width;
                    const cy = y % this.#imageData.height;
                    const index = (cy * this.#imageData.width + cx) * 4;
    
                    const red = this.#imageData.data[index];
                    const green = this.#imageData.data[index + 1];
                    const blue = this.#imageData.data[index + 2];
                    // const alpha = this.#imageData.data[index + 3];
    
                    const newElementTail = ElementTail.setColor(element.elementTail, red, green, blue);
                    return new Element(element.elementHead, newElementTail);
    
                } else {
                    return element;
                }
            }
        }
    
        /*
         * A fast javascript implementation of simplex noise by Jonas Wagner
    
        Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
        Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
        With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
        Better rank ordering method by Stefan Gustavson in 2012.
    
         Copyright (c) 2022 Jonas Wagner
    
         Permission is hereby granted, free of charge, to any person obtaining a copy
         of this software and associated documentation files (the "Software"), to deal
         in the Software without restriction, including without limitation the rights
         to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         copies of the Software, and to permit persons to whom the Software is
         furnished to do so, subject to the following conditions:
    
         The above copyright notice and this permission notice shall be included in all
         copies or substantial portions of the Software.
    
         THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
         AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
         SOFTWARE.
         */
    
        // 
        const F2 =  0.5 * (Math.sqrt(3.0) - 1.0);
        const G2 =  (3.0 - Math.sqrt(3.0)) / 6.0;
        // I'm really not sure why this | 0 (basically a coercion to int)
        // is making this faster but I get ~5 million ops/sec more on the
        // benchmarks across the board or a ~10% speedup.
        const fastFloor = (x) => Math.floor(x) | 0;
        const grad2 = /*#__PURE__*/ new Float64Array([1, 1,
            -1, 1,
            1, -1,
            -1, -1,
            1, 0,
            -1, 0,
            1, 0,
            -1, 0,
            0, 1,
            0, -1,
            0, 1,
            0, -1]);
        /**
         * Creates a 2D noise function
         * @param random the random function that will be used to build the permutation table
         * @returns {NoiseFunction2D}
         */
        function createNoise2D(random = Math.random) {
            const perm = buildPermutationTable(random);
            // precalculating this yields a little ~3% performance improvement.
            const permGrad2x = new Float64Array(perm).map(v => grad2[(v % 12) * 2]);
            const permGrad2y = new Float64Array(perm).map(v => grad2[(v % 12) * 2 + 1]);
            return function noise2D(x, y) {
                // if(!isFinite(x) || !isFinite(y)) return 0;
                let n0 = 0; // Noise contributions from the three corners
                let n1 = 0;
                let n2 = 0;
                // Skew the input space to determine which simplex cell we're in
                const s = (x + y) * F2; // Hairy factor for 2D
                const i = fastFloor(x + s);
                const j = fastFloor(y + s);
                const t = (i + j) * G2;
                const X0 = i - t; // Unskew the cell origin back to (x,y) space
                const Y0 = j - t;
                const x0 = x - X0; // The x,y distances from the cell origin
                const y0 = y - Y0;
                // For the 2D case, the simplex shape is an equilateral triangle.
                // Determine which simplex we are in.
                let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
                if (x0 > y0) {
                    i1 = 1;
                    j1 = 0;
                } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
                else {
                    i1 = 0;
                    j1 = 1;
                } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
                // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
                // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
                // c = (3-sqrt(3))/6
                const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
                const y2 = y0 - 1.0 + 2.0 * G2;
                // Work out the hashed gradient indices of the three simplex corners
                const ii = i & 255;
                const jj = j & 255;
                // Calculate the contribution from the three corners
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 >= 0) {
                    const gi0 = ii + perm[jj];
                    const g0x = permGrad2x[gi0];
                    const g0y = permGrad2y[gi0];
                    t0 *= t0;
                    // n0 = t0 * t0 * (grad2[gi0] * x0 + grad2[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
                    n0 = t0 * t0 * (g0x * x0 + g0y * y0);
                }
                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 >= 0) {
                    const gi1 = ii + i1 + perm[jj + j1];
                    const g1x = permGrad2x[gi1];
                    const g1y = permGrad2y[gi1];
                    t1 *= t1;
                    // n1 = t1 * t1 * (grad2[gi1] * x1 + grad2[gi1 + 1] * y1);
                    n1 = t1 * t1 * (g1x * x1 + g1y * y1);
                }
                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 >= 0) {
                    const gi2 = ii + 1 + perm[jj + 1];
                    const g2x = permGrad2x[gi2];
                    const g2y = permGrad2y[gi2];
                    t2 *= t2;
                    // n2 = t2 * t2 * (grad2[gi2] * x2 + grad2[gi2 + 1] * y2);
                    n2 = t2 * t2 * (g2x * x2 + g2y * y2);
                }
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to return values in the interval [-1,1].
                return 70.0 * (n0 + n1 + n2);
            };
        }
        /**
         * Builds a random permutation table.
         * This is exported only for (internal) testing purposes.
         * Do not rely on this export.
         * @private
         */
        function buildPermutationTable(random) {
            const tableSize = 512;
            const p = new Uint8Array(tableSize);
            for (let i = 0; i < tableSize / 2; i++) {
                p[i] = i;
            }
            for (let i = 0; i < tableSize / 2 - 1; i++) {
                const r = i + ~~(random() * (256 - i));
                const aux = p[i];
                p[i] = p[r];
                p[r] = aux;
            }
            for (let i = 256; i < tableSize; i++) {
                p[i] = p[i - 256];
            }
            return p;
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-06
         */
        class VisualEffects {
    
            static isVisualBurnApplicable(elementHead) {
                const type = ElementHead.getTypeClass(elementHead);
                return type > ElementHead.TYPE_FLUID || type === ElementHead.TYPE_POWDER_FLOATING;
            }
    
            static visualBurn(elementTail, force = 1, maxBurntLevel = 3) {
                const burntLevel = ElementTail.getBurntLevel(elementTail);
                if (burntLevel > 2) {
                    return elementTail;
                }
    
                let newTail = elementTail;
    
                let newBurntLevel = burntLevel + force;
                newBurntLevel = Math.min(newBurntLevel, maxBurntLevel);
                newBurntLevel = Math.max(newBurntLevel, 0);
    
                const appliedForce = newBurntLevel - burntLevel;
                if (appliedForce > 0) {
                    newTail = ElementTail.setBurntLevel(newTail, newBurntLevel);
    
                    let red = ElementTail.getColorRed(elementTail);
                    let green = ElementTail.getColorGreen(elementTail);
                    let blue = ElementTail.getColorBlue(elementTail);
    
                    let divisor = 1.8 - (Math.random() * 0.5);
                    if (appliedForce > 1) {
                        divisor = divisor * (1.8 - (Math.random() * 0.5));
                    }
                    if (appliedForce > 2) {
                        divisor = divisor * (1.8 - (Math.random() * 0.5));
                    }
    
                    red = Math.trunc(red / divisor);
                    green = Math.trunc(green / divisor);
                    blue = Math.trunc(blue / divisor);
    
                    newTail = ElementTail.setColor(newTail, red, green, blue);
                }
    
                return newTail;
            }
    
            /**
             *
             * @param seed {number|number[]|null}
             * @returns {PerlinNoiseVisualEffect}
             */
            static visualNoiseProvider(seed = 0) {
                if (Array.isArray(seed)) {
                    const instances = seed.map(s => {
                        const random = new DeterministicRandom(s);
                        return createNoise2D(() => random.next());
                    });
                    return new PerlinNoiseVisualEffect(instances);
                } else {
                    const random = new DeterministicRandom(seed);
                    const noise2D = createNoise2D(() => random.next());
                    return new PerlinNoiseVisualEffect([noise2D]);
                }
            }
        }
    
        class PerlinNoiseVisualEffect {
            #noise2DInstances;
    
            constructor(noise2DInstances) {
                this.#noise2DInstances = noise2DInstances;
            }
    
            visualNoise(elementTail, x, y, factor = 1, threshold = 0.5, force = 0.1,
                        nr = 0x00, ng = 0x00, nb = 0x00) {
    
                const nose2D = this.#noise2DInstances[0];
    
                let value = (nose2D(x / factor, y / factor) + 1) / 2;  // 0..1
    
                // apply threshold
    
                if (value < threshold) {
                    return elementTail;
                }
                value = (value - threshold) * (1 / (1 - threshold));  // normalized 0..1
    
                // alpha blending
    
                const alpha = 1 - (value * force);
    
                let r = ElementTail.getColorRed(elementTail);
                let g = ElementTail.getColorGreen(elementTail);
                let b = ElementTail.getColorBlue(elementTail);
    
                r = Math.trunc(r * alpha) + (nr * (1 - alpha));
                g = Math.trunc(g * alpha) + (ng * (1 - alpha));
                b = Math.trunc(b * alpha) + (nb * (1 - alpha));
    
                return ElementTail.setColor(elementTail, r, g, b);
            }
    
            visualNoiseCombined(elementTail, x, y, coefficientList,
                        nr = 0x00, ng = 0x00, nb = 0x00) {
    
                let result = 0;
                for (let i = 0; i < coefficientList.length; i++) {
                    const { factor, threshold, force } = coefficientList[i];
                    const instance = this.#noise2DInstances[i % this.#noise2DInstances.length];
    
                    // apply factor and count value
                    let value = (instance(x / factor, y / factor) + 1) / 2;  // 0..1
    
                    // apply threshold
                    if (value < threshold) {
                        value = 0;
                    } else {
                        value = (value - threshold) * (1 / (1 - threshold));  // normalized 0..1
    
                        // apply force
                        value = value * force;
    
                        result += value;
                    }
                }
                result = Math.min(result, 1);
    
                // alpha blending
    
                const alpha = 1 - (result);
    
                let r = ElementTail.getColorRed(elementTail);
                let g = ElementTail.getColorGreen(elementTail);
                let b = ElementTail.getColorBlue(elementTail);
    
                r = Math.trunc(r * alpha) + (nr * (1 - alpha));
                g = Math.trunc(g * alpha) + (ng * (1 - alpha));
                b = Math.trunc(b * alpha) + (nb * (1 - alpha));
    
                return ElementTail.setColor(elementTail, r, g, b);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-06
         */
        class ColorNoiseBrush extends AbstractEffectBrush {
    
            #r; #g; #b;
    
            /**
             * @type {object|object[]}
             */
            #coefficients;
    
            #noise;
    
            constructor(innerBrush, coefficients, r, g, b) {
                super(innerBrush);
                this.#coefficients = coefficients;
                this.#r = r;
                this.#g = g;
                this.#b = b;
                if (Array.isArray(coefficients)) {
                    this.#noise = VisualEffects.visualNoiseProvider(coefficients.map(c => c.seed));
                } else {
                    this.#noise = VisualEffects.visualNoiseProvider(coefficients.seed);
                }
            }
    
            apply(x, y, random, oldElement) {
                const element = this._retrieveElement(x, y, random, oldElement);
    
                const coefficients = this.#coefficients;
                const r = this.#r;  // it could be null...
                const g = this.#g;
                const b = this.#b;
    
                let newElementTail;
                if (Array.isArray(coefficients)) {
                    newElementTail = this.#noise.visualNoiseCombined(element.elementTail, x, y, coefficients, r, g, b);
                } else {
                    const factor = coefficients.factor;  // it could be null...
                    const threshold = coefficients.threshold;
                    const force = coefficients.force;
                    newElementTail = this.#noise.visualNoise(element.elementTail, x, y, factor, threshold, force, r, g, b);
                }
                return new Element(element.elementHead, newElementTail);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-03-12
         */
        class ColorMovingPaletteBrush extends AbstractEffectBrush {
    
            /** @type number[][] */
            #palette;
    
            /** @type number */
            #stepSize;
    
            #i = 0;
            #direction = 1;
            #current = 0;
    
            constructor(innerBrush, palette, stepSize) {
                super(innerBrush);
                this.#palette = palette;
                this.#stepSize = stepSize;
            }
    
            apply(x, y, random, oldElement) {
                const element = this._retrieveElement(x, y, random, oldElement);
    
                if (this.#palette.length === 0) {
                    return element;
                }
    
                // retrieve current color
                const [r, g, b] = this.#palette[this.#i];
    
                if (this.#palette.length > 1) {
                    // count next index
                    this.#current += 1;
                    if (this.#current >= this.#stepSize) {
                        this.#current = 0;
                        this.#i += this.#direction;
                        if (this.#i < 0) {
                            // switch direction
                            this.#direction = 1;
                            this.#i = 1;
                        } else if (this.#i >= this.#palette.length) {
                            // switch direction
                            this.#direction = -1;
                            this.#i = this.#palette.length - 2;
                        }
                    }
                }
    
                const newElementTail = ElementTail.setColor(element.elementTail, r, g, b);
                return new Element(element.elementHead, newElementTail);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * This brush provides a bit of randomness to element colors.
         *
         * @author Patrik Harag
         * @version 2024-03-12
         */
        class ColorRandomize extends AbstractEffectBrush {
    
            #maxDiff;
    
            constructor(innerBrush, maxDiff) {
                super(innerBrush);
                this.#maxDiff = maxDiff;
            }
    
            apply(x, y, random, oldElement) {
                const element = this._retrieveElement(x, y, random, oldElement);
    
                let r = ElementTail.getColorRed(element.elementTail);
                let g = ElementTail.getColorGreen(element.elementTail);
                let b = ElementTail.getColorBlue(element.elementTail);
    
                r += random.nextInt(this.#maxDiff) * (random.nextInt(2) === 0 ? 1 : -1);
                g += random.nextInt(this.#maxDiff) * (random.nextInt(2) === 0 ? 1 : -1);
                b += random.nextInt(this.#maxDiff) * (random.nextInt(2) === 0 ? 1 : -1);
    
                r = Math.max(0, Math.min(255, r));
                g = Math.max(0, Math.min(255, g));
                b = Math.max(0, Math.min(255, b));
    
                const newElementTail = ElementTail.setColor(element.elementTail, r, g, b);
                return new Element(element.elementHead, newElementTail);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-02-20
         */
        class CustomBrush extends Brush {
    
            /** @type function(x: number, y: number, random: DeterministicRandom, oldElement: Element) */
            #func;
    
            constructor(func) {
                super();
                this.#func = func;
            }
    
            apply(x, y, random, oldElement) {
                return this.#func(x, y, random, oldElement);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * Special brush for counting elements.
         *
         * @author Patrik Harag
         * @version 2024-01-10
         */
        class CountingBrush extends Brush {
    
            static #NULL_REDICATE = function (elementHead, elementTail) {
                return false;
            };
    
            #predicate;
    
            #counterPositives = 0;
            #counterTotal = 0;
    
            /**
             *
             * @param predicate {function(number:elementHead, number:elementTail):boolean}
             */
            constructor(predicate = CountingBrush.#NULL_REDICATE) {
                super();
                this.#predicate = predicate;
            }
    
            apply(x, y, random, oldElement) {
                this.#counterTotal++;
                if (oldElement !== null) {
                    if (this.#predicate(oldElement.elementHead, oldElement.elementTail)) {
                        this.#counterPositives++;
                    }
                }
                return null;
            }
    
            getPositives() {
                return this.#counterPositives;
            }
    
            getTotal() {
                return this.#counterTotal;
            }
    
            reset() {
                this.#counterTotal = 0;
                this.#counterPositives = 0;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class PredicateDefs {
    
            static and(predicateA, predicateB) {
                return function (elementHead, elementTail) {
                    return predicateA(elementHead, elementTail) && predicateB(elementHead, elementTail);
                };
            }
    
            static or(predicateA, predicateB) {
                return function (elementHead, elementTail) {
                    return predicateA(elementHead, elementTail) || predicateB(elementHead, elementTail);
                };
            }
    
            static not(predicate) {
                return function (elementHead, elementTail) {
                    return !predicate(elementHead, elementTail);
                };
            }
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static TRUE = function (elementHead, elementTail) {
                return true;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_AIR = function (elementHead, elementTail) {
                return ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_AIR;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_EFFECT = function (elementHead, elementTail) {
                return ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_EFFECT;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_GAS = function (elementHead, elementTail) {
                return ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_GAS;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_FLUID = function (elementHead, elementTail) {
                return ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_FLUID;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_WATER = function (elementHead, elementTail) {
                return ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_WATER
                    && ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_FLUID;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_POWDER = function (elementHead, elementTail) {
                const typeClass = ElementHead.getTypeClass(elementHead);
                return typeClass === ElementHead.TYPE_POWDER
                    || typeClass === ElementHead.TYPE_POWDER_FLOATING
                    || typeClass === ElementHead.TYPE_POWDER_WET;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_SAND = function (elementHead, elementTail) {
                if (PredicateDefs.IS_POWDER(elementHead, elementTail)) {
                    return ElementHead.getBehaviour(elementHead) === 0
                        && ElementHead.getTypeModifierPowderMomentum(elementHead) === 6;
                }
                return false;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_SOIL = function (elementHead, elementTail) {
                if (PredicateDefs.IS_POWDER(elementHead, elementTail)) {
                    const behaviour = ElementHead.getBehaviour(elementHead);
                    return behaviour === ElementHead.BEHAVIOUR_SOIL;
                }
                return false;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_GRAVEL = function (elementHead, elementTail) {
                if (PredicateDefs.IS_POWDER(elementHead, elementTail)) {
                    return ElementHead.getBehaviour(elementHead) === 0
                        && ElementHead.getTypeModifierPowderMomentum(elementHead) === 3;
                }
                return false;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_STATIC = function (elementHead, elementTail) {
                return ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_STATIC;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_SOLID_BODY = function (elementHead, elementTail) {
                return ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_STATIC
                    && ElementHead.getTypeModifierSolidBodyId(elementHead) > 0;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_ENTITY = function (elementHead, elementTail) {
                return ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_ENTITY;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_BIOMASS = function (elementHead, elementTail) {
                const behaviour = ElementHead.getBehaviour(elementHead);
                return behaviour === ElementHead.BEHAVIOUR_GRASS
                    || behaviour === ElementHead.BEHAVIOUR_TREE
                    || behaviour === ElementHead.BEHAVIOUR_TREE_LEAF
                    || behaviour === ElementHead.BEHAVIOUR_TREE_TRUNK
                    || behaviour === ElementHead.BEHAVIOUR_TREE_ROOT
                    || behaviour === ElementHead.BEHAVIOUR_ENTITY;
            };
    
            /** @type {function(elementHead:number, elementTail:number):boolean} */
            static IS_TREE_PART = function (elementHead, elementTail) {
                const behaviour = ElementHead.getBehaviour(elementHead);
                return behaviour === ElementHead.BEHAVIOUR_TREE
                    || behaviour === ElementHead.BEHAVIOUR_TREE_LEAF
                    || behaviour === ElementHead.BEHAVIOUR_TREE_TRUNK
                    || behaviour === ElementHead.BEHAVIOUR_TREE_ROOT;
            };
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-07
         */
        class MeltingBrush extends AbstractEffectBrush {
    
            constructor(innerBrush) {
                super(innerBrush);
            }
    
            apply(x, y, random, oldElement) {
                const element = this._retrieveElement(x, y, random, oldElement);
                if (element === null) {
                    return null;
                }
    
                const heatModIndex = ElementHead.getHeatModIndex(element.elementHead);
                if (ElementHead.hmiToMeltingTemperature(heatModIndex) < (1 << ElementHead.FIELD_TEMPERATURE_SIZE)) {
                    let newElementHead = element.elementHead;
                    newElementHead = ElementHead.setHeatModIndex(newElementHead, ElementHead.hmiToMeltingHMI(heatModIndex));
                    newElementHead = ElementHead.setType(newElementHead, ElementHead.TYPE_FLUID);
    
                    let newElementTail = ElementTail.setBlurType(element.elementTail, ElementTail.BLUR_TYPE_1);
    
                    return new Element(newElementHead, newElementTail);
                }
                return element;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-03-23
         */
        class SolidBodyBrush extends AbstractEffectBrush {
    
            #solidBodyId;
            #extendedNeighbourhood;
    
            constructor(solidBodyId, extendedNeighbourhood, innerBrush) {
                super(innerBrush);
                this.#solidBodyId = solidBodyId;
                this.#extendedNeighbourhood = extendedNeighbourhood;
            }
    
            apply(x, y, random, oldElement) {
                const element = this._retrieveElement(x, y, random, oldElement);
    
                let elementHead = element.elementHead;
                const newType = ElementHead.type8Solid(ElementHead.TYPE_STATIC, this.#solidBodyId, this.#extendedNeighbourhood);
                elementHead = ElementHead.setType(elementHead, newType);
                return new Element(elementHead, element.elementTail);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-07
         */
        class ExtinguishedBrush extends AbstractEffectBrush {
    
            constructor(innerBrush) {
                super(innerBrush);
            }
    
            apply(x, y, random, oldElement) {
                const element = this._retrieveElement(x, y, random, oldElement);
                if (element === null) {
                    return null;
                }
    
                const behaviour = ElementHead.getBehaviour(element.elementHead);
                if (behaviour === ElementHead.BEHAVIOUR_FIRE_SOURCE) {
                    const newElementHead = ElementHead.setBehaviour(element.elementHead, ElementHead.BEHAVIOUR_NONE);
                    return new Element(newElementHead, element.elementTail);
                } else {
                    return null;
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-07
         */
        class Brushes {
    
            static #parsePalette(string) {
                return string.split('\n')
                    .filter(line => line.trim() !== '')
                    .map(line => line.split(',').map(Number));
            }
    
    
            /**
             *
             * @param predicate {(function(elementHead:number, elementTail:number):boolean)|undefined}
             * @returns {CountingBrush}
             */
            static counting(predicate) {
                return new CountingBrush(predicate);
            }
    
            /**
             *
             * @param func {function(x: number, y: number, random: DeterministicRandom, oldElement: Element)}
             * @returns {Brush}
             */
            static custom(func) {
                return new CustomBrush(func);
            }
    
            /**
             *
             * @param list {Element[]|Brush[]}
             * @returns {Brush}
             */
            static random(list) {
                let hasBrushes = undefined;
                for (let item of list) {
                    if (item instanceof Element) {
                        if (hasBrushes === true) {
                            throw 'Mixing Element and Brush instances';
                        }
                        hasBrushes = false;
                    } else if (item instanceof Brush) {
                        if (hasBrushes === false) {
                            throw 'Mixing Element and Brush instances';
                        }
                        hasBrushes = true;
                    } else {
                        throw 'Element or Brush instances expected';
                    }
                }
                return (hasBrushes) ? new RandomBrush(list) : new RandomElementBrush(list);
            }
    
            /**
             *
             * @param r {number} 0..255
             * @param g {number} 0..255
             * @param b {number} 0..255
             * @param innerBrush {Brush|undefined}
             * @return {Brush}
             */
            static color(r = 0, g = 0, b = 0, innerBrush = undefined) {
                return new ColorBrush(r, g, b, innerBrush);
            }
    
            /**
             *
             * @param base64
             * @param innerBrush {Brush|undefined}
             * @return {ColorTextureBrush}
             */
            static colorTexture(base64, innerBrush = undefined) {
                return new ColorTextureBrush(innerBrush, base64);
            }
    
            /**
             *
             * @param palette {number[][]|string}
             * @param innerBrush {Brush|undefined}
             * @returns {Brush}
             */
            static colorPaletteRandom(palette, innerBrush = undefined) {
                if (typeof palette === 'string') {
                    palette = Brushes.#parsePalette(palette);
                }
                return new ColorPaletteRandomBrush(innerBrush, palette);
            }
    
            /**
             *
             * @param palette {number[][]|string}
             * @param stepSize {number}
             * @param innerBrush {Brush|undefined}
             * @returns {Brush}
             */
            static colorPaletteCyclic(palette, stepSize = 1, innerBrush = undefined) {
                if (typeof palette === 'string') {
                    palette = Brushes.#parsePalette(palette);
                }
                return new ColorMovingPaletteBrush(innerBrush, palette, stepSize);
            }
    
            /**
             * This brush provides a bit of randomness to element colors.
             *
             * @param maxDiff {number}
             * @param innerBrush {Brush|undefined}
             * @returns {Brush}
             */
            static colorRandomize(maxDiff, innerBrush = undefined) {
                return new ColorRandomize(innerBrush, maxDiff);
            }
    
            /**
             *
             * @param coefficients {
             * {
             *     seed: number|undefined,
             *     factor: number|undefined,
             *     threshold: number|undefined,
             *     force: number|undefined,
             * }
             * |
             * {
             *     seed: number|undefined,
             *     factor: number|undefined,
             *     threshold: number|undefined,
             *     force: number|undefined,
             * }[]
             * }
             * @param r {number} 0..255
             * @param g {number} 0..255
             * @param b {number} 0..255
             * @param innerBrush {Brush|undefined}
             * @return {Brush}
             */
            static colorNoise(coefficients, r = undefined, g = undefined, b = undefined,
                    innerBrush = undefined) {
    
                return new ColorNoiseBrush(innerBrush, coefficients, r, g, b);
            }
    
            /**
             *
             * @param brush {Brush}
             * @param intensity {number} 0..1
             * @returns {Brush}
             */
            static withIntensity(intensity, brush) {
                return Brushes.custom((x, y, random, oldElement) => {
                    let rnd = ((random) ? random : DeterministicRandom.DEFAULT).next();
                    if (rnd < intensity) {
                        return brush.apply(x, y, random, oldElement);
                    }
                    return null;
                });
            }
    
            /**
             * Brush will not paint over other elements.
             *
             * @param brush {Brush}
             */
            static gentle(brush) {
                return Brushes.conditional(PredicateDefs.IS_AIR, brush);
            }
    
            /**
             * Brush will paint only over specific elements.
             *
             * @param predicate {function(elementHead:number, elementTail:number):boolean}
             * @param brush {Brush}
             */
            static conditional(predicate, brush) {
                return Brushes.custom((x, y, random, oldElement) => {
                    if (oldElement === null) {
                        return null;
                    }
                    if (predicate(oldElement.elementHead, oldElement.elementTail)) {
                        return brush.apply(x, y, random, oldElement);
                    }
                    return null;
                });
            }
    
            static temperature(value) {
                return Brushes.custom((x, y, random, oldElement) => {
                    if (oldElement === null) {
                        return null;
                    }
                    const newElementHead = ElementHead.setTemperature(oldElement.elementHead, value & 0xFF);
                    return new Element(newElementHead, oldElement.elementTail);
                });
            }
    
            static temperatureOrBrush(value, brush) {
                return Brushes.custom((x, y, random, oldElement) => {
                    if (oldElement === null) {
                        return brush.apply(x, y, random, null);
                    }
    
                    const typeClass = ElementHead.getTypeClass(oldElement.elementHead);
                    switch (typeClass) {
                        case ElementHead.TYPE_AIR:
                        case ElementHead.TYPE_EFFECT:
                            return brush.apply(x, y, random, oldElement);
    
                        case ElementHead.TYPE_POWDER:
                        case ElementHead.TYPE_POWDER_WET:
                        case ElementHead.TYPE_POWDER_FLOATING:
                        case ElementHead.TYPE_FLUID:
                        case ElementHead.TYPE_GAS:
                        case ElementHead.TYPE_STATIC:
                            const newElementHead = ElementHead.setTemperature(oldElement.elementHead, value & 0xFF);
                            return new Element(newElementHead, oldElement.elementTail);
    
                        default:
                            return brush.apply(x, y, random, null);
                    }
                });
            }
    
            static concat(first, second) {
                return Brushes.custom((x, y, random, oldElement) => {
                    const firstResult = first.apply(x, y, random, oldElement);
                    const secondResult = second.apply(x, y, random, firstResult !== null ? firstResult : oldElement);
                    return (secondResult !== null) ? secondResult : firstResult;
                });
            }
    
            static join(brushes) {
                return Brushes.custom((x, y, random, oldElement) => {
                    let last = oldElement;
                    for (let brush of brushes) {
                        const next = brush.apply(x, y, random, last);
                        if (next !== null) {
                            last = next;
                        }
                    }
                    return last;
                });
            }
    
            /**
             *
             * @param innerBrush {Brush|undefined}
             * @returns {Brush}
             */
            static molten(innerBrush) {
                return new MeltingBrush(innerBrush);
            }
    
            /**
             *
             * @param innerBrush {Brush|undefined}
             * @returns {Brush}
             */
            static extinguished(innerBrush) {
                return new ExtinguishedBrush(innerBrush)
            }
    
            /**
             * @param solidBodyId {number}
             * @param extendedNeighbourhood {boolean|undefined}
             * @param innerBrush {Brush|undefined}
             * @return {SolidBodyBrush}
             */
            static toSolidBody(solidBodyId, extendedNeighbourhood = undefined, innerBrush = undefined) {
                return new SolidBodyBrush(solidBodyId, extendedNeighbourhood, innerBrush);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-08
         */
        class ToolInfo {
    
            static NOT_DEFINED = new ToolInfo();
    
            #info
    
            /**
             *
             * @param info {{
             *     codeName: string|undefined,
             *     displayName: string|undefined,
             *     category: string|undefined,
             *     badgeStyle: CSSStyleDeclaration|undefined,
             * }}
             */
            constructor(info = {}) {
                this.#info = info;
            }
    
            derive(info) {
                const derivedInfo = {};
                Object.assign(derivedInfo, this.#info);
                Object.assign(derivedInfo, info);
                return new ToolInfo(derivedInfo);
            }
    
            /**
             *
             * @return {string|undefined}
             */
            getCategory() {
                return this.#info.category;
            }
    
            /**
             *
             * @return {string|undefined}
             */
            getDisplayName() {
                return this.#info.displayName;
            }
    
            /**
             *
             * @return {string|undefined}
             */
            getCodeName() {
                return this.#info.codeName;
            }
    
            /**
             *
             * @return {CSSStyleDeclaration|undefined}
             */
            getBadgeStyle() {
                return this.#info.badgeStyle;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2023-05-04
         */
        class CursorDefinition {
    
            /**
             *
             * @return {number}
             */
            getWidth() {
                throw 'Not implemented';
            }
    
            /**
             *
             * @return {number}
             */
            getHeight() {
                throw 'Not implemented';
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2024-02-08
         */
        class Tool {
    
            /** @type ToolInfo|null */
            #info;
    
            constructor(info = ToolInfo.NOT_DEFINED) {
                this.#info = info;
            }
    
            /**
             *
             * @returns {ToolInfo}
             */
            getInfo() {
                return this.#info;
            }
    
            hasCursor() {
                return false;
            }
    
            /**
             * @return {CursorDefinition|null}
             */
            createCursor() {
                // default cursor
                return null;
            }
    
            isRepeatingEnabled() {
                return false;
            }
    
            /**
             *
             * @param x {number}
             * @param y {number}
             * @param graphics {SandGameGraphics}
             * @param altModifier {boolean}
             * @return {void}
             */
            applyPoint(x, y, graphics, altModifier) {
                // no action by default
            }
    
            isLineModeEnabled() {
                return false;
            }
    
            onDragStart(x, y, graphics, altModifier) {
                // no action by default
            }
    
            onDragEnd(x, y, graphics, altModifier) {
                // no action by default
            }
    
            /**
             *
             * @param x1 {number}
             * @param y1 {number}
             * @param x2 {number}
             * @param y2 {number}
             * @param graphics {SandGameGraphics}
             * @param altModifier {boolean}
             * @return {void}
             */
            applyStroke(x1, y1, x2, y2, graphics, altModifier) {
                // no action by default
            }
    
            isAreaModeEnabled() {
                return false;
            }
    
            /**
             *
             * @param x1 {number}
             * @param y1 {number}
             * @param x2 {number}
             * @param y2 {number}
             * @param graphics {SandGameGraphics}
             * @param altModifier {boolean}
             * @return {void}
             */
            applyArea(x1, y1, x2, y2, graphics, altModifier) {
                // no action by default
            }
    
            /**
             *
             * @param x {number}
             * @param y {number}
             * @param graphics {SandGameGraphics}
             * @param altModifier {boolean}
             * @return {void}
             */
            applySpecial(x, y, graphics, altModifier) {
                // no action by default
            }
    
            isSecondaryActionEnabled() {
                return false;
            }
    
            /**
             *
             * @param x {number}
             * @param y {number}
             * @param graphics {SandGameGraphics}
             * @param altModifier {boolean}
             * @return {void}
             */
            applySecondaryAction(x, y, graphics, altModifier) {
                // no action by default
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-26
         */
        class RoundBrushTool extends Tool {
    
            /** @type Brush */
            #brush;
    
            /** @type number */
            #size;
    
            constructor(info, brush, size) {
                super(info);
                this.#brush = brush;
                this.#size = size;
            }
    
            getBrush() {
                return this.#brush;
            }
    
            isLineModeEnabled() {
                return true;
            }
    
            isAreaModeEnabled() {
                return true;
            }
    
            isRepeatingEnabled() {
                return true;
            }
    
            applyPoint(x, y, graphics, altModifier) {
                this.applyStroke(x, y, x, y, graphics, altModifier);
            }
    
            applyStroke(x1, y1, x2, y2, graphics, altModifier) {
                const brush = this.#currentBrush(altModifier);
                graphics.drawLine(x1, y1, x2, y2, this.#size, brush, true);
            }
    
            applyArea(x1, y1, x2, y2, graphics, altModifier) {
                const brush = this.#currentBrush(altModifier);
                graphics.drawRectangle(x1, y1, x2, y2, brush);
            }
    
            applySpecial(x, y, graphics, altModifier) {
                const brush = this.#currentBrush(altModifier);
                graphics.floodFill(x, y, brush, 1);
            }
    
            #currentBrush(altModifier) {
                let brush = this.#brush;
                if (altModifier) {
                    brush = Brushes.gentle(brush);
                }
                return brush;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-26
         */
        class RoundBrushToolForSolidBody extends Tool {
    
            /** @type Brush */
            #brush;
    
            /** @type Brush */
            #toSolidBodyBrush = Brushes.conditional(PredicateDefs.IS_STATIC, Brushes.toSolidBody(2, false));  // TODO: hardcoded
    
            /** @type number */
            #size;
    
            #drag = false;
            #dragBuffer = [];
    
            constructor(info, brush, size) {
                super(info);
                this.#brush = brush;
                this.#size = size;
            }
    
            getBrush() {
                return this.#brush;
            }
    
            isLineModeEnabled() {
                return true;
            }
    
            isAreaModeEnabled() {
                return true;
            }
    
            isRepeatingEnabled() {
                return false;
            }
    
            applyPoint(x, y, graphics, altModifier) {
                // ignored
            }
    
            applyStroke(x1, y1, x2, y2, graphics, altModifier) {
                const brush = this.#currentBrush(altModifier);
                graphics.drawLine(x1, y1, x2, y2, this.#size, brush, true);
            }
    
            applyArea(x1, y1, x2, y2, graphics, altModifier) {
                const brush = this.#currentBrush(altModifier);
                graphics.drawRectangle(x1, y1, x2, y2, brush);
            }
    
            applySpecial(x, y, graphics, altModifier) {
                const brush = this.#currentBrush(altModifier);
                graphics.floodFill(x, y, brush, 1);
            }
    
            onDragStart(x, y, graphics, altModifier) {
                this.#drag = true;
            }
    
            onDragEnd(x, y, graphics, altModifier) {
                this.#drag = false;
                for (const [ex, ey] of this.#dragBuffer) {
                    graphics.draw(ex, ey, this.#toSolidBodyBrush);
                }
                this.#dragBuffer = [];
            }
    
            #currentBrush(altModifier) {
                let brush = this.#brush;
                if (altModifier) {
                    brush = Brushes.gentle(brush);
                }
    
                if (this.#drag) {
                    return Brushes.custom((x, y, random, oldElement) => {
                        const element = brush.apply(x, y, random, oldElement);
                        if (element !== null) {
                            const elementHead = ElementHead.setType(element.elementHead, ElementHead.TYPE_STATIC);
                            this.#dragBuffer.push([x, y]);
                            return new Element(elementHead, element.elementTail);
                        }
                        return null;
                    });
                } else {
                    return brush;
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-25
         */
        class PointBrushTool extends Tool {
    
            /** @type {{dx: number, dy: number, brush: Brush}[]} */
            #points;
    
            constructor(info, points) {
                super(info);
                this.#points = points;
            }
    
            applyPoint(x, y, graphics, aldModifier) {
                for (const {dx, dy, brush} of this.#points) {
                    graphics.draw(x + dx, y + dy, brush);
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-12
         */
        class MeteorTool extends Tool {
    
            #meteor;
            #meteorFromLeft;
            #meteorFromRight;
    
            constructor(info, meteor, meteorFromLeft, meteorFromRight) {
                super(info);
                this.#meteor = meteor;
                this.#meteorFromLeft = meteorFromLeft;
                this.#meteorFromRight = meteorFromRight;
            }
    
            applyPoint(x, y, graphics, aldModifier) {
                const diffSlope4 = Math.trunc(y / 4);
                if (x < diffSlope4 + 10) {
                    // right only
                    graphics.draw(x + diffSlope4, 1, this.#meteorFromRight);
                    return;
                }
                if (x > graphics.getWidth() - diffSlope4 - 10) {
                    // left only
                    graphics.draw(x - diffSlope4, 1, this.#meteorFromLeft);
                    return;
                }
    
                if (x < graphics.getWidth() / 2) {
                    if (DeterministicRandom.DEFAULT.next() < 0.8) {
                        graphics.draw(x + diffSlope4, 1, this.#meteorFromRight);
                    } else {
                        graphics.draw(x, 1, this.#meteor);
                    }
                } else {
                    if (DeterministicRandom.DEFAULT.next() < 0.8) {
                        graphics.draw(x - diffSlope4, 1, this.#meteorFromLeft);
                    } else {
                        graphics.draw(x, 1, this.#meteor);
                    }
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-10-11
         */
        class ElementArea {
    
            /**
             * This element is used for templates etc.
             * @type {Element}
             */
            static TRANSPARENT_ELEMENT = new Element(0xFFFFFFFF, 0xFFFFFFFF);
    
            static LITTLE_ENDIAN = true;
    
            static create(width, height, defaultElement) {
                let bufferHeads = new DataView(new ArrayBuffer(width * height * 4));
                let bufferTails = new DataView(new ArrayBuffer(width * height * 4));
                let instance = new ElementArea(width, height, bufferHeads, bufferTails);
    
                // set default elements
                for (let y = 0; y < instance.#height; y++) {
                    for (let x = 0; x < instance.#width; x++) {
                        instance.setElement(x, y, defaultElement);
                    }
                }
                return instance;
            }
    
            /**
             *
             * @param width
             * @param height
             * @param dataHeads {ArrayBuffer}
             * @param dataTails {ArrayBuffer}
             * @returns {ElementArea}
             */
            static from(width, height, dataHeads, dataTails) {
                return new ElementArea(width, height, new DataView(dataHeads), new DataView(dataTails));
            }
    
    
            /** @type number */
            #width;
    
            /** @type number */
            #height;
    
            /** @type DataView */
            #bufferHeads;
    
            /** @type DataView */
            #bufferTails;
    
            constructor(width, height, bufferHeads, bufferTails) {
                this.#width = width;
                this.#height = height;
                this.#bufferHeads = bufferHeads;
                this.#bufferTails = bufferTails;
            }
    
            isValidPosition(x, y) {
                if (x < 0 || y < 0) {
                    return false;
                }
                if (x >= this.#width || y >= this.#height) {
                    return false;
                }
                return true;
            }
    
            setElement(x, y, element) {
                if (element !== null) {
                    this.setElementHeadAndTail(x, y, element.elementHead, element.elementTail);
                }
                // brushes can produce nulls
            }
    
            setElementHeadAndTail(x, y, elementHead, elementTail) {
                const byteOffset = (this.#width * y + x) * 4;
                this.#bufferHeads.setUint32(byteOffset, elementHead, ElementArea.LITTLE_ENDIAN);
                this.#bufferTails.setUint32(byteOffset, elementTail, ElementArea.LITTLE_ENDIAN);
            }
    
            setElementHead(x, y, elementHead) {
                const byteOffset = (this.#width * y + x) * 4;
                this.#bufferHeads.setUint32(byteOffset, elementHead, ElementArea.LITTLE_ENDIAN);
            }
    
            setElementTail(x, y, elementTail) {
                const byteOffset = (this.#width * y + x) * 4;
                this.#bufferTails.setUint32(byteOffset, elementTail, ElementArea.LITTLE_ENDIAN);
            }
    
            getElement(x, y) {
                const byteOffset = (this.#width * y + x) * 4;
                const elementHead = this.#bufferHeads.getUint32(byteOffset, ElementArea.LITTLE_ENDIAN);
                const elementTail = this.#bufferTails.getUint32(byteOffset, ElementArea.LITTLE_ENDIAN);
                return new Element(elementHead, elementTail);
            }
    
            getElementHead(x, y) {
                const byteOffset = (this.#width * y + x) * 4;
                return this.#bufferHeads.getUint32(byteOffset, ElementArea.LITTLE_ENDIAN);
            }
    
            getElementHeadOrNull(x, y) {
                if (this.isValidPosition(x, y)) {
                    return this.getElementHead(x, y);
                }
                return null;
            }
    
            getElementTail(x, y) {
                const byteOffset = (this.#width * y + x) * 4;
                return this.#bufferTails.getUint32(byteOffset, ElementArea.LITTLE_ENDIAN);
            }
    
            getElementTailOrNull(x, y) {
                if (this.isValidPosition(x, y)) {
                    return this.getElementTail(x, y);
                }
                return null;
            }
    
            swap(x, y, x2, y2) {
                const elementHead = this.getElementHead(x, y);
                const elementHead2 = this.getElementHead(x2, y2);
                this.setElementHead(x2, y2, elementHead);
                this.setElementHead(x, y, elementHead2);
    
                const elementTail = this.getElementTail(x, y);
                const elementTail2 = this.getElementTail(x2, y2);
                this.setElementTail(x2, y2, elementTail);
                this.setElementTail(x, y, elementTail2);
            }
    
            /**
             *
             * @return {ArrayBuffer}
             */
            getDataHeads() {
                return this.#bufferHeads.buffer;
            }
    
            /**
             *
             * @return {ArrayBuffer}
             */
            getDataTails() {
                return this.#bufferTails.buffer;
            }
    
            /**
             *
             * @return {number}
             */
            getWidth() {
                return this.#width;
            }
    
            /**
             *
             * @return {number}
             */
            getHeight() {
                return this.#height;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @author Patrik Harag
         * @version 2023-05-04
         */
        class CursorDefinitionElementArea extends CursorDefinition {
    
            /** @type ElementArea */
            #elementArea;
    
            constructor(elementArea) {
                super();
                this.#elementArea = elementArea;
            }
    
            getWidth() {
                return this.#elementArea.getWidth();
            }
    
            getHeight() {
                return this.#elementArea.getHeight();
            }
    
            getElementArea() {
                return this.#elementArea;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class InsertElementAreaTool extends Tool {
    
            static asElementArea(scene) {
                return scene.createElementArea(InsertElementAreaTool.DEFAULT_W, InsertElementAreaTool.DEFAULT_H,
                        ElementArea.TRANSPARENT_ELEMENT);
            }
    
    
            static DEFAULT_W = 30;
            static DEFAULT_H = 30;
    
            /** @type ElementArea */
            #elementArea;
            /** @type object[] */
            #serializedEntities;
            /** @type function */
            #onInsertHandler;
    
            constructor(info, elementArea, serializedEntities, onInsertHandler) {
                super(info);
                this.#elementArea = elementArea;
                this.#serializedEntities = serializedEntities;
                this.#onInsertHandler = onInsertHandler;
            }
    
            applyPoint(x, y, graphics, aldModifier) {
                const elementArea = this.#elementArea;
                const offsetX = x - Math.trunc(elementArea.getWidth() / 2);
                const offsetY = y - Math.trunc(elementArea.getHeight() / 2);
    
                // apply elements
                let brush = Brushes.custom((tx, ty) => {
                    const element = elementArea.getElement(tx - offsetX, ty - offsetY);
                    if (element.elementHead !== ElementArea.TRANSPARENT_ELEMENT.elementHead
                        && element.elementTail !== ElementArea.TRANSPARENT_ELEMENT.elementTail) {
    
                        return element;
                    }
                    return null;
                });
                if (aldModifier) {
                    brush = Brushes.gentle(brush);
                }
    
                for (let i = 0; i < elementArea.getWidth() && offsetX + i < graphics.getWidth(); i++) {
                    const tx = offsetX + i;
                    if (tx < 0) {
                        continue;
                    }
    
                    for (let j = 0; j < elementArea.getHeight() && offsetY + j < graphics.getHeight(); j++) {
                        const ty = offsetY + j;
                        if (ty < 0) {
                            continue;
                        }
    
                        graphics.draw(tx, ty, brush);
                    }
                }
    
                // apply entities
                for (const serializedEntity of this.#serializedEntities) {
                    const serializedClone = Object.assign({}, serializedEntity);
                    // map entity position
                    if (typeof serializedClone.x === 'number') {
                        serializedClone.x += offsetX;
                    }
                    if (typeof serializedClone.y === 'number') {
                        serializedClone.y += offsetY;
                    }
                    graphics.entities().insertEntity(serializedClone);
                }
    
                if (this.#onInsertHandler !== undefined) {
                    this.#onInsertHandler();
                }
            }
    
            hasCursor() {
                return true;
            }
    
            createCursor() {
                return new CursorDefinitionElementArea(this.#elementArea);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class InsertRandomSceneTool extends Tool {
    
            /** @type Scene[] */
            #scenes;
    
            #currentTool;
    
            /** @type function */
            #onInsertHandler;
    
            constructor(info, scenes, onInsertHandler) {
                super(info);
                this.#scenes = scenes;
                this.#onInsertHandler = onInsertHandler;
                this.#initRandomTool();
            }
    
            #initRandomTool() {
                if (this.#scenes.length === undefined || this.#scenes.length === 0) {
                    throw 'Scenes not set';
                }
    
                const i = DeterministicRandom.DEFAULT.nextInt(this.#scenes.length);
                const scene = this.#scenes[i];
                const elementArea = InsertElementAreaTool.asElementArea(scene);
                const serializedEntitiesOrNull = scene.createEntities();
                const serializedEntities = serializedEntitiesOrNull !== null ? serializedEntitiesOrNull : [];
                this.#currentTool = new InsertElementAreaTool(this.getInfo(), elementArea, serializedEntities, this.#onInsertHandler);
            }
    
            applyPoint(x, y, graphics, aldModifier) {
                this.#currentTool.applyPoint(x, y, graphics, aldModifier);
                this.#initRandomTool();
            }
    
            hasCursor() {
                return true;
            }
    
            createCursor() {
                return this.#currentTool.createCursor();
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-04
         */
        class ActionTool extends Tool {
    
            /** @type function */
            #handler;
    
            constructor(info, handler) {
                super(info);
                this.#handler = handler;
            }
    
            applyPoint(x, y, graphics, aldModifier) {
                this.#handler(x, y, graphics, aldModifier);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class PositionedElement extends Element {
    
            x;
            y;
    
            constructor(x, y, elementHead, elementTail) {
                super(elementHead, elementTail);
                this.x = x;
                this.y = y;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class FloodFillPainter {
    
            static NEIGHBOURHOOD_VON_NEUMANN = 0;
            static NEIGHBOURHOOD_MOORE = 1;
            static NEIGHBOURHOOD_SOLID_BODY = 2;
    
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type SandGameGraphics */
            #graphics;
    
            #neighbourhood;
    
            /**
             *
             * @param elementArea {ElementArea}
             * @param neighbourhood
             * @param graphics {SandGameGraphics}
             */
            constructor(elementArea, neighbourhood = FloodFillPainter.NEIGHBOURHOOD_VON_NEUMANN, graphics) {
                this.#elementArea = elementArea;
                this.#neighbourhood = neighbourhood;
                this.#graphics = graphics;
            }
    
            #createPattern() {
                if (this.#neighbourhood === FloodFillPainter.NEIGHBOURHOOD_SOLID_BODY) {
                    return 0b1111_1111;  // type class + solid body id (without neighbourhood type)
                } else {
                    return 0b1111_11100111;  // TODO: different for fluid, powder-like...
                }
            }
    
            /**
             *
             * @param x {number}
             * @param y {number}
             * @param brush {Brush}
             */
            paint(x, y, brush) {
                const pattern = this.#createPattern();
                const matcher = this.#normalize(this.#elementArea.getElementHead(x, y)) & pattern;
    
                const w = this.#elementArea.getWidth();
    
                const pointSet = new Set();
                const queue = [];
    
                let point = x + y * w;
                do {
                    let x = point % w;
                    let y = Math.trunc(point / w);
    
                    if (pointSet.has(point)) {
                        continue;  // already completed
                    }
    
                    this.#graphics.draw(x, y, brush);
                    pointSet.add(point);
    
                    // add neighbours
                    this.#tryAdd(x, y - 1, pattern, matcher, pointSet, queue);
                    this.#tryAdd(x + 1, y, pattern, matcher, pointSet, queue);
                    this.#tryAdd(x, y + 1, pattern, matcher, pointSet, queue);
                    this.#tryAdd(x - 1, y, pattern, matcher, pointSet, queue);
    
                    let extendedNeighbourhood = false;
                    if (this.#neighbourhood === FloodFillPainter.NEIGHBOURHOOD_MOORE) {
                        extendedNeighbourhood = true;
                    } else if (this.#neighbourhood === FloodFillPainter.NEIGHBOURHOOD_SOLID_BODY) {
                        const elementHead = this.#elementArea.getElementHead(x, y);
                        if (ElementHead.getTypeModifierSolidNeighbourhoodType(elementHead) === 0) {
                            extendedNeighbourhood = true;
                        }
                    }
    
                    if (extendedNeighbourhood) {
                        this.#tryAdd(x + 1, y + 1, pattern, matcher, pointSet, queue);
                        this.#tryAdd(x + 1, y - 1, pattern, matcher, pointSet, queue);
                        this.#tryAdd(x - 1, y + 1, pattern, matcher, pointSet, queue);
                        this.#tryAdd(x - 1, y - 1, pattern, matcher, pointSet, queue);
                    }
    
                } while ((point = queue.pop()) != null);
            }
    
            #tryAdd(x, y, pattern, matcher, pointSet, queue) {
                const w = this.#elementArea.getWidth();
                const h = this.#elementArea.getHeight();
    
                if (x < 0 || y < 0) {
                    return;
                }
                if (x >= w || y >= h) {
                    return;
                }
    
                if (!this.#equals(x, y, pattern, matcher)) {
                    return;
                }
    
                const point = x + y * w;
                if (pointSet.has(point)) {
                    return;
                }
    
                queue.push(point);
            }
    
            #equals(x, y, pattern, matcher) {
                let elementHead = this.#elementArea.getElementHead(x, y);
                elementHead = this.#normalize(elementHead);
                return (elementHead & pattern) === matcher;
            }
    
            #normalize(elementHead) {
                // wetness is ignored
                if (ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_POWDER_WET) {
                    elementHead = ElementHead.setTypeClass(elementHead, ElementHead.TYPE_POWDER);
                }
                return elementHead;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class CopyUtils {
    
            static copyNonSolidElements(graphicsCommands, replacementElement = null) {
                const elements = [];
    
                function canBeCopiedAsNonSolidElement(elementHead) {
                    const elementTypeClass = ElementHead.getTypeClass(elementHead);
                    if (elementTypeClass > ElementHead.TYPE_AIR && elementTypeClass < ElementHead.TYPE_STATIC) {
                        return true;
                    }
                    return false;
                }
    
                const brush = Brushes.custom((tx, ty, r, element) => {
                    if (canBeCopiedAsNonSolidElement(element.elementHead)) {
                        elements.push(new PositionedElement(tx, ty, element.elementHead, element.elementTail));
                        return replacementElement;  // remove
                    }
                    return null;  // ignore
                });
    
                graphicsCommands(brush);
    
                return elements;
            }
    
            static copySolidBodies(graphicsCommands, graphics, maxArea, replacementElement) {
                const elements = [];
    
                const brush = Brushes.custom((tx, ty, r, element) => {
                    if (ElementHead.getTypeClass(element.elementHead) === ElementHead.TYPE_STATIC
                            && ElementHead.getTypeModifierSolidBodyId(element.elementHead) !== 0) {
    
                        const newElements = CopyUtils.copySolidBody(tx, ty, graphics, maxArea, replacementElement);
                        for (const newElement of newElements) {
                            elements.push(newElement);
                        }
                    }
                    return null;  // ignore here
                });
    
                graphicsCommands(brush);
    
                return elements;
            }
    
            static copySolidBody(x, y, graphics, maxArea, replacementElement = null) {
                const solidBodyElements = [];
                const collectingBrush = Brushes.custom((tx, ty, random, element) => {
                    solidBodyElements.push(new PositionedElement(tx, ty, element.elementHead, element.elementTail));
                    return null;  // ignore here
                });
                graphics.floodFill(x, y, collectingBrush, FloodFillPainter.NEIGHBOURHOOD_SOLID_BODY);
    
                if (solidBodyElements.length > maxArea) {
                    return [];  // too big
                }
                for (let solidBodyElement of solidBodyElements) {
                    graphics.draw(solidBodyElement.x, solidBodyElement.y, replacementElement);
                }
                return solidBodyElements;
            }
    
            static copyEntities(graphicsCommands, graphics, defaultElement) {
                const elements = [];
                const entities = [];
    
                const brush = Brushes.custom((tx, ty, r, element) => {
                    for (const entity of graphics.entities().getAt(tx, ty)) {
                        if (entity.isActive()) {
                            const [extractedSerializedEntity, extractedElements] = entity.extract(defaultElement, 0, 0);
                            entities.push(extractedSerializedEntity);
                            elements.push(...extractedElements);
                        }
                    }
                    return null;  // ignore
                });
    
                graphicsCommands(brush);
    
                return [entities, elements];
            }
    
            static trimmed(elements, entities) {
                if (elements.length === 0) {
                    return [null, null];
                }
    
                let minX = Number.MAX_VALUE;
                let maxX = Number.MIN_VALUE;
                let minY = Number.MAX_VALUE;
                let maxY = Number.MIN_VALUE;
                for (const element of elements) {
                    minX = Math.min(minX, element.x);
                    maxX = Math.max(maxX, element.x);
                    minY = Math.min(minY, element.y);
                    maxY = Math.max(maxY, element.y);
                }
                const w = maxX - minX + 1;
                const h = maxY - minY + 1;
    
                // create element area
                const elementArea = ElementArea.create(w, h, ElementArea.TRANSPARENT_ELEMENT);
                for (const element of elements) {
                    const tx = element.x - minX;
                    const ty = element.y - minY;
                    elementArea.setElement(tx, ty, element);
                }
    
                // map entities
                for (let serializedEntity of entities) {
                    if (typeof serializedEntity.x === 'number') {
                        serializedEntity.x -= minX;
                    }
                    if (typeof serializedEntity.y === 'number') {
                        serializedEntity.y -= minY;
                    }
                }
    
                return [elementArea, entities];
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * It can be used to move elements from one place to another.
         * This tool works in three modes: click-click, drag-drop and selection-click.
         *
         * @author Patrik Harag
         * @version 2024-04-24
         */
        class MoveTool extends Tool {
    
            /** @type number */
            #size;
            /** @type number */
            #solidBodyMaxArea;
    
            /** @type InsertElementAreaTool */
            #insertScene = null;
    
            constructor(info, size, solidBodyMaxArea) {
                super(info);
                this.#size = size;
                this.#solidBodyMaxArea = solidBodyMaxArea;
            }
    
            // POINT & DRAG AND DROP ACTION
    
            applyPoint(x, y, graphics, altModifier) {
                if (this.#insertScene === null) {
                    this.#insertScene = this.#createInsertToolAt(x, y, graphics);
                } else {
                    this.#insertScene.applyPoint(x, y, graphics, altModifier);
                    this.#insertScene = null;
                }
            }
    
            onDragStart(x, y, graphics, altModifier) {
                // ignore
            }
    
            onDragEnd(x, y, graphics, altModifier) {
                if (this.#insertScene !== null) {
                    this.#insertScene.applyPoint(x, y, graphics, altModifier);
                    this.#insertScene = null;
                }
            }
    
            #createInsertToolAt(x, y, graphics) {
                const [elementArea, entities] = this.#copySingleElementsAt(x, y, graphics);
                return (elementArea !== null)
                        ? new InsertElementAreaTool(new ToolInfo(), elementArea, entities)
                        : null;
            }
    
            #copySingleElementsAt(x, y, graphics) {
                const defaultElement = graphics.getDefaults().getDefaultElement();
                const graphicsCommands = (brush) => graphics.drawLine(x, y, x, y, this.#size, brush, true);
    
                const elements = [];
    
                elements.push(...CopyUtils.copyNonSolidElements(graphicsCommands, defaultElement));
    
                elements.push(...CopyUtils.copySolidBodies(graphicsCommands, graphics, this.#solidBodyMaxArea, defaultElement));
    
                const [entities, entitiesElements] = CopyUtils.copyEntities(graphicsCommands, graphics, defaultElement);
                elements.push(...entitiesElements);
    
                return CopyUtils.trimmed(elements, entities);
            }
    
            // AREA ACTION
    
            isAreaModeEnabled() {
                return true;
            }
    
            applyArea(x1, y1, x2, y2, graphics, altModifier) {
                this.#insertScene = this.#createInsertTool(x1, y1, x2, y2, graphics);
            }
    
            #createInsertTool(x1, y1, x2, y2, graphics) {
                const [elementArea, entities] = this.#copyElements(x1, y1, x2, y2, graphics);
                return (elementArea !== null)
                    ? new InsertElementAreaTool(new ToolInfo(), elementArea, entities)
                    : null;
            }
    
            #copyElements(x1, y1, x2, y2, graphics) {
                const w = Math.abs(x1 - x2) + 1;
                const h = Math.abs(y1 - y2) + 1;
                const elementArea = ElementArea.create(w, h, ElementArea.TRANSPARENT_ELEMENT);
                const entities = [];
    
                const defaultElement = graphics.getDefaults().getDefaultElement();
                let empty = true;
                const brush = Brushes.custom((tx, ty, r, element) => {
    
                    // process entities
                    for (const entity of graphics.entities().getAt(tx, ty)) {
                        if (entity.isActive()) {
                            const [serializedEntity] = entity.extract(defaultElement, x1, y1);
                            entities.push(serializedEntity);
                        }
                    }
    
                    // process elements
                    if (ElementHead.getTypeClass(element.elementHead) > ElementHead.TYPE_AIR) {
                        let x = tx - Math.min(x1, x2);
                        let y = ty - Math.min(y1, y2);
                        elementArea.setElement(x, y, element);
                        empty = false;
                        return defaultElement;  // remove
                    }
                    return null;  // ignore
                });
    
                graphics.drawRectangle(x1, y1, x2, y2, brush, false);
    
                return (empty) ? null : [elementArea, entities];
            }
    
            // SECONDARY ACTION
    
            isSecondaryActionEnabled() {
                return (this.#insertScene !== null);
            }
    
            applySecondaryAction(x, y, graphics, altModifier) {
                this.#insertScene = null;
            }
    
            // CURSOR
    
            hasCursor() {
                return this.#insertScene !== null;
            }
    
            createCursor() {
                if (this.#insertScene !== null) {
                    return this.#insertScene.createCursor();
                } else {
                    return null;
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-07
         */
        class SelectionFakeTool extends Tool {
    
            #tools;
    
            constructor(info, tools) {
                super(info);
                this.#tools = tools;
            }
    
            getTools() {
                return this.#tools;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-08
         */
        class TemplateSelectionFakeTool extends Tool {
    
            #templateDefinitions;
    
            constructor(info, templateDefinitions) {
                super(info);
                this.#templateDefinitions = templateDefinitions;
            }
    
            getTemplateDefinitions() {
                return this.#templateDefinitions;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-04
         */
        class GlobalActionTool extends Tool {
    
            /** @type function(SandGame) */
            #handler;
    
            constructor(info, handler) {
                super(info);
                this.#handler = handler;
            }
    
            /**
             *
             * @return {function((SandGame))}
             */
            getHandler() {
                return this.#handler;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-03-23
         */
        class ProcessorContext {
    
            static OPT_CYCLES_PER_SECOND = 120;
            static OPT_FRAMES_PER_SECOND = 60;
    
    
            /**
             * @returns number
             */
            getIteration() {
                throw 'Not implemented';
            }
    
            /**
             * @returns GameDefaults
             */
            getDefaults() {
                throw 'Not implemented';
            }
    
            /**
             * @returns {boolean}
             */
            isFallThroughEnabled() {
                throw 'Not implemented';
            }
    
            /**
             * @returns {boolean}
             */
            isErasingEnabled() {
                throw 'Not implemented';
            }
    
            trigger(x, y) {
                throw 'Not implemented';
            }
    
            triggerSolidCreated(elementHead, x, y) {
                throw 'Not implemented';
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class GameState {
    
            /** @type ElementArea */
            elementArea;
            /** @type DeterministicRandom */
            random;
            /** @type ProcessorContext */
            processorContext;
            /** @type EntityManager */
            entityManager;
    
            constructor(elementArea, random, processorContext, entityManager) {
                this.elementArea = elementArea;
                this.random = random;
                this.processorContext = processorContext;
                this.entityManager = entityManager;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-26
         */
        class InsertEntityTool extends Tool {
    
            /** @type {function(object, GameState):Entity} */
            #entityFactory;
    
            /** @type {Entity} */
            #nextEntity;
    
            constructor(info, entityFactory) {
                super(info);
                this.#entityFactory = entityFactory;
    
                this.#createEntity();
            }
    
            #createEntity() {
                const tmpElementArea = ElementArea.create(1, 1, ElementArea.TRANSPARENT_ELEMENT);
                const tmpRandom = DeterministicRandom.DEFAULT;
                const tmpProcessorContext = new ProcessorContext();
                const gameState = new GameState(tmpElementArea, tmpRandom, tmpProcessorContext);
                this.#nextEntity = this.#entityFactory({}, gameState);
            }
    
            applyPoint(x, y, graphics, aldModifier) {
                const serialized = this.#nextEntity.serialize();
                serialized.x = x;
                serialized.y = y;
    
                graphics.entities().insertEntity(serialized);
    
                this.#createEntity();
            }
    
            hasCursor() {
                return true;
            }
    
            createCursor() {
                const boundaries = 2;
                const [w, h] = this.#nextEntity.countMaxBoundaries();
                const defaultElement = ElementArea.TRANSPARENT_ELEMENT;
                const tmpElementArea = ElementArea.create(w + 2 * boundaries, h + 2 * boundaries, defaultElement);
                const centerX = Math.trunc(tmpElementArea.getWidth() / 2);
                const centerY = Math.trunc(tmpElementArea.getHeight() / 2);
                this.#nextEntity.paint(centerX, centerY, tmpElementArea, DeterministicRandom.DEFAULT);
                return new CursorDefinitionElementArea(tmpElementArea);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-07
         */
        class Tools {
    
            static #info(info) {
                if (info instanceof ToolInfo) {
                    return info;
                }
                if (info === undefined) {
                    return ToolInfo.NOT_DEFINED;
                }
                if (typeof info === 'object') {
                    return new ToolInfo(info);
                }
                throw 'Incorrect tool info type: ' + (typeof info);
            }
    
            /**
             *
             * @param brush
             * @param size
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static roundBrushTool(brush, size, info) {
                return new RoundBrushTool(Tools.#info(info), brush, size);
            }
    
            /**
             *
             * @param brush
             * @param size
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static roundBrushToolForSolidBody(brush, size, info) {
                return new RoundBrushToolForSolidBody(Tools.#info(info), brush, size);
            }
    
            /**
             *
             * @param brush
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static pointBrushTool(brush, info) {
                return new PointBrushTool(Tools.#info(info), [{ dx: 0, dy: 0, brush: brush }]);
            }
    
            /**
             *
             * @param points {{dx: number, dy: number, brush: Brush}[]}
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static multiPointBrushTool(points, info) {
                return new PointBrushTool(Tools.#info(info), points);
            }
    
            /**
             *
             * @param meteor {Brush}
             * @param meteorFromLeft {Brush}
             * @param meteorFromRight {Brush}
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static meteorTool(meteor, meteorFromLeft, meteorFromRight, info) {
                return new MeteorTool(Tools.#info(info), meteor, meteorFromLeft, meteorFromRight);
            }
    
            /**
             *
             * @param scenes
             * @param handler
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static insertScenesTool(scenes, handler, info) {
                if (scenes.length === 1) {
                    const scene = scenes[0];
                    const elementArea = InsertElementAreaTool.asElementArea(scene);
                    const serializedEntitiesOrNull = scene.createEntities();
                    const serializedEntities = serializedEntitiesOrNull !== null ? serializedEntitiesOrNull : [];
                    return new InsertElementAreaTool(Tools.#info(info), elementArea, serializedEntities, handler);
                } else {
                    return new InsertRandomSceneTool(Tools.#info(info), scenes, handler);
                }
            }
    
            /**
             *
             * @param handler {function(x: number, y: number, graphics: SandGameGraphics, aldModifier: boolean)}
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static actionTool(handler, info) {
                return new ActionTool(Tools.#info(info), handler);
            }
    
            /**
             *
             * @param handler {function(SandGame)}
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static globalActionTool(handler, info) {
                return new GlobalActionTool(Tools.#info(info), handler);
            }
    
            /**
             *
             * @param size {number}
             * @param solidBodyMaxArea {number}
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static moveTool(size, solidBodyMaxArea, info) {
                return new MoveTool(Tools.#info(info), size, solidBodyMaxArea);
            }
    
            /**
             *
             * @param templateDefinitions
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static templateSelectionTool(templateDefinitions, info) {
                return new TemplateSelectionFakeTool(Tools.#info(info), templateDefinitions);
            }
    
            /**
             *
             * @param tools {Tool[]}
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static selectionTool(tools, info) {
                return new SelectionFakeTool(Tools.#info(info), tools);
            }
    
            /**
             *
             * @param entityFactory {function(serialized:object, gameState:GameState):Entity}
             * @param info {ToolInfo|object|undefined}
             * @return {Tool}
             */
            static insertEntityTool(entityFactory, info) {
                return new InsertEntityTool(Tools.#info(info), entityFactory);
            }
    
            // ---
    
            /**
             *
             * @param tools {Tool[]}
             * @param categoryDefinitions {Object<string, {displayName: string, badgeStyle: object}>}
             * @returns {Tool[]}
             */
            static grouping(tools, categoryDefinitions) {
                const groups = [];
                const selections = {};
                for (const tool of tools) {
                    const category = tool.getInfo().getCategory();
                    if (category !== undefined && categoryDefinitions[category] !== undefined) {
                        let selection = selections[category];
                        if (selection === undefined) {
                            selection = [];
                            selections[category] = selection;
                            groups.push(selection);
                        }
                        selection.push(tool);
                    } else {
                        groups.push(tool);
                    }
                }
    
                const groupedTools = [];
                for (const group of groups) {
                    if (Array.isArray(group)) {
                        const category = group[0].getInfo().getCategory();
                        const categoryDefinition = categoryDefinitions[category];
                        groupedTools.push(Tools.selectionTool(group, Tools.#info({
                            displayName: categoryDefinition.displayName,
                            codeName: 'category_' + category,
                            badgeStyle: categoryDefinition.badgeStyle
                        })));
                    } else {
                        groupedTools.push(group);
                    }
                }
                return groupedTools;
            }
    
        }
    
        var _ASSET_TREE_TRUNK_TEMPLATES = [{entriesCount:310,entries:[[0,-1,4],[0,1,1],[0,2,1],[0,3,1],[0,4,1],[0,5,1],[0,6,1],[0,7,1],[0,8,1],[0,9,1],[0,10,1],[0,11,1],[0,12,1],[0,13,1],[0,14,1],[0,15,1],[0,16,1],[0,17,1],[-1,17,1],[0,18,1],[1,18,1],[2,18,1],[3,19,1],[4,20,1],[5,21,2],[0,19,1],[0,20,1],[0,21,1],[0,22,1],[0,23,1],[-1,23,1],[-2,23,1],[-3,24,1],[-4,25,1],[-5,25,1],[-6,25,1],[-7,25,2],[0,24,1],[1,25,1],[1,26,1],[1,27,1],[2,28,1],[3,29,1],[4,30,1],[5,30,2],[0,28,1],[0,29,1],[-1,30,1,[[-2,31,1],[-3,31,1],[-4,31,2],[-2,32,1],[-1,33,1],[-1,34,1],[0,35,1],[0,36,2]]],[1,-1,4],[1,0,1],[1,1,1],[1,2,1],[1,3,1],[1,4,1],[1,5,1],[1,6,1],[1,7,1],[1,8,1],[1,9,1],[1,10,1],[1,11,1],[1,12,1],[1,13,1],[1,14,1],[1,15,1],[1,16,1],[1,17,1],[2,19,1],[1,19,1],[1,20,1],[1,21,1],[1,22,1],[1,23,1],[1,24,1],[2,25,1],[2,26,1],[2,27,1],[1,28,1],[1,29,1],[1,30,1],[1,31,1],[2,32,1],[2,33,1],[2,34,1],[3,34,1],[3,35,1],[4,35,1],[5,35,1],[6,36,1,[[7,36,1],[8,37,1],[8,38,2],[9,38,1],[10,39,1],[11,39,1],[12,40,1],[13,40,1],[14,40,1],[15,40,1],[16,40,2]]],[3,36,1],[3,37,1],[4,38,1],[5,39,1,[[6,40,1],[6,41,1],[6,42,1],[7,43,1],[8,44,2]]],[2,38,1,[[1,39,1],[0,39,1],[-1,40,1],[-2,40,1],[-2,41,2],[-3,41,1],[-4,41,1],[-5,42,1],[-6,42,1],[-7,43,1],[-8,43,1],[-9,43,2]]],[3,20,1],[4,21,1],[5,21,2],[5,22,1],[6,23,1],[7,24,1],[8,25,1],[8,26,2],[9,26,1,[]],[-1,-1,4],[-1,0,1],[-1,1,1],[-1,2,1],[-1,3,1],[-1,4,1],[-1,5,1],[-1,6,1],[-1,7,1],[-1,8,1],[-1,9,1],[-1,10,1],[-1,11,1],[-1,12,1],[-1,13,1],[-1,14,1],[-1,15,1],[-1,16,1],[-1,24,1],[-2,25,1],[-3,26,1],[-4,27,1],[-5,27,1],[-6,28,1],[-7,29,1],[-8,30,1],[-9,31,1],[-10,31,1,[[-9,32,1],[-9,33,1],[-9,34,1],[-9,35,1],[-8,36,1],[-7,36,1],[-6,36,1],[-5,37,2],[-8,37,1],[-7,38,1],[-7,39,1],[-6,40,1],[-6,41,1],[-9,38,1],[-10,38,2]]],[9,27,1],[10,28,1],[11,29,1],[12,30,1],[13,31,1],[13,32,1],[14,33,2],[10,30,1],[10,31,1],[9,32,1],[8,33,2],[12,41,1],[12,42,1],[13,43,1],[13,44,1],[13,45,1],[14,46,2],[-6,43,1],[-5,44,1],[-4,44,1],[-3,45,1],[-2,46,1],[-1,46,1],[0,47,1],[1,48,1],[2,48,1],[3,48,2],[-3,47,2],[-2,-1,4],[-2,0,1],[-2,1,1],[-2,2,1],[-2,3,1],[-2,4,1],[-2,5,1],[-2,6,1],[-2,7,1],[-2,8,1],[-2,9,1],[-2,10,1],[-2,11,1],[-2,12,1],[-2,13,1],[-2,14,1],[-2,15,1],[-2,16,1],[-2,17,1],[-1,18,1],[-1,19,1],[-1,20,1],[-1,21,1],[-1,22,1],[-2,24,1],[-3,25,1],[-4,26,1],[-5,26,1],[-6,27,1],[-7,28,1],[-8,29,1],[-9,30,1],[-10,30,2],[-10,31,1,[[-11,32,1],[-12,32,1],[-13,33,1],[-14,34,1],[-15,35,1],[-16,35,1],[-17,35,2],[-14,36,1],[-14,37,1],[-14,38,1],[-14,39,1],[-15,40,1],[-15,41,1],[-16,41,2],[-15,42,1],[-15,43,1,[[-16,44,1],[-16,45,1],[-15,45,1],[-14,46,1],[-13,46,1],[-12,47,1],[-12,48,2],[-11,48,1],[-10,49,1],[-9,49,1],[-8,50,1],[-7,51,1],[-6,52,2],[-16,46,1],[-16,47,1],[-17,48,1],[-17,49,1],[-18,50,2]]]]],[4,39,1],[4,40,1],[4,41,1],[4,42,1],[3,42,1],[4,43,1],[5,44,1],[5,45,1],[5,46,1],[6,47,1],[7,48,1],[8,49,1],[8,50,2],[5,48,1,[[4,49,1],[3,50,1],[2,51,1],[1,52,1],[1,53,1],[0,53,2],[0,54,1],[0,55,1],[0,56,1],[1,57,1],[2,57,1],[3,57,1],[4,58,2],[-1,57,1],[-2,57,1],[-3,58,1],[-4,59,2]]],[2,43,2]]},{entriesCount:319,entries:[[0,-1,4],[0,1,1],[0,2,1],[0,3,1],[0,4,1],[0,5,1],[0,6,1],[0,7,1],[0,8,1],[0,9,1],[0,10,1],[0,11,1],[0,12,1],[0,13,1],[0,14,1],[0,15,1],[0,16,1],[0,17,1],[0,18,1],[-1,18,1],[-2,18,1],[-3,19,1],[-4,20,1],[-5,21,2],[0,19,1],[0,20,1],[0,21,1],[0,22,1],[0,23,1],[1,23,1],[2,23,1],[3,24,1],[4,25,1],[5,25,1],[6,25,1],[7,25,2],[0,24,1],[-1,25,1],[-1,26,1],[-1,27,1],[0,28,1],[0,29,1],[1,30,1,[[2,31,1],[3,31,1],[4,31,2],[2,32,1],[1,33,1],[1,34,1],[0,35,1],[0,36,2]]],[-2,28,1],[-3,29,1],[-4,30,1],[-5,30,2],[-1,-1,4],[-1,0,1],[-1,1,1],[-1,2,1],[-1,3,1],[-1,4,1],[-1,5,1],[-1,6,1],[-1,7,1],[-1,8,1],[-1,9,1],[-1,10,1],[-1,11,1],[-1,12,1],[-1,13,1],[-1,14,1],[-1,15,1],[-1,16,1],[-1,17,1],[-1,19,1],[-2,19,1],[-1,20,1],[-1,21,1],[-1,22,1],[-1,23,1],[-1,24,1],[-2,25,1],[-2,26,1],[-2,27,1],[-1,28,1],[-1,29,1],[-1,30,1],[-1,31,1],[-2,32,1],[-2,33,1],[-2,34,1],[-3,34,1],[-3,35,1],[-4,35,1],[-5,35,1],[-6,36,1,[[-7,36,1],[-8,37,1],[-9,38,1],[-9,39,2],[-10,39,1],[-11,39,1],[-12,40,1],[-13,40,1],[-14,40,1],[-15,40,1],[-16,40,2]]],[-3,36,1],[-3,37,1],[-2,38,1,[[-1,39,1],[0,39,1],[1,40,1],[2,40,1],[3,41,1],[4,41,1],[5,42,1],[6,42,1],[7,43,1],[8,43,1],[9,44,2],[3,42,2],[-2,40,2]]],[-4,38,1],[-5,39,1,[[-6,40,1],[-6,41,1],[-6,42,1],[-7,43,1],[-7,44,2]]],[-3,20,1],[-4,21,1],[-5,21,2],[-5,22,1],[-6,23,1],[-7,24,1],[-8,25,1],[-8,26,2],[-9,26,1,[]],[1,-1,4],[1,0,1],[1,1,1],[1,2,1],[1,3,1],[1,4,1],[1,5,1],[1,6,1],[1,7,1],[1,8,1],[1,9,1],[1,10,1],[1,11,1],[1,12,1],[1,13,1],[1,14,1],[1,15,1],[1,16,1],[1,17,1],[1,18,1],[1,19,1],[1,24,1],[2,25,1],[3,26,1],[4,27,1],[5,27,1],[6,28,1],[7,29,1],[8,30,1],[9,31,1],[9,32,1],[9,33,1],[9,34,1],[8,34,2],[9,35,1],[8,36,1],[7,36,1],[6,36,1],[5,37,2],[8,37,1],[9,38,1],[7,38,1],[7,39,1],[6,40,1],[6,41,1],[-9,27,1],[-10,28,1],[-11,29,1],[-12,30,1],[-13,31,1],[-13,32,1],[-14,33,2],[-12,41,1],[-12,42,1],[-13,43,1],[-13,44,1],[-13,45,1],[-14,46,2],[6,43,1],[5,44,1],[4,44,1],[3,45,1],[2,45,1],[1,45,1],[0,45,2],[1,46,1],[0,47,1],[-1,48,1],[-2,48,1],[-3,48,2],[4,46,1],[5,47,2],[2,-1,4],[2,0,1],[2,1,1],[2,2,1],[2,3,1],[2,4,1],[2,5,1],[2,6,1],[2,7,1],[2,8,1],[2,9,1],[2,10,1],[2,11,1],[2,12,1],[2,13,1],[2,14,1],[2,15,1],[2,16,1],[2,17,1],[2,18,1],[2,19,1],[2,20,1],[1,20,1],[1,21,1],[1,22,1],[2,24,1],[3,25,1],[4,26,1],[5,26,1],[6,27,1],[7,28,1],[8,29,1],[9,30,1],[10,30,2],[10,31,1],[11,32,1],[12,33,1],[13,34,1],[14,35,1],[15,35,1],[16,35,2],[14,36,1],[14,37,1],[14,38,1],[14,39,1],[15,40,1],[15,41,1],[16,41,2],[8,38,1],[9,39,1],[10,40,1],[11,40,1],[12,41,1],[12,42,1],[13,43,1],[14,44,1],[15,45,1],[16,46,1],[16,47,1],[17,48,1],[17,49,1],[18,50,2],[14,46,1],[13,46,1],[12,47,1],[12,48,2],[11,48,1],[10,49,1],[9,49,1],[8,50,1],[7,51,1],[6,52,2],[-4,39,1],[-5,39,1,[[-4,40,1],[-4,41,1],[-4,42,1],[-4,43,1],[-5,44,1],[-5,45,1],[-5,46,1],[-6,47,1],[-6,48,1],[-6,49,1],[-6,50,1],[-7,50,2],[-6,51,1],[-7,52,1],[-8,52,1],[-9,53,1],[-9,54,1],[-10,55,2]]],[-2,49,1],[-2,50,1],[-2,51,1],[-2,52,1],[-1,53,1],[-1,54,1],[0,54,2],[-1,55,1],[0,56,1],[1,56,1],[2,57,1],[3,58,2],[-2,56,1],[-3,56,1],[-4,56,1],[-5,57,2]]},{entriesCount:269,entries:[[0,-1,4],[0,1,1],[0,2,1],[0,3,1],[0,4,1],[0,5,1],[0,6,1],[0,7,1],[0,8,1],[0,9,1],[0,10,1],[0,11,1],[0,12,1],[0,13,1],[0,14,1],[0,15,1],[0,16,1],[0,17,1],[0,18,1],[0,19,1],[0,20,1,[[-1,20,1],[0,21,1],[1,21,1],[2,22,1],[2,23,1],[3,24,1],[3,25,1],[2,25,2],[4,26,1],[5,27,1],[6,28,1],[7,28,1],[8,29,1],[9,30,1],[10,31,1],[11,32,2],[3,27,1],[3,28,1],[3,29,1],[2,30,1],[1,31,1],[0,31,2],[0,22,1],[0,23,1],[-1,24,1],[-2,25,1],[-2,26,1],[-3,27,1],[-4,28,1],[-5,29,1],[-6,29,2],[-5,30,1],[-6,31,1],[-7,31,1],[-8,31,1],[-9,32,1],[-10,32,1],[-11,33,2],[-2,21,1],[-3,22,1],[-4,23,1],[-5,23,2]]],[1,-1,4],[1,0,1],[1,1,1],[1,2,1],[1,3,1],[1,4,1],[1,5,1],[1,6,1],[1,7,1],[1,8,1],[1,9,1],[1,10,1],[1,11,1],[1,12,1],[1,13,1],[1,14,1],[1,15,1],[1,16,1],[1,17,1],[1,18,1],[1,19,1],[1,20,1],[0,20,1,[[-1,21,1],[-1,22,1],[-1,23,1]]],[-1,25,1],[-1,26,1],[-1,27,1],[-2,27,1],[-3,28,1],[-4,29,1],[0,28,1,[[1,29,1],[1,30,1],[2,31,1],[3,32,1],[3,33,1],[3,34,1],[4,35,1],[4,36,1],[4,37,1],[3,37,2],[0,31,2]]],[-5,31,1],[-5,32,1],[-5,33,1],[-6,34,1,[[-7,35,1],[-8,36,1],[-8,37,2],[-9,37,1],[-10,38,1],[-10,39,1],[-11,40,1],[-12,41,1],[-11,42,2]]],[-1,-1,4],[-1,0,1],[-1,1,1],[-1,2,1],[-1,3,1],[-1,4,1],[-1,5,1],[-1,6,1],[-1,7,1],[-1,8,1],[-1,9,1],[-1,10,1],[-1,11,1],[-1,12,1],[-1,13,1],[-1,14,1],[-1,15,1],[-1,16,1],[-1,17,1],[-1,18,1],[-1,19,1],[0,20,1,[]],[2,21,1],[3,22,1],[3,23,1],[4,24,1],[4,25,1],[5,26,1],[6,27,1],[6,29,1],[6,30,1],[7,31,1],[7,32,1],[7,33,1],[8,34,1],[8,35,1],[8,36,1],[8,37,1],[9,37,2],[8,38,1],[8,39,1],[9,40,1],[9,41,1],[9,42,1],[10,43,2],[-4,34,1],[-4,35,1],[-4,36,1],[-4,37,1],[-3,38,1],[-2,38,2],[-3,39,1],[-3,40,1],[-3,41,1],[-3,42,1],[-2,42,1],[-1,42,1],[0,43,1],[1,43,1],[2,43,1],[3,44,2],[-3,43,1],[-4,44,2],[2,-1,4],[2,0,1],[2,1,1],[2,2,1],[2,3,1],[2,4,1],[-2,5,1],[-2,6,1],[-2,7,1],[-2,8,1],[-2,9,1],[-2,10,1],[-2,11,1],[-2,12,1],[2,13,1],[2,14,1],[2,15,1],[2,16,1],[2,17,1],[2,18,1],[2,19,1],[2,20,1],[-5,27,1],[-6,27,1],[-7,28,1],[-8,28,1],[-9,29,1],[-10,29,1],[-11,29,1],[-12,29,1],[-13,29,1],[-14,29,2],[-14,30,1],[-15,31,1],[-15,32,1],[-16,33,1],[-16,34,1],[-17,35,1],[-17,36,1],[-18,37,2],[-6,29,2],[9,34,1],[10,35,1],[11,35,1],[12,36,1],[13,37,1],[14,37,1],[15,38,1],[16,38,1],[17,38,2],[-5,38,1],[-6,39,1],[-6,40,1],[-7,41,1],[-7,42,1],[-8,43,1],[-8,44,1],[-9,45,1],[-9,46,1],[-8,47,2],[-10,47,1],[-10,48,1],[-11,49,1],[-11,50,1],[-12,51,2],[7,39,1],[7,40,1],[6,41,1],[6,42,1],[6,43,1],[6,44,1],[5,45,1],[5,46,1],[5,47,1],[4,47,1],[5,48,1],[5,49,1],[4,50,1],[3,51,2],[3,48,1],[2,48,1],[1,48,1],[0,48,1],[-1,49,1],[-2,49,1],[-3,49,2]]},{entriesCount:268,entries:[[0,-1,4],[0,1,1],[0,2,1],[0,3,1],[0,4,1],[0,5,1],[0,6,1],[0,7,1],[0,8,1],[0,9,1],[0,10,1],[0,11,1],[0,12,1],[0,13,1],[0,14,1],[0,15,1],[0,16,1],[0,17,1],[0,18,1],[0,19,1],[0,20,1,[[1,20,1],[2,21,1],[3,22,1],[4,23,1],[5,23,2],[0,21,1],[-1,21,1],[0,22,1],[0,23,1],[1,24,1],[2,25,1],[2,26,1],[3,27,1],[4,28,1],[5,29,1],[6,29,2],[5,30,1],[6,31,1],[7,31,1],[8,31,1],[9,32,1],[10,32,1],[11,33,2],[-2,22,1],[-2,23,1],[-3,24,1],[-3,25,1],[-2,25,2],[-4,26,1],[-3,27,1],[-3,28,1],[-3,29,1],[-2,30,1],[-1,31,1],[0,31,2],[-5,27,1],[-6,28,1],[-7,28,1],[-8,29,1],[-9,30,1],[-10,31,1],[-11,31,1],[-12,31,1],[-13,31,2]]],[-1,-1,4],[-1,0,1],[-1,1,1],[-1,2,1],[-1,3,1],[-1,4,1],[-1,5,1],[-1,6,1],[-1,7,1],[-1,8,1],[-1,9,1],[-1,10,1],[-1,11,1],[-1,12,1],[-1,13,1],[-1,14,1],[-1,15,1],[-1,16,1],[-1,17,1],[-1,18,1],[-1,19,1],[-1,20,1],[0,20,1,[[1,21,1],[1,22,1],[1,23,1]]],[1,25,1],[1,26,1],[2,27,1],[3,28,1],[4,29,1],[4,30,1],[5,31,1],[5,32,1],[5,33,1],[6,34,1,[[7,35,1],[8,36,1],[8,37,2],[9,37,1],[10,38,1],[10,39,1],[11,40,1],[12,41,2]]],[-4,27,1],[-4,28,1],[-4,29,1],[-4,30,1],[-4,31,1],[-3,32,1],[-3,33,1],[-3,34,1],[-3,35,1],[-3,36,1],[-3,37,2],[1,-1,4],[1,0,1],[1,1,1],[1,2,1],[1,3,1],[1,4,1],[1,5,1],[1,6,1],[1,7,1],[1,8,1],[1,9,1],[1,10,1],[1,11,1],[1,12,1],[1,13,1],[1,14,1],[1,15,1],[1,16,1],[1,17,1],[1,18,1],[1,19,1],[0,20,1,[]],[-2,21,1],[-3,22,1],[-3,23,1],[-4,24,1],[-4,25,1],[-5,26,1],[-6,27,1],[-6,29,1],[-6,30,1],[-7,31,1],[-7,32,1],[-7,33,1],[-8,34,1],[-8,35,1],[-8,36,1],[-8,37,1],[-9,37,2],[-8,38,1],[-8,39,1],[-9,40,1],[-9,41,1],[-9,42,1],[-10,43,2],[4,34,1],[4,35,1],[4,36,1],[4,37,1],[3,38,1],[2,38,2],[3,39,1],[3,40,1],[3,41,1],[3,42,1],[2,42,1],[1,42,1],[0,43,1],[-1,43,1],[-2,43,1],[-3,44,2],[3,43,1],[4,44,2],[-2,-1,4],[-2,0,1],[-2,1,1],[-2,2,1],[-2,3,1],[-2,4,1],[-2,5,1],[-2,6,1],[-2,7,1],[-2,8,1],[-2,9,1],[-2,10,1],[-2,11,1],[-2,12,1],[-2,13,1],[-2,14,1],[-2,15,1],[-2,16,1],[-2,17,1],[-2,18,1],[-2,19,1],[-2,20,1],[6,25,1],[5,25,1],[4,25,1],[3,25,1],[7,26,1],[8,26,1],[9,27,1],[10,27,1],[11,27,2],[11,28,1],[12,28,1],[13,29,1],[14,30,1],[15,31,1],[16,31,2],[15,32,1],[16,33,1],[16,34,1],[17,35,1],[17,36,1],[17,37,2],[-9,34,1],[-10,35,1],[-11,35,1],[-12,36,1],[-13,37,1],[-14,37,1],[-15,38,1],[-16,39,2],[5,38,1],[6,39,1],[6,40,1],[7,41,1],[7,42,1],[8,43,1],[8,44,1],[9,45,1],[9,46,1],[10,47,1],[10,48,1],[11,49,1],[11,50,1],[12,51,2],[8,47,2],[-7,39,1],[-7,40,1],[-6,41,1],[-6,42,1],[-6,43,1],[-6,44,1],[-5,45,1],[-5,46,1],[-5,47,1],[-5,48,1],[-4,49,1],[-3,49,1],[-2,49,1],[-1,49,1],[0,49,1],[1,49,1],[2,49,2],[-4,50,1],[-5,51,2]]},{entriesCount:169,entries:[[0,-1,4],[0,1,1],[0,2,1],[0,3,1],[0,4,1],[0,5,1],[0,6,1],[0,7,1],[0,8,1],[0,9,1],[0,10,1],[0,11,1],[0,12,1],[0,13,1],[0,14,1],[0,15,1],[0,16,1],[0,17,1],[0,18,1],[0,19,1],[0,20,1,[[-1,20,1],[0,21,1],[1,21,1],[2,22,1],[2,23,1],[3,24,1],[3,25,1],[3,26,1],[4,27,1],[4,28,1],[4,29,2],[0,22,1],[0,23,1],[0,24,2],[-2,21,1],[-3,22,1],[-4,23,1],[-4,24,1],[-5,25,1],[-6,26,2]]],[1,-1,4],[1,0,1],[1,1,1],[1,2,1],[1,3,1],[1,4,1],[1,5,1],[1,6,1],[1,7,1],[1,8,1],[1,9,1],[1,10,1],[1,11,1],[1,12,1],[1,13,1],[1,14,1],[1,15,1],[1,16,1],[1,17,1],[1,18,1],[1,19,1],[1,20,1],[0,20,1,[[-1,21,1],[-1,22,1],[-1,23,1],[-1,24,1],[0,24,2],[-2,25,1],[-2,26,1],[-2,27,1],[-2,28,1],[-3,29,1],[-4,30,1],[-5,30,1],[-4,31,1],[-4,32,1],[-3,33,1],[-2,34,1],[-2,35,1],[-1,36,1],[0,36,1],[1,36,2],[-5,33,2],[-6,31,1],[-7,31,1],[-8,31,1],[-9,31,1],[-10,31,2]]],[-1,-1,4],[-1,0,1],[-1,1,1],[-1,2,1],[-1,3,1],[-1,4,1],[-1,5,1],[-1,6,1],[-1,7,1],[-1,8,1],[-1,9,1],[-1,10,1],[-1,11,1],[-1,12,1],[-1,13,1],[-1,14,1],[-1,15,1],[-1,16,1],[-1,17,1],[-1,18,1],[-1,19,1],[0,20,1,[]],[-5,24,1],[-6,24,1],[-7,24,1],[-8,24,1],[-9,24,1],[-10,24,1],[-11,24,2],[6,25,1],[5,25,1],[4,25,1],[7,26,1],[8,26,1],[9,26,2],[-1,25,1],[-1,26,1],[-1,27,1],[-1,28,1],[0,28,1],[1,29,1],[2,30,1],[3,31,1],[4,32,1],[5,32,1],[6,33,1],[7,33,1],[8,34,1],[9,34,2],[5,34,1],[5,35,1],[5,36,1],[5,37,1],[5,38,1],[6,39,2],[-1,29,1],[-1,30,1],[-1,31,1],[-1,32,1],[-1,33,1],[-1,34,1],[-1,35,1],[-3,35,1],[-4,36,1],[-5,37,1],[-6,38,1],[-7,39,2],[-1,37,1],[-1,38,1],[-1,39,1],[-1,40,1],[-2,40,1],[-1,41,1],[-1,42,2],[-3,41,1],[-4,42,1],[-5,42,1],[-6,43,1],[-7,43,2]]},{entriesCount:73,entries:[[0,-1,4],[0,1,1],[0,2,1],[0,3,1],[0,4,1],[0,5,1],[0,6,1],[0,7,1],[0,8,1],[0,9,1],[0,10,1],[0,11,1],[0,12,1],[0,13,1],[0,14,1],[-1,14,1,[[-2,14,1],[-3,14,1],[-4,15,1],[-5,16,2],[0,15,1],[0,16,1],[0,17,1],[0,18,1],[1,18,1,[[2,18,1],[3,19,1],[4,20,1],[5,20,2],[0,19,1],[-1,20,1],[-1,21,1],[-1,22,1],[0,23,1],[0,24,1],[1,25,1],[2,26,1],[3,26,1],[4,26,2],[-1,25,1],[-1,26,1],[-1,27,1],[-1,28,1],[0,29,1],[0,30,1],[0,31,2],[-2,23,1],[-3,24,1],[-4,25,1],[-5,25,2]]]]],[1,-1,4],[1,0,1],[1,1,1],[1,2,1],[1,3,1],[1,4,1],[1,5,1],[1,6,1],[1,7,1],[1,8,1],[1,9,1],[1,10,1],[1,11,1],[1,12,1],[1,13,1],[1,14,1],[1,15,1],[1,16,1],[1,17,1],[1,18,1,[]],[0,20,1],[0,21,1],[0,22,1]]},{entriesCount:60,entries:[[0,-1,4],[0,1,1],[0,2,1],[0,3,1],[0,4,1],[0,5,1],[0,6,1],[0,7,1],[0,8,1],[0,9,1],[0,10,1],[0,11,1],[0,12,1],[0,13,1],[0,14,1],[0,15,1],[-1,15,1],[0,16,1],[0,17,1],[1,18,1],[2,19,1],[3,20,1],[4,20,2],[1,20,1],[0,21,1],[0,22,1],[-1,22,1],[-2,23,1],[-3,24,2],[1,23,1],[2,24,1],[2,25,1],[3,26,2],[-2,16,1],[-3,17,1],[-3,18,1],[-3,19,2],[1,-1,4],[1,0,1],[1,1,1],[1,2,1],[1,3,1],[1,4,1],[-1,4,1],[-1,5,1],[-1,6,1],[-1,7,1],[-1,8,1],[-1,9,1],[-1,10,1],[1,10,1],[1,11,1],[1,12,1],[1,13,1],[1,14,1],[1,15,1],[1,16,1],[1,17,1],[0,18,1],[1,19,1]]},{entriesCount:55,entries:[[0,-1,4],[0,1,1],[0,2,1],[0,3,1],[0,4,1],[0,5,1],[0,6,1],[0,7,1],[-1,7,1],[-1,8,1],[-1,9,1],[-1,10,1],[-1,11,1],[-1,12,1],[-1,13,1],[-1,14,1],[-1,15,1],[0,15,1,[[1,16,1],[2,17,1],[3,18,2],[-1,16,1],[-1,17,1],[-1,18,1],[-1,19,1],[-1,20,1],[-1,21,1],[-1,22,1],[0,23,1],[1,24,1],[2,25,2],[-2,23,1],[-3,24,1],[-4,25,2]]],[-2,15,1,[[-3,16,1],[-4,17,1],[-5,18,2]]],[-1,-1,4],[-1,0,1],[-1,1,1],[-1,2,1],[-1,3,1],[-1,4,1],[-1,5,1],[-1,6,1],[-2,7,1],[-2,8,1],[-2,9,1],[-2,10,1],[-2,11,1],[-2,12,1],[-2,13,1],[-2,14,1],[-2,15,1,[]]]}];
    
        var _ASSET_TREE_CELL_TEMPLATES = [{entriesCount:49,entries:[[1,0,3,[[2,0,3],[1,-1,3],[2,-1,3],[3,0,3],[2,1,3],[3,-1,3],[3,1,3],[4,0,3],[3,-2,3],[3,2,3],[4,1,3],[4,-2,3]]],[-1,0,3,[[-2,0,3],[-3,0,3],[-2,1,3],[-2,-1,3],[-3,1,3],[-3,-1,3],[-4,0,3],[-2,2,3],[-3,2,3],[-2,3,3]]],[0,-1,3,[[-1,-1,3],[0,-2,3],[-1,-2,3],[0,-3,3],[1,-2,3],[-2,-2,3],[-1,-3,3],[1,-3,3],[2,-2,3],[2,-3,3],[3,-3,3]]],[0,1,3,[[1,1,3],[-1,1,3],[0,2,3],[1,2,3],[-1,2,3],[0,3,3],[2,2,3],[1,3,3],[2,3,3],[1,4,3],[3,3,3],[2,4,3]]]]},{entriesCount:55,entries:[[0,-1,3,[[0,-2,3],[-1,-1,3],[0,-3,3],[-1,-2,3],[1,-2,3],[-1,-3,3],[1,-3,3],[-2,-2,3],[2,-2,3]]],[-1,0,3,[[-2,0,3],[-2,-1,3],[-3,0,3],[-3,-1,3],[-4,0,3],[-3,1,3],[-4,-1,3],[-3,-2,3],[-4,1,3],[-3,2,3],[-4,-2,3]]],[1,0,3,[[1,-1,3],[1,1,3],[2,0,3],[2,-1,3],[2,1,3],[3,0,3],[3,-1,3],[3,1,3],[4,0,3],[4,-1,3],[3,-2,3],[4,1,3],[5,0,3],[5,-1,3],[4,-2,3]]],[0,1,3,[[0,2,3],[-1,1,3],[1,2,3],[-1,2,3],[0,3,3],[-2,1,3],[2,2,3],[1,3,3],[-2,2,3],[-1,3,3],[0,4,3],[2,3,3],[3,2,3],[1,4,3],[-1,4,3],[0,5,3]]]]},{entriesCount:82,entries:[[-1,0,3,[[-2,0,3],[-2,1,3],[-3,0,3],[-3,1,3],[-4,0,3],[-3,-1,3],[-4,1,3],[-4,-1,3],[-5,0,3],[-5,1,3],[-4,2,3],[-5,-1,3],[-4,-2,3],[-6,0,3],[-5,2,3],[-6,1,3],[-4,3,3],[-5,3,3]]],[0,1,3,[[0,2,3],[-1,1,3],[1,1,3],[-1,2,3],[1,2,3],[0,3,3],[-2,2,3],[-1,3,3],[1,3,3],[2,2,3],[0,4,3],[-2,3,3],[-1,4,3],[1,4,3],[2,3,3],[0,5,3],[3,3,3],[0,6,3],[3,4,3]]],[0,-1,3,[[1,-1,3],[0,-2,3],[-1,-1,3],[1,-2,3],[-1,-2,3],[0,-3,3],[-2,-1,3],[2,-2,3],[1,-3,3],[-1,-3,3],[-2,-2,3],[0,-4,3],[2,-3,3],[-1,-4,3],[-3,-2,3],[3,-3,3],[4,-3,3]]],[1,0,3,[[2,0,3],[3,0,3],[2,1,3],[2,-1,3],[3,1,3],[3,-1,3],[4,0,3],[4,1,3],[3,2,3],[4,-1,3],[3,-2,3],[5,0,3],[4,2,3],[5,1,3],[5,-1,3],[4,-2,3],[6,0,3],[4,3,3],[6,-1,3],[7,0,3],[4,4,3],[7,-1,3],[5,4,3],[4,5,3]]]]},{entriesCount:63,entries:[[1,0,3,[[2,0,3],[2,1,3],[2,-1,3],[3,0,3],[3,1,3],[3,-1,3],[4,0,3],[4,1,3],[4,-1,3],[3,-2,3],[5,0,3],[5,1,3],[5,-1,3],[6,0,3]]],[0,-1,3,[[-1,-1,3],[0,-2,3],[1,-1,3],[-2,-1,3],[-1,-2,3],[0,-3,3],[1,-2,3],[-2,-2,3],[-1,-3,3],[1,-3,3],[2,-2,3],[-3,-2,3],[2,-3,3]]],[0,1,3,[[1,1,3],[-1,1,3],[0,2,3],[1,2,3],[-1,2,3],[0,3,3],[2,2,3],[1,3,3],[-1,3,3],[-2,2,3],[3,2,3],[-2,3,3],[-1,4,3],[-3,2,3],[-3,3,3],[-2,4,3],[-4,2,3],[-4,3,3]]],[-1,0,3,[[-2,0,3],[-2,1,3],[-3,0,3],[-3,1,3],[-3,-1,3],[-4,0,3],[-4,1,3],[-4,-1,3],[-5,0,3],[-5,1,3],[-5,-1,3],[-6,0,3],[-6,1,3],[-5,2,3]]]]},{entriesCount:48,entries:[[-1,0,3,[[-1,-1,3],[-2,0,3],[-2,-1,3],[-3,0,3],[-3,-1,3],[-4,0,3],[-3,1,3],[-4,-1,3],[-3,-2,3],[-4,1,3],[-3,-3,3]]],[0,-1,3,[[1,-1,3],[0,-2,3],[1,-2,3],[0,-3,3],[-1,-2,3],[2,-2,3],[0,-4,3],[-1,-3,3],[-2,-2,3],[2,-3,3],[-1,-4,3],[-2,-3,3]]],[0,1,3,[[0,2,3],[-1,1,3],[1,2,3],[0,3,3],[-1,2,3],[-2,1,3],[-1,3,3],[-2,2,3],[-3,2,3]]],[1,0,3,[[1,1,3],[2,0,3],[2,1,3],[3,0,3],[2,-1,3],[3,1,3],[2,2,3],[4,0,3],[3,-1,3],[4,1,3],[3,2,3],[5,1,3]]]]},{entriesCount:57,entries:[[0,1,3,[[1,1,3],[0,2,3],[1,2,3],[-1,2,3],[0,3,3],[1,3,3],[2,2,3],[-1,3,3],[0,4,3],[2,3,3],[1,4,3],[-1,4,3],[-2,3,3],[0,5,3],[3,3,3],[2,4,3],[-1,5,3],[3,4,3]]],[-1,0,3,[[-2,0,3],[-1,-1,3],[-1,1,3],[-2,1,3],[-3,0,3],[-2,-1,3],[-2,2,3],[-3,1,3],[-3,-1,3],[-2,-2,3]]],[0,-1,3,[[0,-2,3],[-1,-2,3],[0,-3,3],[1,-2,3],[-1,-3,3],[1,-3,3],[0,-4,3],[-1,-4,3],[-2,-3,3],[2,-3,3],[1,-4,3],[0,-5,3],[-2,-4,3],[-1,-5,3],[3,-3,3],[2,-4,3],[1,-5,3],[3,-4,3]]],[1,0,3,[[1,-1,3],[2,0,3],[2,-1,3],[3,0,3],[2,1,3],[2,-2,3],[3,1,3]]]]},{entriesCount:86,entries:[[0,1,3,[[0,2,3],[-1,1,3],[0,3,3],[1,2,3],[-1,2,3],[1,3,3],[-1,3,3],[2,2,3],[-2,2,3],[2,3,3],[-2,3,3],[-3,2,3]]],[1,0,3,[[1,1,3],[2,0,3],[2,1,3],[3,0,3],[3,1,3],[3,-1,3],[4,0,3],[4,1,3],[3,2,3],[4,-1,3],[5,0,3],[4,2,3],[4,-2,3],[5,-1,3],[5,-2,3],[4,-3,3],[6,-1,3],[5,-3,3],[6,-2,3],[4,-4,3],[7,-1,3],[6,-3,3],[5,-4,3],[7,-2,3],[4,-5,3],[5,-5,3]]],[-1,0,3,[[-2,0,3],[-1,-1,3],[-3,0,3],[-2,1,3],[-2,-1,3],[-4,0,3],[-3,-1,3],[-3,1,3],[-2,-2,3],[-4,1,3],[-4,-1,3],[-3,-2,3],[-4,-2,3],[-3,-3,3],[-4,-3,3],[-5,-2,3],[-4,-4,3],[-5,-3,3],[-5,-4,3],[-6,-3,3],[-6,-4,3]]],[0,-1,3,[[1,-1,3],[0,-2,3],[1,-2,3],[2,-1,3],[-1,-2,3],[0,-3,3],[1,-3,3],[2,-2,3],[-1,-3,3],[1,-4,3],[2,-3,3],[3,-2,3],[-1,-4,3],[-2,-3,3],[2,-4,3],[3,-3,3],[-2,-4,3],[-1,-5,3],[2,-5,3],[-2,-5,3],[-3,-4,3],[-3,-5,3],[-2,-6,3]]]]},{entriesCount:41,entries:[[1,0,3,[[2,0,3],[1,1,3],[3,0,3],[2,1,3],[2,-1,3],[3,1,3],[3,-1,3],[4,0,3],[2,2,3],[4,1,3],[3,-2,3],[4,-2,3]]],[-1,0,3,[[-2,0,3],[-3,0,3],[-2,1,3],[-3,1,3],[-4,1,3],[-4,2,3]]],[0,1,3,[[0,2,3],[-1,1,3],[-1,2,3],[-1,3,3],[-2,2,3],[-2,3,3],[-3,2,3],[-2,4,3],[-3,3,3],[-3,4,3]]],[0,-1,3,[[0,-2,3],[1,-1,3],[-1,-1,3],[-1,-2,3],[1,-2,3],[2,-2,3],[2,-3,3],[3,-3,3],[3,-4,3]]]]},{entriesCount:47,entries:[[0,1,3,[[0,2,3],[1,1,3],[1,2,3],[-1,2,3],[1,3,3],[2,2,3],[-2,2,3]]],[-1,0,3,[[-1,-1,3],[-1,1,3],[-2,0,3],[-2,-1,3],[-2,1,3],[-3,0,3],[-3,-1,3],[-3,1,3],[-4,0,3],[-4,-1,3],[-4,1,3],[-5,0,3],[-5,1,3]]],[0,-1,3,[[1,-1,3],[0,-2,3],[1,-2,3],[-1,-2,3],[0,-3,3],[1,-3,3],[2,-2,3],[2,-3,3],[3,-2,3],[2,-4,3],[3,-3,3],[4,-2,3],[3,-4,3]]],[1,0,3,[[2,0,3],[2,1,3],[2,-1,3],[3,0,3],[3,1,3],[3,-1,3],[4,0,3],[4,-1,3],[5,0,3],[5,-1,3]]]]}];
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-18
         */
        class StructureDefs {
    
            /** @type {[]} */
            static TREE_TRUNK_TEMPLATES = _ASSET_TREE_TRUNK_TEMPLATES;
    
            /** @type {[]} */
            static TREE_CLUSTER_TEMPLATES = _ASSET_TREE_CELL_TEMPLATES;
        }
    
        var _ASSET_PALETTE_SAND = "214,212,154\n214,212,154\n214,212,154\n214,212,154\n225,217,171\n225,217,171\n225,217,171\n225,217,171\n203,201,142\n203,201,142\n203,201,142\n203,201,142\n195,194,134\n195,194,134\n218,211,165\n218,211,165\n223,232,201\n186,183,128";
    
        var _ASSET_PALETTE_SOIL = "142,104,72\n142,104,72\n142,104,72\n142,104,72\n142,104,72\n142,104,72\n114,81,58\n114,81,58\n114,81,58\n114,81,58\n114,81,58\n114,81,58\n82,64,30\n82,64,30\n82,64,30\n177,133,87\n177,133,87\n177,133,87\n102,102,102";
    
        var _ASSET_PALETTE_GRAVEL = "97,94,88\n111,110,106\n117,116,112\n117,117,113\n120,118,115\n104,102,97\n113,112,107\n129,128,125\n124,124,121\n81,80,75\n80,76,69\n123,119,111\n105,104,99\n84,82,78\n77,74,69\n91,88,82\n68,65,60\n79,75,69\n85,82,77\n98,94,88\n105,102,96\n104,97,86\n60,55,47\n93,89,81";
    
        var _ASSET_PALETTE_THERMITE = "137,86,89\n137,86,89\n137,86,89\n137,86,89\n137,86,89\n137,86,89\n125,70,72\n125,70,72\n147,93,96\n147,93,96\n138,84,86\n138,84,86\n118,72,75\n118,72,75\n101,61,65\n151,104,106";
    
        var _ASSET_PALETTE_COAL = "31,31,31\n46,44,41\n13,13,13\n17,17,15";
    
        var _ASSET_PALETTE_ASH = "131,131,131\n131,131,131\n131,131,131\n131,131,131\n131,131,131\n131,131,131\n135,135,135\n135,135,135\n135,135,135\n135,135,135\n135,135,135\n135,135,135\n145,145,145\n145,145,145\n145,145,145\n145,145,145\n145,145,145\n145,145,145\n148,148,148\n148,148,148\n148,148,148\n148,148,148\n148,148,148\n148,148,148\n160,160,160\n160,160,160\n160,160,160\n160,160,160\n160,160,160\n160,160,160\n114,114,114\n193,193,193";
    
        var _ASSET_PALETTE_WATER = "4,135,186\n5,138,189";
    
        var _ASSET_PALETTE_STEAM = "147,182,217\n163,188,212";
    
        var _ASSET_PALETTE_WALL = "55,55,55\n57,57,57";
    
        var _ASSET_PALETTE_TREE_WOOD_LIGHT = "133,108,80\n124,97,67";
    
        var _ASSET_PALETTE_TREE_WOOD_DARK = "94,70,42\n109,82,53";
    
        var _ASSET_PALETTE_TREE_ROOT = "75,54,31\n67,53,38";
    
        var _ASSET_PALETTE_TREE_LEAF_LIGHT = "128,137,79\n128,137,79\n128,137,79\n128,137,79\n128,137,79\n141,149,91\n141,149,91\n117,128,71\n99,110,65\n111,123,68\n121,132,73\n111,123,74";
    
        var _ASSET_PALETTE_TREE_LEAF_DARK = "74,86,47\n74,86,47\n74,86,47\n74,86,47\n68,77,40\n68,77,40\n68,77,40\n70,82,42\n70,82,42\n70,82,42\n72,82,46\n72,82,46\n78,90,48\n78,90,48\n95,106,60\n88,100,57\n66,74,36\n66,67,35\n76,87,52\n86,100,53\n75,89,47";
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class BrushDefs {
    
            static NONE = Brushes.custom(() => null);
    
            // TEST brushes
            // bright color for testing purposes
    
            static _TEST_SOLID = Brushes.random([
                new Element(
                    ElementHead.of(ElementHead.type8(ElementHead.TYPE_STATIC)),
                    ElementTail.of(255, 0, 125))
            ]);
    
            static _TEST_AIR = Brushes.random([
                new Element(
                    ElementHead.of(ElementHead.type8(ElementHead.TYPE_AIR)),
                    ElementTail.of(255, 0, 125))
            ]);
    
            // ---
    
            static AIR = Brushes.random([
                new Element(
                    ElementHead.of(ElementHead.type8(ElementHead.TYPE_AIR)),
                    ElementTail.of(255, 255, 255, ElementTail.BLUR_TYPE_BACKGROUND))
            ]);
    
            static WALL = Brushes.colorPaletteRandom(_ASSET_PALETTE_WALL, Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.TYPE_STATIC),
                        ElementHead.behaviour8(0),
                        ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_1)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_NONE, ElementTail.HEAT_EFFECT_2))
            ]));
    
            static ROCK = Brushes.join([
                Brushes.random([
                    new Element(
                        ElementHead.of(
                            ElementHead.type8(ElementHead.type8Solid(ElementHead.TYPE_STATIC, 1, false)),
                            ElementHead.behaviour8(),
                            ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_1)),
                        ElementTail.of(155, 155, 155, ElementTail.BLUR_TYPE_NONE, ElementTail.HEAT_EFFECT_2))
                ]),
                Brushes.colorNoise([
                    { seed: 40, factor: 60, threshold: 0.4, force: 0.9 },
                    { seed: 41, factor: 30, threshold: 0.4, force: 0.9 },
                    { seed: 42, factor: 15, threshold: 0.4, force: 0.5 },
                    { seed: 43, factor: 3, threshold: 0.1, force: 0.1 },
                ], 79, 69, 63),
                Brushes.colorNoise([
                    { seed: 51, factor: 30, threshold: 0.4, force: 0.9 },
                    { seed: 52, factor: 15, threshold: 0.4, force: 0.5 },
                    { seed: 53, factor: 3, threshold: 0.1, force: 0.1 },
                ], 55, 48, 46),
                Brushes.colorNoise([
                    { seed: 61, factor: 30, threshold: 0.4, force: 0.9 },
                    { seed: 62, factor: 15, threshold: 0.4, force: 0.5 },
                    { seed: 63, factor: 3, threshold: 0.1, force: 0.1 },
                ], 33, 29, 28)
            ]);
    
            static METAL = Brushes.join([
                Brushes.random([
                    new Element(
                        ElementHead.of(
                            ElementHead.type8(ElementHead.type8Solid(ElementHead.TYPE_STATIC, 2, false)),
                            ElementHead.behaviour8(),
                            ElementHead.modifiers8(ElementHead.HMI_METAL)),
                        ElementTail.of(155, 155, 155, ElementTail.BLUR_TYPE_NONE, ElementTail.HEAT_EFFECT_3))
                ]),
                Brushes.colorNoise([
                    { seed: 40, factor: 40, threshold: 0.4, force: 0.75 },
                    { seed: 40, factor: 20, threshold: 0.5, force: 0.4 },
                    { seed: 40, factor: 10, threshold: 0.4, force: 0.2 },
                    { seed: 40, factor: 5, threshold: 0.4, force: 0.1 },
                ], 135, 135, 135),
                Brushes.colorNoise([
                    { seed: 41, factor: 10, threshold: 0.4, force: 0.4 },
                    { seed: 41, factor: 6, threshold: 0.3, force: 0.3 },
                    { seed: 41, factor: 4, threshold: 0.5, force: 0.3 },
                ], 130, 130, 130)
            ]);
    
            static METAL_MOLTEN = Brushes.join([BrushDefs.METAL, Brushes.temperature(180), Brushes.molten()]);
    
            static SAND = Brushes.colorPaletteRandom(_ASSET_PALETTE_SAND, Brushes.custom((x, y, random) => {
                const type = random.nextInt(100) < 60 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
                const elementHead = ElementHead.of(
                    ElementHead.type8Powder(type, 6),
                    ElementHead.behaviour8(),
                    ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_2));
                const elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_2);
                return new Element(elementHead, elementTail);
            }));
    
            static SOIL = Brushes.colorPaletteRandom(_ASSET_PALETTE_SOIL, Brushes.custom((x, y, random) => {
                const type = random.nextInt(100) < 40 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
                const elementHead = ElementHead.of(
                    ElementHead.type8Powder(type, 5),
                    ElementHead.behaviour8(ElementHead.BEHAVIOUR_SOIL),
                    ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_1));
                const elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_1);
                return new Element(elementHead, elementTail);
            }));
    
            static GRAVEL = Brushes.colorPaletteRandom(_ASSET_PALETTE_GRAVEL, Brushes.custom((x, y, random) => {
                const type = random.nextInt(100) < 20 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
                const elementHead = ElementHead.of(
                    ElementHead.type8Powder(type, 3),
                    ElementHead.behaviour8(),
                    ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_2));
                const elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_2);
                return new Element(elementHead, elementTail);
            }));
    
            static COAL = Brushes.colorPaletteRandom(_ASSET_PALETTE_COAL, Brushes.custom((x, y, random) => {
                const type = random.nextInt(100) < 40 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
                const elementHead = ElementHead.of(
                    ElementHead.type8Powder(type, 4),
                    ElementHead.behaviour8(),
                    ElementHead.modifiers8(ElementHead.HMI_COAL));
                const elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_2, 3);
                return new Element(elementHead, elementTail);
            }));
    
            static THERMITE = Brushes.colorPaletteRandom(_ASSET_PALETTE_THERMITE, Brushes.custom((x, y, random) => {
                const type = random.nextInt(100) < 60 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
                const elementHead = ElementHead.of(
                    ElementHead.type8Powder(type, 5),
                    ElementHead.behaviour8(),
                    ElementHead.modifiers8(ElementHead.HMI_THERMITE));
                const elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_2, 3);
                return new Element(elementHead, elementTail);
            }));
    
            static OIL = Brushes.colorPaletteRandom("36,26,1", Brushes.custom((x, y, random) => {
                const elementHead = ElementHead.of(
                    ElementHead.type8Fluid(ElementHead.TYPE_FLUID),
                    ElementHead.behaviour8(),
                    ElementHead.modifiers8(ElementHead.HMI_OIL));
                const elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_2, 3);
                return new Element(elementHead, elementTail);
            }));
            static WATER = Brushes.colorPaletteRandom(_ASSET_PALETTE_WATER, Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8Fluid(ElementHead.TYPE_FLUID),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_WATER),
                        ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_3)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_NONE))
            ]));
    
            static STEAM = Brushes.colorPaletteRandom(_ASSET_PALETTE_STEAM, Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8Fluid(ElementHead.TYPE_GAS),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_WATER),
                        ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_3)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_NONE))
            ]));
    
            static GRASS = Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8Powder(ElementHead.TYPE_POWDER, 0),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_GRASS, 5),
                        ElementHead.modifiers8(ElementHead.HMI_GRASS_LIKE)),
                    ElementTail.of(56, 126, 38, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_1)),
                new Element(
                    ElementHead.of(
                        ElementHead.type8Powder(ElementHead.TYPE_POWDER, 0),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_GRASS, 3),
                        ElementHead.modifiers8(ElementHead.HMI_GRASS_LIKE)),
                    ElementTail.of(46, 102, 31, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_1)),
                new Element(
                    ElementHead.of(
                        ElementHead.type8Powder(ElementHead.TYPE_POWDER, 0),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_GRASS, 4),
                        ElementHead.modifiers8(ElementHead.HMI_GRASS_LIKE)),
                    ElementTail.of(72, 130, 70, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_1))
            ]);
    
            static TREE = Brushes.colorPaletteRandom(_ASSET_PALETTE_TREE_WOOD_DARK, Brushes.custom((x, y, random) => {
                let treeType = random.nextInt(StructureDefs.TREE_TRUNK_TEMPLATES.length);
                return new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.type8Solid(ElementHead.TYPE_STATIC, 3)),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE, treeType),
                        ElementHead.modifiers8(ElementHead.HMI_WOOD_LIKE)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_NONE, ElementTail.HEAT_EFFECT_1));
            }));
    
            static TREE_ROOT = Brushes.colorPaletteRandom(_ASSET_PALETTE_TREE_ROOT, Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.type8Solid(ElementHead.TYPE_STATIC, 3)),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_ROOT, 8),
                        ElementHead.modifiers8(ElementHead.HMI_WOOD_LIKE)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_NONE, ElementTail.HEAT_EFFECT_1)),
                new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.type8Solid(ElementHead.TYPE_STATIC, 3)),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_ROOT, 5),
                        ElementHead.modifiers8(ElementHead.HMI_WOOD_LIKE)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_NONE, ElementTail.HEAT_EFFECT_1))
            ]));
    
            static TREE_WOOD = Brushes.colorPaletteRandom(_ASSET_PALETTE_TREE_WOOD_LIGHT, Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.type8Solid(ElementHead.TYPE_STATIC, 3)),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_TRUNK, 0),
                        ElementHead.modifiers8(ElementHead.HMI_WOOD_LIKE)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_NONE, ElementTail.HEAT_EFFECT_1))
            ]));
    
            static TREE_WOOD_DARK = Brushes.colorPaletteRandom(_ASSET_PALETTE_TREE_WOOD_DARK, Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.type8Solid(ElementHead.TYPE_STATIC, 3)),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_TRUNK, 0),
                        ElementHead.modifiers8(ElementHead.HMI_WOOD_LIKE)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_NONE, ElementTail.HEAT_EFFECT_1))
            ]));
    
            static TREE_LEAF_LIGHTER = Brushes.colorPaletteRandom(_ASSET_PALETTE_TREE_LEAF_LIGHT, Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.type8Solid(ElementHead.TYPE_STATIC, 3)),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_LEAF, 0),
                        ElementHead.modifiers8(ElementHead.HMI_LEAF_LIKE)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_NONE, ElementTail.HEAT_EFFECT_1))
            ]));
    
            static TREE_LEAF_DARKER = Brushes.colorPaletteRandom(_ASSET_PALETTE_TREE_LEAF_DARK, Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.type8Solid(ElementHead.TYPE_STATIC, 3)),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_LEAF, 0),
                        ElementHead.modifiers8(ElementHead.HMI_LEAF_LIKE)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_NONE, ElementTail.HEAT_EFFECT_1))
            ]));
    
            static #FIRE_ELEMENT_HEAD = ElementHead.of(
                    ElementHead.type8(ElementHead.TYPE_EFFECT),
                    ElementHead.behaviour8(ElementHead.BEHAVIOUR_FIRE, 0));
            static FIRE = Brushes.random([
                new Element(ElementHead.setTemperature(BrushDefs.#FIRE_ELEMENT_HEAD, 255), ElementTail.of(249, 219, 30)),
                new Element(ElementHead.setTemperature(BrushDefs.#FIRE_ELEMENT_HEAD, 255), ElementTail.of(249, 219, 30)),
                new Element(ElementHead.setTemperature(BrushDefs.#FIRE_ELEMENT_HEAD, 120), ElementTail.of(249, 219, 30))
            ]);
    
            static ASH = Brushes.colorPaletteRandom(_ASSET_PALETTE_ASH, Brushes.custom((x, y, random) => {
                const type = random.nextInt(100) < 80 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
                const elementHead = ElementHead.of(
                    ElementHead.type8Powder(type, 6),
                    ElementHead.behaviour8(),
                    ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_2));
                const elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1, ElementTail.HEAT_EFFECT_2, 3);
                return new Element(elementHead, elementTail);
            }));
    
            static METEOR = Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.TYPE_STATIC),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_METEOR, 0)),
                    ElementTail.of(249, 219, 30))
            ]);
    
            static METEOR_FROM_LEFT = Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.TYPE_STATIC),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_METEOR, 1 << 1)),
                    ElementTail.of(249, 219, 30))
            ]);
    
            static METEOR_FROM_RIGHT = Brushes.random([
                new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.TYPE_STATIC),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_METEOR, 2 << 1)),
                    ElementTail.of(249, 219, 30))
            ]);
    
            static EFFECT_BURNT = Brushes.custom((x, y, random, oldElement) => {
                if (VisualEffects.isVisualBurnApplicable(oldElement.elementHead)) {
                    const burntLevel = ElementTail.getBurntLevel(oldElement.elementTail);
                    if (burntLevel < 3) {
                        return new Element(oldElement.elementHead, VisualEffects.visualBurn(oldElement.elementTail, 1));
                    }
                }
                return null;
            });
    
            static EFFECT_NOISE_LG = Brushes.colorNoise({ seed: 0, factor: 40, threshold: 0.5, force: 0.25 });
            static EFFECT_NOISE_MD = Brushes.colorNoise({ seed: 0, factor: 10, threshold: 0.5, force: 0.25 });
            static EFFECT_NOISE_SM = Brushes.colorNoise({ seed: 0, factor: 4, threshold: 0.5, force: 0.25 });
    
            static EFFECT_TEMP_0 = Brushes.temperature(0);
            static EFFECT_TEMP_127 = Brushes.temperature(127);
            static EFFECT_TEMP_200 = Brushes.temperature(200);
            static EFFECT_TEMP_255 = Brushes.temperature(255);
    
            static EFFECT_WET = Brushes.custom((x, y, random, oldElement) => {
                if (oldElement !== null) {
                    const typeClass = ElementHead.getTypeClass(oldElement.elementHead);
                    if (typeClass === ElementHead.TYPE_POWDER) {
                        const modifiedElementHead = ElementHead.setTypeClass(oldElement.elementHead, ElementHead.TYPE_POWDER_WET);
                        return new Element(modifiedElementHead, oldElement.elementTail);
                    } else {
                        return oldElement;
                    }
                }
                return null;
            });
    
            static EFFECT_MOLTEN = Brushes.molten();
            static EFFECT_EXTINGUISH = Brushes.extinguished();
    
            // --- SEARCH
    
            static _LIST = {
                none: BrushDefs.NONE,
                air: BrushDefs.AIR,
                ash: BrushDefs.ASH,
                sand: BrushDefs.SAND,
                soil: BrushDefs.SOIL,
                gravel: BrushDefs.GRAVEL,
                wall: BrushDefs.WALL,
                rock: BrushDefs.ROCK,
                metal: BrushDefs.METAL,
                metal_molten: BrushDefs.METAL_MOLTEN,
                wood: BrushDefs.TREE_WOOD,
                water: BrushDefs.WATER,
                oil: BrushDefs.OIL,
                steam: BrushDefs.STEAM,
                grass: BrushDefs.GRASS,
                tree: BrushDefs.TREE,
                tree_wood: BrushDefs.TREE_WOOD,
                tree_wood_dark: BrushDefs.TREE_WOOD_DARK,
                tree_leaf: BrushDefs.TREE_LEAF_LIGHTER,
                tree_leaf_dark: BrushDefs.TREE_LEAF_DARKER,
                tree_root: BrushDefs.TREE_ROOT,
                fire: BrushDefs.FIRE,
                meteor: BrushDefs.METEOR,
                meteor_l: BrushDefs.METEOR_FROM_LEFT,
                meteor_r: BrushDefs.METEOR_FROM_RIGHT,
                effect_temp_0: BrushDefs.EFFECT_TEMP_0,
                effect_temp_127: BrushDefs.EFFECT_TEMP_127,
                effect_temp_200: BrushDefs.EFFECT_TEMP_200,
                effect_temp_255: BrushDefs.EFFECT_TEMP_255,
                effect_burnt: BrushDefs.EFFECT_BURNT,
                effect_wet: BrushDefs.EFFECT_WET,
                effect_molten: BrushDefs.EFFECT_MOLTEN,
                effect_extinguished: BrushDefs.EFFECT_EXTINGUISH,
            }
    
            /**
             *
             * @param codeName {string}
             * @returns {Brush|null}
             */
            static byCodeName(codeName) {
                const brush = BrushDefs._LIST[codeName];
                if (brush !== undefined) {
                    return brush;
                }
                return null;
            }
        }
    
        var img$k = "data:image/png;base64,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";
    
        var img$j = "data:image/png;base64,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";
    
        var img$i = "data:image/png;base64,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";
    
        var img$h = "data:image/png;base64,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";
    
        var img$g = "data:image/png;base64,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";
    
        var img$f = "data:image/png;base64,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";
    
        var img$e = "data:image/png;base64,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";
    
        var img$d = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAwCAYAAAChS3wfAAAACXBIWXMAAAsTAAALEwEAmpwYAAADaUlEQVRoQ+2WO28cRQCAv5l93p69do5zTsQFBkehiJBRhKAxSNBRUCSFqfgBNEgRoqBLmS4lFIiKBv8BuiChoGBCZBxjiBDGTmHs6OLHPbzv2aEgAXtpswvS7tftp5mR5tPM7prUHLMo6kYToCjqRhOgKOpGE6Ao6kYToCjqRhOgKOpGE6Ao6kYToCjKZunKOzrNQhA5bW8Cr91hZeUOa+sboji2CioN8Mbrr+ooHpGpFKUihsMhz81N0eudYwH0fxGh1ADLy8v20tJS8uRZ6pzx8QgpQUqNEHCw36fddnl+bp619Y2T0yuh1AAnN3/t2kcvf3/7O5I0QqmUOEnIlSQYP8Sf7JDnioWXLlZ+CkoNcJJHu/3VVy5d4v79n+n3+xgYJGGCSlP8mWc5ODpiZrpTnFY6lQUYj0b4/gRtb5IDeYRKwRQSAcRhhFYKAby1uKhv3rpV2SmoLECWZQTBMVPTU+zs7JKoFNOw0TJjPBqQCxACkiyt9CpUFsBtuYxGI3q9cxhCkOcKyzCRQhBGEU7LRWuNlJIz/nRxemlUEuC9d69oISTBccDho31c1yUcB6gsQxqSluOgtCZOEjrdswzHo8pOQSUBTNOk232GJAwxDEm322VvZxdpSAwMAIQQQE6mUkzLYn6+ms9iJQEMNG3Xw3Ud0jjCtW0mJlpkSqMSdWpsFEW4XovNzc1TvixKD/Dxhx/o33/7Fa0z8lwRBSFZlnG212NwNGSYjP4eKzTEQUDb8+hMTvPJjRtz71+9uv3Pak+f0gOs3f2BbrfDvdV1ZmdnsaRNFEVYloNpOgRRH8txCIKILMtwWi2ODg4ZByGffv7ZFlDqe6D0APuHAzzPJQgitra3iOMYlWX4/jSDwQDf97FtmzCMkaaJ1jlCmOR5zr31X0rdPFQQYGVtQwAa4Pz5F3BTxfaDBxiWQxBHoCVBnBAEAa7XwnJamIaN7Xp8df363NuXL2+fXvHpUnoA+CvCm4uL+o+HhwB4Ez5KC6RpEccxpjBxvRYzMz329vrc/em2ALj57Ten1imDSgIAfP349/a1hYvamzxDloNpuxiWQxzHvHjhAl98uVz6kS9SWYAnPL4S/+LO6o9FVQmVB/i/0QQoirrRBCiKutEEKIq60QQoirrRBCiKutEEKIq60QQoirrxJ1JCV8S5Z+TMAAAAAElFTkSuQmCC";
    
        var img$c = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAATCAYAAACdkl3yAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC7UlEQVQ4T62UPW9cRRiFn5k793Pt682yzoq4wOAoFBEyihA0Bgk6CoqkMBU/gAYpQhR0KdOlhAJRpcF/gC5IKCiYEBnHGCKEsVMYO9rY3t27vp8zdyjAa6+ddJzyaM6j94zeGcX/JHXaAFi89oGtdAaiphFNEDVaLC/fZ3VtXZw+e6QzoHfeftPmRYI2FcbkDAYDXpqdotO5wDzY58HU0tKSt7i4WB4Z0tYMDxOkBCktQsD+XpdGI+Dl2TlW19ZP5kdSJyE3bnz2+k/3fqSscoypKMqS2kjS4RPiyRZ1bZh/7fIzpxqr9nSnu/LGlSs8evQb3W4XB4cyKzFVRTz9Ivu9HtPN1snISGOgYZIQxxM0okn2ZQ9TgRISARRZjjUGAby3sGDv3L07NtUYSGtNmh4y1Zxie3uH0lQox8NKzTDpUwsQAkpdnak4BgrCgCRJ6HQu4AhBXRtcRyGFIMtz/DDAWouUknNx82T0GPTRh9esEJL0MOXg6R5BEJANU4zWSEcS+j7GWoqypNU+z2CYjE01AimlaLdfoMwyHEfSbrfZ3d5BOhIHBwAhBFCjTYVyXebmjtdhBHKwNIKIIPCpipzA85iYCNHGYkpzdAyAPM8JopCNjY2RpwA+//QT+9eff2Ctpq4NeZqhteZ8p0O/N2BQJqOAsFCkKY0oojXZ5Itbt2Y/vn59SwGsPviZdrvFw5U1ZmZmcKVHnue4ro9SPmnexfV90jRHa40fhvT2DximGV9+/dUmIBTA3kGfKApI05zNrU2KosBoTRw36ff7xHGM53lkWYFUCmtrhFDUdc3Dtd+PL3t5dV0AFuDixVcIKsPW48c4rk9a5GAlaVGSpilBFOL6Icrx8IKIb2/enH3/6tV/qx3B3l1YsH8/OQAgmogxViCVS1EUKKEIopDp6Q67u10e/HpPANz54Xvg1EJ+99/avzV/2UaT59A1KC/AcX2KouDVS5e4/c3SmQcLz/iPYFT1jO6v/HLaGukfK6ZXUFEV3tAAAAAASUVORK5CYII=";
    
        var img$b = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAALCAYAAACQy8Z9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB6klEQVQoU7WSzU4TURiGnzNz5qfTMkEMaFkg0XgXbePCcAWscKXeSG+GRAVvgLgw6J4ASwKr0kCBTmf6M2dmzum4aKhQY1z57M57zvfkTb4j+Q/IxWCRVqNZKjVmefkJtVqVMAzR2lAUOZ/3vorF9/AXaavRLAE8zyHPc4SwiOOYm5sbpLSZ3Xm0Gs1yOIw5Oj55JJ9LW41m+XRlhSxP0dpgjKYoCqS08TwPYzSTyexs25KyLBkOY+r15xwdnzx0zqT3zZIkQTqzJq7rYts2taDKZDxmkqYk05hBP8KREum52LYkSRLetJrl98Mf87YSYL1eZ5KmZFnG0lIVAK0LsixDKYXruqyurvJsbY1Op0OeF0yyFKUUWhcEQZWtrbflwcE3MZcCVHwfKW3G4xFhGOJ5NaR02NzYoNPpcHnZpdfrkRc5QgiwBI4jUUohhCBKBrx++ao8uzgXEuDT3hfx8f2HsuL75IUiDEOMmTIYRJyenNLrXSOEhTaaqTEIYSGwwALf99HaUA2qjOIRj5qqPGNj8wXRXZ9u94rrq2uGoyFRPyKoBjjSwbZsUpUDhnc7O3a73Z7ezz9kLt3d3RXb29ulyQtu726pVAKifkR9fZ3Dn7+XcE+73V6M5jz6p/v7+38Mn12cL0b/5Bf4ONku8uljuAAAAABJRU5ErkJggg==";
    
        var img$a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASCAYAAABfJS4tAAAACXBIWXMAAAsTAAALEwEAmpwYAAADFklEQVQ4T7XUz2ucRRzH8fc8z+zMs88++yvG1GRrhUKLWOKhxTZYqeBBinrwUr34X4l4lyLoqQcFxZLakJb+sF7ExkAuSmh2m/3R7JN95vk9HpYkVkJsDn6Ow3xfDDMfRvI/Rf574ahceuuiPTH/Ckop4shQrwdsbm4CMBgMefzHmtjb+0LwtWvXrNaa4XafJEkYDQakacZoOMSVEsdxmJubY2Fh3t5cXhZwCHz50kWrtQZgYhLuP3wgJuMQ/ZICYH7uBOrkqxRZxsbGBtJxMcagqh5PnmztO/vwB1fftzWvSmQMVc9DCMG8Upx7/awd7jxjNwyx1rKzs4MrJVpKTp16jbW1NVrtFiaOcR2HxTfO2d8e/y4kTO9u1B8Sex5SCl6eaSOEi+/7rK+vI5XCWovWinD8jLIsGQwGaK1pNAPKMqe0lloQYK09OHEYhniug680eZLxtNslTQsAlFK4rkteFNRrAXFkyPJ8OuxKhBCEYYiu+vh+jTiOD+A3Fxfpd7fob/XwfR+bQxD4AGitkLoCgC1yZmfaJFlKq9HEdV1MmlD1PIKgxqDfx1XTvRKg2+sx6j2l3WphjKEoCiITAyVe1SOODMJ1sNbSarWZnZ1lYmKstRSjEYXOUUpRlCVSTBsnAX5euS3eu3zFRvEuwquw8ugXcfXKuzbcDTFJhhCCdr3O9vY2Qgji2JDlGdJ1SbOYWuCTJAnNZpOFkx1W7947aMXynZX9cgP8sHJbLF04b+M4RimF79c4fbrOeDwmtwWeVyUIakRJTKfT4c7qXc6cOctX178+vMf/zL1Hv4qlC+dtsyIZ704QQiCES7PeJM9z/vpzk6DZoLvVo9Fu41Tc/dkjYTjApZQsdDoUZUGcJoQ7YxzHwUSGSTSZVq/R2J/7Txim+GeffmK7vS6TKMJxHMqyxHEcsjTFcVzaszN8/sWXx/srAK5/8634+KMPbUVWSNOUNEuxpUVrjTERt26sPvdGLwwD3Pjue/HO20tWCEHQaLAzHHJr9XlwL8eCAbKsRCmXH3+6eSi4l2PD9x8+OBLcy99QElUk8fCpxwAAAABJRU5ErkJggg==";
    
        var img$9 = "data:image/png;base64,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";
    
        var img$8 = "data:image/png;base64,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";
    
        var img$7 = "data:image/png;base64,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";
    
        var img$6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAkCAYAAAD2IghRAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFcUlEQVRYR82Y3W4TRxTHf7vetb2Osd2AY18kogqpKkETSC7sUEEAqep9L7jhEfoYfYA+BqqUN6hUKNyUQgnioxcVigOqIR84ITHGG3u9M73YzHr9tXZIgP5udj1n9sx/Zs7MmbHBR2Jp6YpsNBrEYjHu3r2jdduPitFdcFQKhaKMRCIIITCjJq5wKRYXpXBdHvz14Ng6cGzCFxcvSiklZtRESsne3h5CCPSITjqdRkqDQqEodV3n3r0/Ojrww/ffyWjcwjRNIhqsr67x66NHoZ08kvCrV69JIQQArnABqO5VAZg91fDrPduuIqUkeSKJrutcvrwkTdPk1q3fNAApdVxNx2jYtAwTDc9nGB8k/NKly9JxHFzXE4sWFNwCXBJWEoBkMsY3bAMRnlZqaJpGOp2m6TQpFhclQHlnh7NGlpZpEDUMNEIHGzik8Pn5BRkxImi6hhk1/XDQNK1HcCrlPROWQa3mvc+eqgHw5I1A13VS6RS6piOiJk/WN4jHY3w1cRLDjDOMocILhaJ0HAdN00ilUriuy9udtwghuJCTgDfqSrAiYRnU7RZRa4x8zivb2PSec9kaEOHx1luklEQMgy8yGVzh8uzf9fZMhjBQ+MWL30p73yYej2NZFltbW+zv7wP4goNi1Qgr6nYLgN2dPb9M1UkmY9RqDc5PeDMAksdb28RiMVKpFFJKLlyYl/F4vGchK3qEFwpF2Wg2MAyDdCpNpVJBCMF8Xo1ChIRlkc9lfHGHRddN8jnLnwHgoBOCv3dcHMchm80ipGB2dk5alsX9+392dMAXfuXKVbm/v080GsWMmlSrVYQQnJ9wgHYo5HMZ9QmZ8bT/Dt7oqrLgSHfXU+RzELXGAGja79nY3OXcuFoH2+i6TjrjfVssLsp4PM6dO79rAEahUJQArutimIa/4OayLuAykT1JrdboEKxo2u+7i0YuUwQ7mM9l2Nj0QmmOXcDlaWUPNDiRSuEKl0KhKKUQGG6rhSsFTsvBaTrMZZu+I4CtN9sAlF6oePz41O12W7OnvBB9WqliRk2EK7xBfrjy0I+dG9fOyukvJ/2PwFtkCatnKXwG1rl5+4mvtUfRxubuwZTtAt60qWrK9qlRWoL0CK/btY6wqNs1tt607Z8yZDqJdPzqEa52j7ptk7CsLuunJaihbtsdth7h7TDpzV7BvTszng7dLRT9pnl03I6wDdIjPMigbAid21gY3T5GJWEZlF7UBia5UOFBNjY3uosAyOfy3UUjcVR/ocLVQSkznubnX/pfv3768WvZXaYyaPAJXnip95u3/wn1NywMQ4Urwpw07ff+dKqOQjuU1DNhGSOFl/I3LHeEWw8YFGfQaRu1Xhij1gsVHrXGiFrhCzFhGf5BKXjI6mbQAawfg3wECRUeDINB1O0WdbstJExUmC3I7s7e0UJlmOiPybC2Q4VXq7WRLwxqYQ4aqaBtmL+EZfRNOkH6t3JAKpUc2ohC1QurH2YLUrdb5HOZ0HNRqPDg9vZ/I1S42lUAblzrTTQw2g7Qj2H+wnIHDBEeTAbdFwxFdwIKI1hvFH9hhLd0wCiO4HjrDRuEcCsfHgqHYadSASA5ZnXc+sMYKnyYg+MgOda+sHS3l7AMqt7fkh30CC+9KPd9/1y0NQy4ui0tLcnGeBYpJeVymcnJSXRdR9O802epVOLMmTM4jkO5XGZqaopIxHOmaRpS9t0kBqL8qj9Ng5RKJaanpwFotVq8evWKqakprl8/J5eXlzU4ED4/Py+r1Srv3r1DSommabx8+RLw/ihSjp8/fw6AlJK1tTUOy8zMTMdAqM7qus7k5CSvX7/m9OnTzMzM4Louq6ur/rerq6vous7CwoJcWVnR/gMS6rip19cCIwAAAABJRU5ErkJggg==";
    
        var img$5 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAOCAIAAACtuNvgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB5UlEQVQoz1XPy04UURAG4Ko6t+6eGRkl0dGFLly5cOv7+AY+itEVCStDfBg1JhICbCQIiAmCc6FP97mXi9EJXZtK/sqXqkJmhv91/PktM7x49QaGdXm4x0pnZ5++fL1OaDM7P9xTciyFPjv4cNecfNsNXNq+db7bjP6x7193gm+ZgtYm39l/9OW9QIyu7RZXRCJEu87luuWcfAqCBI4m2S83rGqmSjYo+8RBCIopDpjSejJ9kktw3UKresNyDq1tkaCutr1bNM10wLgU2/8uIIiZVLVh3t4KIgAjuDeqRlSD33rf3c7n7B0i9N31yf7OOp9OtsfjSVOJ5eImINjuarDtwfaz7Nu2W6ZUtBzZdnV6sAfF5ZRzSYXTw9lzSiUgDdhq+ROZiFDryvteG/3j9Hz2eAqcYvKVHvlu7r1HMoMjjW6kFjFGH3pTVecXNyH4s4s5AxOqEJ2WtRSKsx8w26+8d1LKVLK1rTENQ/ZuRUjj5p5UCjAT4mRrNmBaGYGaGaaTR3XdWLtS0milS4JbO/fe9a6PzDEsTvd3AQCZ+ejTu7oaMRdEijGQaUK3ICRCAYBAzBliDve3Zi4scyopR/nr+CMAh9gJKQVr57sGBQNoo4Gxd50RlaxlA+M/y0sSJiUrSf0F+OQcr89DEA8AAAAASUVORK5CYII=";
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-22
         */
        class TemplateDefs {
    
            static ROCK_SM = {
                info: {
                    displayName: "Small Rock",
                    category: "template",
                    icon: {
                        imageData: img$d
                    }
                },
                action: {
                    type: "random-template",
                    actions: [
                        {
                            type: "image-template",
                            imageData: img$c,
                            brush: "rock",
                            threshold: 50,
                            randomFlipHorizontally: true
                        },
                        {
                            type: "image-template",
                            imageData: img$b,
                            brush: "rock",
                            threshold: 50,
                            randomFlipHorizontally: true,
                            randomFlipVertically: true
                        },
                        {
                            type: "image-template",
                            imageData: img$a,
                            brush: "rock",
                            threshold: 50,
                            randomFlipHorizontally: true
                        }
                    ]
                }
            };
    
            static ROCK_MD =  {
                info: {
                    displayName: "Medium Rock",
                    category: "template",
                    icon: {
                        imageData: img$k
                    }
                },
                action: {
                    type: "random-template",
                    actions: [
                        {
                            type: "image-template",
                            imageData: img$j,
                            brush: "rock",
                            threshold: 50,
                            randomFlipHorizontally: true
                        },
                        {
                            type: "image-template",
                            imageData: img$i,
                            brush: "rock",
                            threshold: 50,
                            randomFlipHorizontally: true,
                            randomFlipVertically: true
                        },
                        {
                            type: "image-template",
                            imageData: img$h,
                            brush: "rock",
                            threshold: 50,
                            randomFlipHorizontally: true,
                            randomFlipVertically: true
                        },
                        {
                            type: "image-template",
                            imageData: img$g,
                            brush: "rock",
                            threshold: 50,
                            randomFlipHorizontally: true,
                            randomFlipVertically: true
                        },
                        {
                            type: "image-template",
                            imageData: img$f,
                            brush: "rock",
                            threshold: 50,
                            randomFlipHorizontally: true
                        },
                        {
                            type: "image-template",
                            imageData: img$e,
                            brush: "rock",
                            threshold: 50,
                            randomFlipHorizontally: true,
                            randomFlipVertically: true
                        }
                    ]
                }
            };
    
            static ROCK_LG = {
                info: {
                    displayName: "Large Rock",
                    category: "template",
                    icon: {
                        imageData: img$9
                    }
                },
                action: {
                    type: "random-template",
                    actions: [
                        {
                            type: "image-template",
                            imageData: img$8,
                            brush: "rock",
                            threshold: 50
                        },
                        {
                            type: "image-template",
                            imageData: img$7,
                            brush: "rock",
                            threshold: 50,
                            randomFlipHorizontally: true
                        }
                    ]
                }
            };
    
            static CABIN = {
                info: {
                    displayName: "Cabin",
                    category: "template",
                    // icon: {
                    //     imageData: _ASSET_WOODEN_HOUSE_ICON
                    // }
                },
                action: {
                    type: "image-template",
                    imageData: img$6,
                    brush: "wood",
                    threshold: 50,
                    randomFlipHorizontally: true
                }
            };
            static VOLCANO = {
                info: {
                    displayName: "Volcano",
                    category: "template",
                     icon: {
                    imageData: "data:image/png;base64,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",
                    }
                },
                action: {
                    type: "image-template",
                    imageData: "data:image/png;base64,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",
                    brush: "rock",
                    threshold: 50,
                    randomFlipHorizontally: true
                }
            };
    
            static SAND_CASTLE = {
                info: {
                    displayName: "Sand Castle",
                    category: "template"
                },
                action: {
                    type: "image-template",
                    imageData: img$5,
                    brush: "sand",
                    threshold: 1
                }
            };
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-05
         */
        class StateDefinition {
    
            static #createStateTransition(stateFrom, stateTo) {
                const transitions = [];
                for (let i = 0; i < stateFrom.length; i++) {
                    const [ax, ay] = stateFrom[i];
                    const [bx, by] = stateTo[i];
                    if (ax === bx && ay === by) {
                        continue;  // no change
                    }
                    transitions.push([[ax, ay], [bx, by]]);
                }
                return transitions;
            }
    
            static #createStateTransitionTable(states) {
                const stateTransitions = [];
                for (let i = 0; i < states.length; i++) {
                    stateTransitions.push(StateDefinition.#createStateTransition(states[i], states[i + 1 < states.length ? i + 1 : 0]));
                }
                return stateTransitions;
            }
    
            static createCyclic(states) {
                const transitions = StateDefinition.#createStateTransitionTable(states);
    
                let minX = Number.MAX_VALUE;
                let minY = Number.MAX_VALUE;
                let maxX = Number.MIN_VALUE;
                let maxY = Number.MIN_VALUE;
                for (let state of states) {
                    for (let [dx, dy] of state) {
                        minX = Math.min(minX, dx);
                        minY = Math.min(minY, dy);
                        maxX = Math.max(maxX, dx);
                        maxY = Math.max(maxY, dy);
                    }
                }
    
                const masks = [];
                for (let state of states) {
                    masks.push(new StateMask(state, minX, maxX, minY, maxY));
                }
    
                return new StateDefinition(states, masks, transitions, minX, maxX, minY, maxY);
            }
    
    
            #states;
            #masks;
            #transitions;
            #minX;
            #maxX;
            #minY;
            #maxY;
    
            constructor(states, masks, transitions, minX, maxX, minY, maxY) {
                this.#states = states;
                this.#masks = masks;
                this.#transitions = transitions;
                this.#minX = minX;
                this.#maxX = maxX;
                this.#minY = minY;
                this.#maxY = maxY;
            }
    
            getStates() {
                return this.#states;
            }
    
            getStatesCount() {
                return this.#states.length;
            }
    
            getMasks() {
                return this.#masks;
            }
    
            getTransitions() {
                return this.#transitions;
            }
    
            getMinX() {
                return this.#minX;
            }
    
            getMaxX() {
                return this.#maxX;
            }
    
            getMinY() {
                return this.#minY;
            }
    
            getMaxY() {
                return this.#maxY;
            }
        }
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-05
         */
        class StateMask {
    
            #minX;
            #maxX;
            #minY;
            #maxY;
            #array
    
            constructor(state, minX, maxX, minY, maxY) {
                this.#minX = minX;
                this.#maxX = maxX;
                this.#minY = minY;
                this.#maxY = maxY;
    
                const w = Math.abs(minX) + 1 + maxX;
                const h = Math.abs(minY) + 1 + maxY;
                const array = new Uint8Array(w * h);
                for (const [dx, dy] of state) {
                    const x = dx - this.#minX;
                    const y = dy - this.#minY;
                    const i = x + (w * y);
                    array[i] = 1;
                }
                this.#array = array;
            }
    
            matches(dx, dy) {
                if (dx < this.#minX || dy < this.#minY || dx > this.#maxX || dy > this.#maxY) {
                    // out of bounds
                    return false;
                }
                const w = Math.abs(this.#minX) + 1 + this.#maxX;
                const x = dx - this.#minX;
                const y = dy - this.#minY;
                const i = x + (w * y);
                return this.#array[i] === 1;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-05
         */
        class EntityUtils {
    
            static isElementFallingHeavy(elementHead) {
                if (elementHead === null) {
                    return false;
                }
                const typeClass = ElementHead.getTypeClass(elementHead);
                if (typeClass === ElementHead.TYPE_POWDER || typeClass === ElementHead.TYPE_POWDER_WET) {
                    return true;
                }
                if (typeClass === ElementHead.TYPE_STATIC) {
                    if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_ENTITY) {
                        return false;
                    }
                    if (ElementHead.getTypeModifierSolidBodyId(elementHead) > 0) {
                        return true;
                    }
                }
                return false;
            }
    
            static isElementLight(elementHead) {
                if (elementHead === null) {
                    return false;
                }
                const typeClass = ElementHead.getTypeClass(elementHead);
                return typeClass <= ElementHead.TYPE_GAS;
    
            }
    
            static isElementWater(elementHead) {
                if (elementHead === null) {
                    return false;
                }
                const typeClass = ElementHead.getTypeClass(elementHead);
                return typeClass === ElementHead.TYPE_FLUID;
    
            }
    
            static isElementEntity(elementHead) {
                if (elementHead === null) {
                    return false;
                }
                const behaviour = ElementHead.getBehaviour(elementHead);
                return behaviour === ElementHead.BEHAVIOUR_ENTITY
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class Entity {
    
            /**
             * @return {string}
             */
            getType() {
                throw 'Not implemented';
            }
    
            /**
             * @return {number}
             */
            getX() {
                throw 'Not implemented';
            }
    
            /**
             * @return {number}
             */
            getY() {
                throw 'Not implemented';
            }
    
            /**
             * @returns {boolean}
             */
            isActive() {
                throw 'Not implemented';
            }
    
            /**
             *
             * @returns {object}
             */
            serialize() {
                throw 'Not implemented';
            }
    
            /**
             *
             * @returns {void}
             */
            initialize() {
                throw 'Not implemented';
            }
    
            /**
             *
             * @returns {boolean} alive
             */
            performBeforeProcessing() {
                throw 'Not implemented';
            }
    
            /**
             *
             * @returns {boolean} alive
             */
            performAfterProcessing() {
                throw 'Not implemented';
            }
    
            /**
             *
             * @param defaultElement {Element}
             * @param rx {number} relative x
             * @param ry {number} relative y
             * @returns {[object, PositionedElement[]]}
             */
            extract(defaultElement, rx, ry) {
                throw 'Not implemented';
            }
    
            paint(x, y, elementArea, random) {
                throw 'Not implemented';
            }
    
            /**
             *
             * @returns {[number, number]}
             */
            countMaxBoundaries() {
                throw 'Not implemented';
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        // TODO: support collisions/interleaving with other entities
        // TODO: support flammability
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-05
         */
        class StateBasedAbstractEntity extends Entity {
    
            /** @type ElementArea */
            _elementArea;
            /** @type DeterministicRandom */
            _random;
            /** @type ProcessorContext */
            _processorContext;
    
            /** @type StateDefinition */
            _stateDefinition;
            /** @type Brush */
            _brush;
            _areaBoundary;
    
            /** @type string */
            _type;
            _iteration = 0;
            _x = 0;
            _y = 0;
            _waypoint = null;
            _state = 0;
            _stuck = 0;
    
            constructor(type, serialized, stateDefinition, brush, gameState) {
                super();
                this._type = type;
                this._stateDefinition = stateDefinition;
                this._brush = brush;
                this._areaBoundary = 2 * (Math.abs(this._stateDefinition.getMinX() - this._stateDefinition.getMaxX()) + 1);
    
                this._elementArea = gameState.elementArea;
                this._random = gameState.random;
                this._processorContext = gameState.processorContext;
    
                if (serialized.iteration !== undefined) {
                    this._iteration = serialized.iteration;
                } else {
                    // set randomly; so state change will not be on the same time
                    this._iteration = this._random.nextInt(this._stateDefinition.getStatesCount());
                }
                if (serialized.x !== undefined) {
                    this._x = serialized.x;
                }
                if (serialized.y !== undefined) {
                    this._y = serialized.y;
                }
                if (serialized.state !== undefined) {
                    this._state = serialized.state;
                } else {
                    // random state by default
                    this._state = this._random.nextInt(this._stateDefinition.getStatesCount());
                }
                if (serialized.stuck !== undefined) {
                    this._stuck = serialized.stuck;
                }
            }
    
            // abstract methods
    
            _checkIsSpace(elementHead) {
                throw 'Not implemented';
            }
    
            performBeforeProcessing() {
                return this._state !== -1;
            }
    
            performAfterProcessing() {
                return this._state !== -1;
            }
    
            // methods
    
            serialize() {
                return {
                    entity: this._type,
                    iteration: this._iteration,
                    x: this._x,
                    y: this._y,
                    state: this._state,
                    stuck: this._stuck,
                };
            }
    
            getType() {
                return this._type;
            }
    
            getX() {
                return this._x;
            }
    
            getY() {
                return this._y;
            }
    
            assignWaypoint(x, y) {
                this._waypoint = {
                    x: x,
                    y: y,
                    stuck: 0
                };
            }
    
            unassignWaypoint() {
                this._waypoint = null;
            }
    
            isActive() {
                return this._state !== -1;
            }
    
            initialize() {
                this.paint(this._x, this._y, this._elementArea, this._random);
            }
    
            _incrementState() {
                const x = this._x;
                const y = this._y;
    
                const transitions = this._stateDefinition.getTransitions()[this._state];
    
                let allowed = true;
                for (const [[dx1, dy1], [dx2, dy2]] of transitions) {
                    if (!this._elementArea.isValidPosition(x + dx1, y + dy1) || !this._checkIsSpaceAt(x + dx2, y + dy2)) {
                        allowed = false;
                        break;
                    }
                }
    
                if (allowed) {
                    for (const [[dx1, dy1], [dx2, dy2]] of transitions) {
                        this._elementArea.swap(x + dx1, y + dy1, x + dx2, y + dy2);
                    }
    
                    this._stuck = 0;
                    this._state++;
                    if (this._state === this._stateDefinition.getStates().length) {
                        this._state = 0;
                    }
                } else {
                    // stuck
                    this._stuck++;
                }
            }
    
            _moveRandom(visionExtra) {
                const xChange = this._random.nextInt(3) - 1;
                const yChange = this._random.nextInt(3) - 1;
    
                return this._move(xChange, yChange, visionExtra);
            }
    
            _moveInWaypointDirection(visionExtra) {
                let dx = this._waypoint.x - this._x;
                let xChange = 0;
                if (dx > 0) {
                    // move right
                    xChange += 1;
                } else if (dx < 0) {
                    // move left
                    xChange -= 1;
                }
    
                let dy = this._waypoint.y - this._y;
                let yChange = 0;
                if (dy > 0) {
                    // move up
                    yChange += 1;
                } else if (dy < 0) {
                    // move down
                    yChange -= 1;
                }
    
                const moved = this._move(xChange, yChange, visionExtra);
                if (moved) {
                    this._waypoint.stuck = 0;
                } else {
                    this._waypoint.stuck++;
                }
            }
    
            _move(xChange, yChange, visionExtra) {
                const x = this._x;
                const y = this._y;
    
                const newPos = this.#countNewPosition(x, y, xChange, yChange, visionExtra);
    
                if (newPos !== null) {
                    const [nx, ny] = newPos;
    
                    this.#relocate(this._stateDefinition.getStates()[this._state], x, y, nx, ny);
    
                    this._x = nx;
                    this._y = ny;
    
                    return true;
                }
                return false;
            }
    
            #countNewPosition(x, y, xChange, yChange, visionExtra) {
                // check boundaries
    
                if (x + xChange < this._areaBoundary && xChange < 0) {
                    xChange = 0;
                }
                if (x + xChange > this._elementArea.getWidth() - this._areaBoundary && xChange > 0) {
                    xChange = 0;
                }
    
                if (y + yChange < this._areaBoundary && yChange < 0) {
                    yChange = 0;
                }
                if (y + yChange > this._elementArea.getHeight() - this._areaBoundary && yChange > 0) {
                    yChange = 0;
                }
    
                // check further obstacles
    
                if (xChange === 0 && yChange === 0) {
                    return null;
                }
    
                // test right | right
                if (xChange > 0 || xChange < 0) {
                    for (let yy = this._stateDefinition.getMinY() - visionExtra; yy <= this._stateDefinition.getMaxY() + visionExtra; yy++) {
                        if (!this._checkIsSpaceAt(x + (xChange * 5), y + yChange + yy)) {
                            xChange = 0;
                            break;
                        }
                    }
                }
    
                // test above | below
                if (yChange > 0 || yChange < 0) {
                    for (let xx = this._stateDefinition.getMinX() - visionExtra; xx <= this._stateDefinition.getMaxX() + visionExtra; xx++) {
                        if (!this._checkIsSpaceAt(x + xChange + xx, y + (yChange * 5))) {
                            yChange = 0;
                            break;
                        }
                    }
                }
    
                // check close obstacles
    
                if (xChange === 0 && yChange === 0) {
                    return null;
                }
    
                const mask = this._stateDefinition.getMasks()[this._state];
                for (const [dx, dy] of this._stateDefinition.getStates()[this._state]) {
                    if (mask.matches(xChange + dx, yChange + dy)) ; else if (!this._checkIsSpaceAt(x + xChange + dx, y + yChange + dy)) {
                        return null;
                    }
                }
    
                return [x + xChange, y + yChange];
            }
    
            _moveForced(xChange, yChange) {
                const x = this._x;
                const y = this._y;
    
                const newPos = this.#countNewForcedPosition(x, y, xChange, yChange);
    
                if (newPos !== null) {
                    const [nx, ny] = newPos;
    
                    this.#relocate(this._stateDefinition.getStates()[this._state], x, y, nx, ny);
    
                    this._x = nx;
                    this._y = ny;
    
                    return true;
                }
                return false;
            }
    
            #countNewForcedPosition(x, y, xChange, yChange) {
                if (x + xChange < 0 && xChange < 0) {
                    xChange = 0;
                }
                if (x + xChange > this._elementArea.getWidth() && xChange > 0) {
                    xChange = 0;
                }
    
                if (y + yChange < 0 && yChange < 0) {
                    yChange = 0;
                }
                if (y + yChange > this._elementArea.getHeight() && yChange > 0) {
                    yChange = 0;
                }
    
                if (xChange === 0 && yChange === 0) {
                    return null;  // cannot move
                }
    
                // check is space
                for (const [dx, dy] of this._stateDefinition.getStates()[this._state]) {
                    const ex = x + dx + xChange;
                    const ey = y + dy + yChange;
    
                    const elementHead = this._elementArea.getElementHeadOrNull(ex, ey);
                    if (elementHead === null) {
                        return null;  // cannot move
                    }
                    if (ElementHead.getBehaviour(elementHead) !== ElementHead.BEHAVIOUR_ENTITY) {
                        if (ElementHead.getTypeClass(elementHead) > ElementHead.TYPE_FLUID) {
                            return null;  // cannot move
                        }
                    }
                }
    
                return [x + xChange, y + yChange];
            }
    
            _checkIsSpaceAt(tx, ty) {
                const targetElementHead = this._elementArea.getElementHeadOrNull(tx, ty);
                if (targetElementHead === null) {
                    return false;
                }
                return this._checkIsSpace(targetElementHead);
            }
    
            #relocate(state, x, y, nx, ny) {
                const sortedPoints = [...state];
    
                if (nx > x) {
                    sortedPoints.sort((a, b) => b[0] - a[0]);
                } else if (nx < x) {
                    sortedPoints.sort((a, b) => a[0] - b[0]);
                }
                if (ny > y) {
                    sortedPoints.sort((a, b) => b[1] - a[1]);
                } else if (ny < y) {
                    sortedPoints.sort((a, b) => a[1] - b[1]);
                }
    
                for (const [dx, dy] of sortedPoints) {
                    this._elementArea.swap(x + dx, y + dy, nx + dx, ny + dy);
                }
            }
    
            _kill() {
                const x = this._x;
                const y = this._y;
    
                for (const [dx, dy] of this._stateDefinition.getStates()[this._state]) {
                    const ex = x + dx;
                    const ey = y + dy;
    
                    const elementHead = this._elementArea.getElementHeadOrNull(ex, ey);
                    if (elementHead === null) {
                        continue;
                    }
    
                    if (ElementHead.getBehaviour(elementHead) !== ElementHead.BEHAVIOUR_ENTITY) {
                        continue;
                    }
    
                    let newElementHead = elementHead;
                    newElementHead = ElementHead.setType(newElementHead, ElementHead.type8Solid(ElementHead.TYPE_STATIC, 4, true));
                    newElementHead = ElementHead.setBehaviour(newElementHead, ElementHead.BEHAVIOUR_NONE);
                    newElementHead = ElementHead.setSpecial(newElementHead, 0);
                    this._elementArea.setElementHead(ex, ey, newElementHead);
                }
    
                this._state = -1;
                return false;  // not active
            }
    
            paint(x, y, elementArea, random) {
                for (const [dx, dy] of this._stateDefinition.getStates()[this._state]) {
                    const ex = x + dx;
                    const ey = y + dy;
    
                    if (!elementArea.isValidPosition(ex, ey)) {
                        continue;  // out of bounds
                    }
    
                    const element = this._brush.apply(dx, dy, random);
                    elementArea.setElement(ex, ey, element);
                }
            }
    
            extract(defaultElement, rx, ry) {
                const x = this._x;
                const y = this._y;
    
                const positionedElements = [];
                for (const [dx, dy] of this._stateDefinition.getStates()[this._state]) {
                    const ex = x + dx;
                    const ey = y + dy;
    
                    const elementHead = this._elementArea.getElementHeadOrNull(ex, ey);
                    if (elementHead === null) {
                        continue;  // out of bounds
                    }
                    if (ElementHead.getBehaviour(elementHead) !== ElementHead.BEHAVIOUR_ENTITY) {
                        continue;
                    }
    
                    const elementTail = this._elementArea.getElementTail(ex, ey);
                    positionedElements.push(new PositionedElement(ex, ey, elementHead, elementTail));
    
                    this._elementArea.setElement(ex, ey, defaultElement);
                }
    
                const serializedEntity = this.serialize();
                // relativize entity position
                serializedEntity.x -= rx;
                serializedEntity.y -= ry;
    
                this._state = -1;
                return [serializedEntity, positionedElements];
            }
    
            countMaxBoundaries() {
                const w = Math.abs(this._stateDefinition.getMinX() - this._stateDefinition.getMaxX()) + 1;
                const h = Math.abs(this._stateDefinition.getMinY() - this._stateDefinition.getMaxY()) + 1;
                return [w, h];
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-28
         */
        class StateBasedBirdLikeEntity extends StateBasedAbstractEntity {
    
            static #MAX_AVG_TEMPERATURE = 10;
    
            static #MAX_STUCK_COUNT = 15;
    
            constructor(type, serialized, stateDefinition, brush, gameState) {
                super(type, serialized, stateDefinition, brush, gameState);
            }
    
            _checkIsSpace(elementHead) {
                if (ElementHead.getTypeClass(elementHead) > ElementHead.TYPE_GAS) {
                    return false;
                }
                if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_FIRE) {
                    return false;
                }
                return true;
            }
    
            performAfterProcessing() {
                this._iteration++;
    
                let isActive = (this._state !== -1);
                let isFalling = false;
    
                if (isActive) {
                    const [retIsActive, retIsFalling] = this.#doCheckState();
                    isActive = retIsActive;
                    isFalling = retIsFalling;
                }
    
                if (isActive) {
                    if (isFalling) {
                        const xChange = this._random.nextInt(3) - 1;
                        const yChange = 1;
                        this._moveForced(xChange, yChange);
                    } else if (this._iteration % 11 === 0) {
                        if (this._waypoint !== null) {
                            if (this._waypoint.stuck === 10) {
                                this._waypoint.stuck = -20;  // try random walk now...
                            }
                            if (this._waypoint.stuck >= 0) {
                                this._moveInWaypointDirection(2);
                            } else {
                                this._waypoint.stuck++;
                                this._moveRandom(2);
                            }
                        } else {
                            this._moveRandom(2);
                        }
                    }
                }
    
                if (isActive && this._stateDefinition.getStatesCount() > 1 && this._iteration % 10 === 0) {
                    this._incrementState();
                }
    
                return isActive;
            }
    
            #doCheckState() {
                const x = this._x;
                const y = this._y;
                const points = this._stateDefinition.getStates()[this._state];
    
                let heavyElementsAbove = false;
                let totalTemperature = 0;
                for (const [dx, dy] of points) {
                    const ex = x + dx;
                    const ey = y + dy;
    
                    const elementHead = this._elementArea.getElementHeadOrNull(ex, ey);
                    if (elementHead === null) {
                        // lost body part / out of bounds
                        return [this._kill(), false];
                    }
    
                    if (ElementHead.getBehaviour(elementHead) !== ElementHead.BEHAVIOUR_ENTITY) {
                        // lost body part
                        return [this._kill(), false];
                    }
    
                    totalTemperature += ElementHead.getTemperature(elementHead);
    
                    // update
                    this._elementArea.setElementHead(ex, ey, ElementHead.setSpecial(elementHead, 0));
    
                    // check element above
                    if (!heavyElementsAbove) {
                        heavyElementsAbove = EntityUtils.isElementFallingHeavy(this._elementArea.getElementHeadOrNull(ex, ey - 1));
                    }
                }
    
                if (totalTemperature / points.length > StateBasedBirdLikeEntity.#MAX_AVG_TEMPERATURE) {
                    // killed by temperature
                    return [this._kill(), false];
                }
    
                if (this._stuck > StateBasedBirdLikeEntity.#MAX_STUCK_COUNT) {
                    // stuck to death
                    return [this._kill(), false];
                }
    
                return [true, heavyElementsAbove];
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-05
         */
        class StateBasedFishLikeEntity extends StateBasedAbstractEntity {
    
            static #MAX_AVG_TEMPERATURE = 10;
    
            static #MAX_STUCK_COUNT = 1000;
    
            constructor(type, serialized, stateDefinition, brush, gameState) {
                super(type, serialized, stateDefinition, brush, gameState);
            }
    
            _checkIsSpace(elementHead) {
                if (ElementHead.getTypeClass(elementHead) !== ElementHead.TYPE_FLUID) {
                    return false;
                }
                return true;
            }
    
            performAfterProcessing() {
                this._iteration++;
    
                let isActive = (this._state !== -1);
                let isFalling = false;
    
                if (isActive) {
                    const [retIsActive, retIsFalling] = this.#doCheckState();
                    isActive = retIsActive;
                    isFalling = retIsFalling;
                }
    
                if (isActive) {
                    if (isFalling) {
                        this._moveForced(0, 1);
                    } else if (this._iteration % 14 === 0) {
                        if (this._waypoint !== null) {
                            if (this._waypoint.stuck === 3) {
                                this._waypoint.stuck = -10;  // try random walk now...
                            }
                            if (this._waypoint.stuck >= 0) {
                                this._moveInWaypointDirection(1);
                            } else {
                                this._waypoint.stuck++;
                                this._moveRandom(1);
                            }
                        } else {
                            this._moveRandom(1);
                        }
                    }
                }
    
                if (isActive && this._stateDefinition.getStatesCount() > 1 && this._iteration % 10 === 0) {
                    this._incrementState();
                }
    
                return isActive;
            }
    
            #doCheckState() {
                const x = this._x;
                const y = this._y;
                const points = this._stateDefinition.getStates()[this._state];
    
                let heavyElementAbove = false;  // at least one
                let lightElementsAbove = true;  // all
                let waterElementsAbove = true;  // all
    
                let lightElementsBelow = true;  // all
                let waterElementsBelow = true;  // all
    
                let totalTemperature = 0;
    
                for (const [dx, dy] of points) {
                    const ex = x + dx;
                    const ey = y + dy;
    
                    const elementHead = this._elementArea.getElementHeadOrNull(ex, ey);
                    if (elementHead === null) {
                        // lost body part / out of bounds
                        return [this._kill(), false];
                    }
    
                    if (ElementHead.getBehaviour(elementHead) !== ElementHead.BEHAVIOUR_ENTITY) {
                        // lost body part
                        return [this._kill(), false];
                    }
    
                    totalTemperature += ElementHead.getTemperature(elementHead);
    
                    // update
                    this._elementArea.setElementHead(ex, ey, ElementHead.setSpecial(elementHead, 0));
    
                    // check element above
                    if (!heavyElementAbove || lightElementsAbove || waterElementsAbove) {
                        const elementHeadOrNull = this._elementArea.getElementHeadOrNull(ex, ey - 1);
                        if (!heavyElementAbove) {
                            heavyElementAbove = EntityUtils.isElementFallingHeavy(elementHeadOrNull);
                        }
                        if (lightElementsAbove) {
                            lightElementsAbove = EntityUtils.isElementLight(elementHeadOrNull);
                        }
                        if (waterElementsAbove) {
                            waterElementsAbove = EntityUtils.isElementWater(elementHeadOrNull)
                                    || EntityUtils.isElementEntity(elementHeadOrNull);
                        }
                    }
    
                    // check element below
                    if (lightElementsBelow || waterElementsBelow) {
                        const elementHeadOrNull = this._elementArea.getElementHeadOrNull(ex, ey + 1);
                        if (lightElementsBelow) {
                            lightElementsBelow = EntityUtils.isElementLight(elementHeadOrNull);
                        }
                        if (waterElementsBelow) {
                            waterElementsBelow = EntityUtils.isElementWater(elementHeadOrNull)
                                    || EntityUtils.isElementEntity(elementHeadOrNull);
                        }
                    }
                }
    
                if (totalTemperature / points.length > StateBasedFishLikeEntity.#MAX_AVG_TEMPERATURE) {
                    // killed by temperature
                    return [this._kill(), false];
                }
    
                if (!waterElementsAbove || !waterElementsBelow) {
                    // not enough water
                    this._stuck++;
                }
    
                if (this._stuck > StateBasedFishLikeEntity.#MAX_STUCK_COUNT) {
                    // stuck to death
                    return [this._kill(), false];
                }
    
                const falling = heavyElementAbove  // dragged
                    || lightElementsBelow  // falling
                    || (lightElementsAbove && waterElementsBelow);  // force submerge
    
                return [true, falling];
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class EntityFactories {
    
            // bird
    
            static #BIRD_STATES = StateDefinition.createCyclic([
                [[0, 0], [1, -1], [-1, -1], [2, -1], [-2, -1], [3, -1], [-3, -1]],
                [[0, 0], [1, -1], [-1, -1], [2, -1], [-2, -1], [3, -2], [-3, -2]],
                [[0, 0], [1, -1], [-1, -1], [2, -2], [-2, -2], [3, -2], [-3, -2]],
                [[0, 0], [1, -1], [-1, -1], [2, -2], [-2, -2], [3, -1], [-3, -1]],
                [[0, 0], [1, -1], [-1, -1], [2, -1], [-2, -1], [3, -1], [-3, -1]],
                [[0, 0], [1, -1], [-1, -1], [2,  0], [-2,  0], [3,  0], [-3,  0]],
                [[0, 0], [1, -1], [-1, -1], [2,  0], [-2,  0], [3,  1], [-3,  1]],
                [[0, 0], [1, -1], [-1, -1], [2,  0], [-2,  0], [3,  0], [-3,  0]],
            ]);
    
            static #BIRD_BRUSH = Brushes.custom((x, y) => {
                // motion blur - ends of wings only
                const blurType = Math.abs(x) < 2 ? ElementTail.BLUR_TYPE_NONE : ElementTail.BLUR_TYPE_1;
                return new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.TYPE_STATIC),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_ENTITY, 0),
                        ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_1)),
                    ElementTail.of(0, 0, 0, blurType))
            });
    
            static birdFactory(serialized, gameState) {
                return new StateBasedBirdLikeEntity('bird', serialized, EntityFactories.#BIRD_STATES, EntityFactories.#BIRD_BRUSH, gameState);
            }
            //CURSOR
            
            static #CURSOR_STATES = StateDefinition.createCyclic([
                [[0, 0],[1, 0],[0, 1],[2, 1],[0, 2],[3, 2],[0, 3],[4, 3],[0, 4],[5, 4],[0, 5],[6, 5],[0, 6],[6, 6],[5, 6],[4, 6],[0, 7],[0, 8],[5, 7],[1, 8],[2, 8],[2, 7],[5, 8],[3, 9],[4, 9],],
            ]);
    
            static #CURSOR_BRUSH = Brushes.custom((x, y) => {
                // motion blur - ends of wings only
                const blurType = Math.abs(x) < 2 ? ElementTail.BLUR_TYPE_NONE : ElementTail.BLUR_TYPE_NONE;
                return new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.TYPE_STATIC),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_ENTITY, 0),
                        ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_1)),
                    ElementTail.of(0, 0, 0, blurType))
            });
    
            static cursorFactory(serialized, gameState) {
                return new StateBasedBirdLikeEntity('cursor', serialized, EntityFactories.#CURSOR_STATES, EntityFactories.#CURSOR_BRUSH, gameState);
            }


            //big boi
            static #BIRD_BIG_STATES = StateDefinition.createCyclic([
                [[0, 0], [1, -1], [-1, -1], [2, -1], [-2, -1], [3, -1],[4, -2],[5, -3], [-3, -1], [-4, -2], [-5, -3]],
                [[0, 0], [1, -1], [-1, -1], [2, -1], [-2, -1], [3, -2],[4, -3],[5, -4], [-3, -2], [-4, -3], [-5, -4]],
                [[0, 0], [1, -1], [-1, -1], [2, -2], [-2, -2], [3, -2],[4, -3],[5, -4], [-3, -2], [-4, -3], [-5, -4]],
                [[0, 0], [1, -1], [-1, -1], [2, -2], [-2, -2], [3, -1],[4, -2],[5, -3], [-3, -1], [-4, -2], [-5, -3]],
                [[0, 0], [1, -1], [-1, -1], [2, -1], [-2, -1], [3, -1],[4, -1],[5, -2], [-3, -1], [-4, -1], [-5, -2]],
                [[0, 0], [1, -1], [-1, -1], [2,  0], [-2,  0], [3,  0],[4,  1],[5,  2], [-3,  0], [-4,  1], [-5,  2]],
                [[0, 0], [1, -1], [-1, -1], [2,  0], [-2,  0], [3,  1],[4,  2],[5,  3], [-3,  1], [-4,  2], [-5,  3]],
                [[0, 0], [1, -1], [-1, -1], [2,  0], [-2,  0], [3,  0],[4,  1],[5,  2], [-3,  0], [-4,  1], [-5,  2]],
            ]);
    
            static #BIRD_BIG_BRUSH = Brushes.custom((x, y) => {
                // motion blur - ends of wings only
                const blurType = Math.abs(x) < 2 ? ElementTail.BLUR_TYPE_NONE : ElementTail.BLUR_TYPE_1;
                return new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.TYPE_STATIC),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_ENTITY, 0),
                        ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_1)),
                    ElementTail.of(0, 0, 0, blurType))
            });
    
            static birdBigFactory(serialized, gameState) {
                return new StateBasedBirdLikeEntity('big_bird', serialized, EntityFactories.#BIRD_BIG_STATES, EntityFactories.#BIRD_BIG_BRUSH, gameState);
            }
    
    
            // butterfly
    
            static #BUTTERFLY_STATES = StateDefinition.createCyclic([
                [[0, 0], [1, -1], [-1, -1]],
                [[0, 0], [1, -1], [-1, -1]],
                [[0, 0], [1,  0], [-1,  0]],
                [[0, 0], [1,  1], [-1,  1]],
                [[0, 0], [1,  1], [-1,  1]],
            ]);
    
            static #BUTTERFLY_BRUSH = Brushes.custom((x, y) => {
                // motion blur - ends of wings only
                const blurType = Math.abs(x) === 0 ? ElementTail.BLUR_TYPE_NONE : ElementTail.BLUR_TYPE_1;
                const r = Math.abs(x) === 0 ? 0 : 200;
                return new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.TYPE_STATIC),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_ENTITY, 0),
                        ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_1)),
                    ElementTail.of(r, 0, 0, blurType));
            });
    
            static butterflyFactory(serialized, gameState) {
                return new StateBasedBirdLikeEntity('butterfly', serialized, EntityFactories.#BUTTERFLY_STATES, EntityFactories.#BUTTERFLY_BRUSH, gameState);
            }
    
            // fish
    
            static #FISH_STATES = StateDefinition.createCyclic([
                [[0, 0], [1, 0]],
            ]);
    
            static #FISH_BRUSH = Brushes.custom((x, y) => {
                return new Element(
                    ElementHead.of(
                        ElementHead.type8(ElementHead.TYPE_STATIC),
                        ElementHead.behaviour8(ElementHead.BEHAVIOUR_ENTITY, 0),
                        ElementHead.modifiers8(ElementHead.HMI_CONDUCTIVE_1)),
                    ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_NONE))
            });
    
            static fishFactory(serialized, gameState) {
                return new StateBasedFishLikeEntity('fish', serialized, EntityFactories.#FISH_STATES, EntityFactories.#FISH_BRUSH, gameState);
            }
    
            // ---
    
            static findFactoryByEntityType(type) {
                switch (type) {
                    case 'bird':
                        return EntityFactories.birdFactory;
                    case 'big_bird':
                        return EntityFactories.birdBigFactory;
                    case 'butterfly':
                        return EntityFactories.butterflyFactory;
                    case 'fish':
                        return EntityFactories.fishFactory;
                    case 'cursor':
                        return EntityFactories.cursorFactory;
                }
                return null;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-08
         */
        class ToolDefs {
    
            static DEFAULT_SIZE = 6;
    
            static CATEGORY_NONE = undefined;
            static CATEGORY_POWDER = 'powders';
            static CATEGORY_FLUIDS = 'fluids';
            static CATEGORY_SOLIDS = 'solids';
            static CATEGORY_EFFECTS = 'effects';
            static CATEGORY_BIOLOGICAL = 'biological';
    //MCategories
            static DEFAULT_CATEGORY_DEFINITIONS = {};
            static {
                ToolDefs.DEFAULT_CATEGORY_DEFINITIONS[ToolDefs.CATEGORY_POWDER] = {
                    displayName: 'Powders',
                    badgeStyle: {
                        backgroundColor: '#b7a643',
                    }
                };
                ToolDefs.DEFAULT_CATEGORY_DEFINITIONS[ToolDefs.CATEGORY_FLUIDS] = {
                    displayName: 'Fluids',
                    badgeStyle: {
                        backgroundColor: '#0487ba',
                    }
                };
                ToolDefs.DEFAULT_CATEGORY_DEFINITIONS[ToolDefs.CATEGORY_SOLIDS] = {
                    displayName: 'Solids',
                    badgeStyle: {
                        backgroundColor: '#656565',
                    }
                };
                ToolDefs.DEFAULT_CATEGORY_DEFINITIONS[ToolDefs.CATEGORY_EFFECTS] = {
                    displayName: 'Effects',
                    badgeStyle: {
                        backgroundColor: '#ff5900',
                    }
                };
            }
    
    
            static NONE = Tools.actionTool(() => {}, new ToolInfo({
                codeName: 'none',
                displayName: 'None',
                category: ToolDefs.CATEGORY_NONE,
            }));
    
            static ERASE = Tools.roundBrushTool(BrushDefs.AIR, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'erase',
                displayName: 'Erase',
                category: ToolDefs.CATEGORY_NONE,
                badgeStyle: {
                    backgroundColor: '#e6e6e6',
                    color: 'black'
                }
            }));
    
            static MOVE = Tools.moveTool(13, 2048, new ToolInfo({
                codeName: 'move',
                displayName: 'Move',
                category: ToolDefs.CATEGORY_NONE,
                badgeStyle: {
                    backgroundColor: '#e6e6e6',
                    color: 'black'
                }
            }));
    
            static FLIP_VERTICALLY = Tools.globalActionTool(sg => sg.graphics().flipVertically(), new ToolInfo({
                codeName: 'flip_vertically',
                displayName: 'Flip \u2195',
                category: ToolDefs.CATEGORY_NONE,
                badgeStyle: {
                    backgroundColor: '#e6e6e6',
                    color: 'black'
                }
            }));
    
            static FLIP_HORIZONTALLY = Tools.globalActionTool(sg => sg.graphics().flipHorizontally(), new ToolInfo({
                codeName: 'flip_horizontally',
                displayName: 'Flip \u2194',
                category: ToolDefs.CATEGORY_NONE,
                badgeStyle: {
                    backgroundColor: '#e6e6e6',
                    color: 'black'
                }
            }));
    
            static SAND = Tools.roundBrushTool(BrushDefs.SAND, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'sand',
                displayName: 'Sand',
                category: ToolDefs.CATEGORY_POWDER,
                badgeStyle: {
                    backgroundColor: '#b7a643',
                }
            }));
    
            static SOIL = Tools.roundBrushTool(BrushDefs.SOIL, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'soil',
                displayName: 'Soil',
                category: ToolDefs.CATEGORY_POWDER,
                badgeStyle: {
                    backgroundColor: '#8e6848',
                }
            }));
    
            static GRAVEL = Tools.roundBrushTool(BrushDefs.GRAVEL, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'gravel',
                displayName: 'Gravel',
                category: ToolDefs.CATEGORY_POWDER,
                badgeStyle: {
                    backgroundColor: '#656565',
                }
            }));
    
            static COAL = Tools.roundBrushTool(BrushDefs.COAL, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'coal',
                displayName: 'Coal',
                category: ToolDefs.CATEGORY_POWDER,
                badgeStyle: {
                    backgroundColor: '#343434',
                }
            }));
    
            static THERMITE = Tools.roundBrushTool(BrushDefs.THERMITE, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'thermite',
                displayName: 'Thermite',
                category: ToolDefs.CATEGORY_POWDER,
                badgeStyle: {
                    backgroundColor: '#914e47',
                }
            }));
    
            static WALL = Tools.roundBrushTool(BrushDefs.WALL, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'wall',
                displayName: 'Wall',
                category: ToolDefs.CATEGORY_SOLIDS,
                badgeStyle: {
                    backgroundColor: '#383838',
                }
            }));
    
            static ROCK = Tools.roundBrushToolForSolidBody(BrushDefs.ROCK, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'rock',
                displayName: 'Rock',
                category: ToolDefs.CATEGORY_SOLIDS,
                badgeStyle: {
                    backgroundColor: '#383838',
                }
            }));
    
            static ROCK_TEMPLATES = Tools.templateSelectionTool([
                TemplateDefs.ROCK_SM,
                TemplateDefs.ROCK_MD,
                TemplateDefs.ROCK_LG,
                TemplateDefs.VOLCANO
            ], new ToolInfo({
                codeName: 'rock_templates',
                displayName: 'Rocks',
                category: ToolDefs.CATEGORY_SOLIDS,
                badgeStyle: {
                    backgroundColor: '#394538',
                }
            }));
    
            static WOOD = Tools.roundBrushToolForSolidBody(BrushDefs.TREE_WOOD, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'wood',
                displayName: 'Wood',
                category: ToolDefs.CATEGORY_SOLIDS,
                badgeStyle: {
                    backgroundColor: '#573005',
                }
            }));
    
            static GRASS = Tools.roundBrushTool(BrushDefs.GRASS, 2, new ToolInfo({
                codeName: 'grass',
                displayName: 'Grass',
                category: ToolDefs.CATEGORY_SOLIDS,
                badgeStyle: {
                    backgroundColor: '#125501',
                }
            }));
    
            static METAL = Tools.roundBrushToolForSolidBody(BrushDefs.METAL, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'metal',
                displayName: 'Metal',
                category: ToolDefs.CATEGORY_SOLIDS,
                badgeStyle: {
                    backgroundColor: '#7c7c7c',
                }
            }));
    
            static METAL_MOLTEN = Tools.roundBrushTool(BrushDefs.METAL_MOLTEN, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'metal_molten',
                displayName: 'M. Metal',
                category: ToolDefs.CATEGORY_FLUIDS,
                badgeStyle: {
                    backgroundColor: '#e67d00',
                }
            }));
    
            static WATER = Tools.roundBrushTool(BrushDefs.WATER, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'water',
                displayName: 'Water',
                category: ToolDefs.CATEGORY_FLUIDS,
                badgeStyle: {
                    backgroundColor: '#0487ba',
                }
            }));
            static OIL = Tools.roundBrushTool(BrushDefs.OIL, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'oil',
                displayName: 'Oil',
                category: ToolDefs.CATEGORY_FLUIDS,
                badgeStyle: {
                    backgroundColor: 'rgb(36,26,1)',
                }
            }));
    
            static FIRE = Tools.roundBrushTool(Brushes.temperatureOrBrush(50, BrushDefs.FIRE), ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'fire',
                displayName: 'Fire',
                category: ToolDefs.CATEGORY_EFFECTS,
                badgeStyle: {
                    backgroundColor: '#ff5900',
                }
            }));
    
            static METEOR = Tools.meteorTool(BrushDefs.METEOR, BrushDefs.METEOR_FROM_LEFT, BrushDefs.METEOR_FROM_RIGHT, new ToolInfo({
                codeName: 'meteor',
                displayName: 'Meteor',
                category: ToolDefs.CATEGORY_EFFECTS,
                badgeStyle: {
                    backgroundColor: '#ff5900',
                }
            }));
    
            static EFFECT_TEMP_MINUS = Tools.roundBrushTool(Brushes.concat(BrushDefs.EFFECT_TEMP_0, BrushDefs.EFFECT_EXTINGUISH),
                    ToolDefs.DEFAULT_SIZE, new ToolInfo({
    
                codeName: 'effect_temp_minus',
                displayName: 'C -',
                category: ToolDefs.CATEGORY_EFFECTS,
                badgeStyle: {
                    backgroundColor: '#63cffa',
                }
            }));
    
            static EFFECT_TEMP_PLUS = Tools.roundBrushTool(BrushDefs.EFFECT_TEMP_200, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'effect_temp_plus',
                displayName: 'C +',
                category: ToolDefs.CATEGORY_EFFECTS,
                badgeStyle: {
                    backgroundColor: '#fa9b4e',
                }
            }));
    
            static EFFECT_TEMP_PLUS2 = Tools.roundBrushTool(BrushDefs.EFFECT_TEMP_255, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                codeName: 'effect_temp_plus2',
                displayName: 'C ⧺',
                category: ToolDefs.CATEGORY_EFFECTS,
                badgeStyle: {
                    backgroundColor: '#fa9b4e',
                }
            }));
            static BIRD2 = Tools.insertEntityTool(EntityFactories.birdFactory, new ToolInfo({
                codeName: 'bird',
                displayName: 'Bird',
                category: ToolDefs.CATEGORY_BIOLOGICAL,
                badgeStyle: {
                    backgroundColor: '#000',
                }
            }));
            static CURSOR2 = Tools.insertEntityTool(EntityFactories.cursorFactory, new ToolInfo({
                codeName: 'cursor',
                displayName: 'Living Cursor',
                category: ToolDefs.CATEGORY_BIOLOGICAL,
                badgeStyle: {
                    backgroundColor: '#000',
                }
            }));
            static BIRDBIG = Tools.insertEntityTool(EntityFactories.birdBigFactory, new ToolInfo({
                codeName: 'bird_big',
                displayName: 'Lqarge Bird',
                category: ToolDefs.CATEGORY_BIOLOGICAL,
                badgeStyle: {
                    backgroundColor: '#000',
                }
            }));
    
            static BUTTERFLY2 = Tools.insertEntityTool(EntityFactories.butterflyFactory, new ToolInfo({
                codeName: 'butterfly',
                displayName: 'Butterfly',
                category: ToolDefs.CATEGORY_BIOLOGICAL,
                badgeStyle: {
                    backgroundColor: '#f00',
                }
            }));
    
            static FISH2 = Tools.insertEntityTool(EntityFactories.fishFactory, new ToolInfo({
                codeName: 'fish',
                displayName: 'Fish',
                category: ToolDefs.CATEGORY_BIOLOGICAL,
                badgeStyle: {
                    backgroundColor: '#000',
                }
            }));
            static WAYTOOL = Tools.actionTool((x, y, graphics) => {
                    graphics.entities().assignWaypoint(x, y);
                }, new ToolInfo({
                    codeName: 'entity_waypoint',
                    displayName: 'Waypoint',
                    category: ToolDefs.CATEGORY_BIOLOGICAL,
                badgeStyle: {
                    backgroundColor: '#999',
                }
            }));
                 static ASH = Tools.roundBrushTool(BrushDefs.ASH, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                    codeName: 'ash',
                    displayName: 'Ash',
                    category: ToolDefs.CATEGORY_POWDER,
                  badgeStyle: {
                        backgroundColor: '#aaa',
                    }
                }));
                static TREE = Tools.pointBrushTool(BrushDefs.TREE, new ToolInfo({
                    codeName: 'tree',
                    displayName: 'Tree',
                    category: ToolDefs.CATEGORY_BIOLOGICAL,
                      badgeStyle: {
                           backgroundColor: '#079134',
                       }
                }));
            /** @type Tool[] */
            static DEFAULT_TOOLS = [
                this.ERASE,
                this.MOVE,
                this.SAND,
                this.SOIL,
                this.GRAVEL,
                this.COAL,
                this.THERMITE,
                this.WATER,
                this.OIL,
                this.ROCK_TEMPLATES,
                this.WALL,
                this.METAL,
                this.METAL_MOLTEN,
                this.FIRE,
                this.METEOR,
                this.EFFECT_TEMP_MINUS,
                this.EFFECT_TEMP_PLUS,
                this.EFFECT_TEMP_PLUS2
            ];
    
            static BIRD = Tools.insertEntityTool(EntityFactories.birdFactory, new ToolInfo({
                codeName: 'bird',
                displayName: 'Bird',
                category: ToolDefs.CATEGORY_BIOLOGICAL,
            }));
    
            static BUTTERFLY = Tools.insertEntityTool(EntityFactories.butterflyFactory, new ToolInfo({
                codeName: 'butterfly',
                displayName: 'Butterfly',
                category: ToolDefs.CATEGORY_BIOLOGICAL,
            }));
    
            static FISH = Tools.insertEntityTool(EntityFactories.fishFactory, new ToolInfo({
                codeName: 'fish',
                displayName: 'Fish',
                category: ToolDefs.CATEGORY_BIOLOGICAL,
            }));
    
            /** @type Tool[] */
            static TEST_TOOLS = [
                Tools.pointBrushTool(BrushDefs.GRASS, new ToolInfo({
                    codeName: 'grass',
                    displayName: 'Grass',
                    category: ToolDefs.CATEGORY_BIOLOGICAL,
                })),
                Tools.pointBrushTool(BrushDefs.TREE, new ToolInfo({
                    codeName: 'tree',
                    displayName: 'Tree',
                    category: ToolDefs.CATEGORY_BIOLOGICAL,
                })),
                ToolDefs.BIRD,
                ToolDefs.BUTTERFLY,
                ToolDefs.FISH,
                Tools.actionTool((x, y, graphics) => {
                    graphics.entities().assignWaypoint(x, y);
                }, new ToolInfo({
                    codeName: 'entity_waypoint',
                    displayName: 'Waypoint',
                    category: ToolDefs.CATEGORY_BIOLOGICAL,
                })),
                Tools.roundBrushTool(BrushDefs.EFFECT_BURNT, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                    codeName: 'effect_burnt',
                    displayName: 'Burnt',
                    category: ToolDefs.CATEGORY_EFFECTS,
                })),
                Tools.roundBrushTool(BrushDefs.EFFECT_NOISE_SM, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                    codeName: 'effect_noise_sm',
                    displayName: 'Noise SM',
                    category: ToolDefs.CATEGORY_EFFECTS,
                })),
                Tools.roundBrushTool(BrushDefs.EFFECT_NOISE_MD, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                    codeName: 'effect_noise_md',
                    displayName: 'Noise MD',
                    category: ToolDefs.CATEGORY_EFFECTS,
                })),
                Tools.roundBrushTool(BrushDefs.EFFECT_NOISE_LG, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                    codeName: 'effect_noise_lg',
                    displayName: 'Noise LG',
                    category: ToolDefs.CATEGORY_EFFECTS,
                })),
                Tools.roundBrushTool(BrushDefs.EFFECT_TEMP_0, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                    codeName: 'effect_temp_0',
                    displayName: 'Temp 0',
                    category: ToolDefs.CATEGORY_EFFECTS,
                })),
                Tools.roundBrushTool(BrushDefs.EFFECT_TEMP_127, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                    codeName: 'effect_temp_127',
                    displayName: 'Temp 127',
                    category: ToolDefs.CATEGORY_EFFECTS,
                })),
                Tools.roundBrushTool(BrushDefs.EFFECT_TEMP_200, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                    codeName: 'effect_temp_200',
                    displayName: 'Temp 200',
                    category: ToolDefs.CATEGORY_EFFECTS,
                })),
                Tools.roundBrushTool(BrushDefs.EFFECT_TEMP_255, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                    codeName: 'effect_temp_255',
                    displayName: 'Temp 255',
                    category: ToolDefs.CATEGORY_EFFECTS,
                })),
                Tools.roundBrushTool(BrushDefs.ASH, ToolDefs.DEFAULT_SIZE, new ToolInfo({
                    codeName: 'ash',
                    displayName: 'Ash',
                    category: ToolDefs.CATEGORY_POWDER,
                }))
            ];
    
            static _LIST = {};
            static {
                for (const tool of [ToolDefs.NONE, ...ToolDefs.DEFAULT_TOOLS, ...ToolDefs.TEST_TOOLS]) {
                    ToolDefs._LIST[tool.getInfo().getCodeName()] = tool;
                }
            }
    
            static byCodeName(codeName) {
                const tool = ToolDefs._LIST[codeName];
                if (tool !== undefined) {
                    return tool;
                }
                return null;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @version 2024-05-07
         * @author Patrik Harag
         */
        class Analytics {
    
            static EVENT_NAME = 'app_sand_game_js';
            static FEATURE_APP_INITIALIZED = 'initialized';
            static FEATURE_SCENARIO_COMPLETED = 's_completed';
            static FEATURE_RENDERER_FALLBACK = 'renderer_fallback';
    
            // options bar
            static FEATURE_PAUSE = 'pause';
            static FEATURE_DRAW_PRIMARY = 'draw_primary';
            static FEATURE_DRAW_SECONDARY = 'draw_secondary';
            static FEATURE_DRAW_TERTIARY = 'draw_tertiary';
            static FEATURE_DRAW_LINE = 'draw_line';
            static FEATURE_DRAW_RECT = 'draw_rect';
            static FEATURE_DRAW_FLOOD = 'draw_flood';
            static FEATURE_STATUS_DISPLAYED = 'status_displayed';
            static FEATURE_OPTIONS_DISPLAYED = 'options_displayed';
            static FEATURE_RENDERER_PIXELATED = 'renderer_pixelated';
            static FEATURE_RENDERER_SHOW_CHUNKS = 'renderer_show_chunks';
            static FEATURE_RENDERER_SHOW_HEATMAP = 'renderer_show_heatmap';
            static FEATURE_CANVAS_SIZE_CHANGE = 'canvas_size_change';
            static FEATURE_SWITCH_SCENE = 'switch_scene';
            static FEATURE_RESTART_SCENE = 'restart_scene';
            static FEATURE_SWITCH_SCALE = 'switch_scale';
            static FEATURE_IO_EXPORT = 'io_export';
            static FEATURE_IO_IMPORT = 'io_import';
            static FEATURE_IO_IMAGE_TEMPLATE = 'io_image_template';
    
            static #USED_FEATURES = new Set();
    
    
            static triggerToolUsed(tool) {
                // Note: better feature name would be tool_xxx, but we will keep backward compatibility
    
                let name = tool.getInfo().getCodeName();
                if (name === undefined) {
                    if (tool instanceof InsertElementAreaTool || tool instanceof InsertRandomSceneTool) {
                        name = 'template';
                    } else if (tool instanceof InsertEntityTool) {
                        name = 'entity';
                    }
                }
                if (name !== undefined) {
                    const feature = 'brush_' + name;
                    Analytics.triggerFeatureUsed(feature);
                }
            }
    
            static triggerFeatureUsed(feature) {
                if (!Analytics.#USED_FEATURES.has(feature)) {
                    // report only the first usage
                    Analytics.#USED_FEATURES.add(feature);
                    Analytics.#report({
                        'app_sand_game_js_feature': feature
                    });
                }
            }
    
            static #report(properties) {
                if (typeof gtag === 'function') {
                    try {
                        gtag('event', Analytics.EVENT_NAME, properties);
                    } catch (e) {
                        console.warn(e);
                    }
                }
                // console.log('event: ' + Analytics.EVENT_NAME + ' = ' + JSON.stringify(properties));
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @version 2023-12-21
         * @author Patrik Harag
         */
        class DomBuilder {
    
            /**
             *
             * @param element {HTMLElement}
             * @param content {null|string|Node|(null|string|Node)[]}
             */
            static addContent(element, content) {
                if (content === null) ; else if (typeof content === 'string') {
                    element.textContent = content;
                } else if (content instanceof Node) {
                    element.appendChild(content);
                } else if (Array.isArray(content)) {
                    for (const item of content) {
                        if (item instanceof Node) {
                            element.appendChild(item);
                        } else if (typeof item === 'string') {
                            element.insertAdjacentText('beforeend', item);
                        } else if (item === null) ; else {
                            throw 'Content type not supported: ' + (typeof item);
                        }
                    }
                } else {
                    throw 'Content type not supported: ' + (typeof content);
                }
            }
    
            /**
             *
             * @param element {HTMLElement}
             * @param content {null|string|Node|(Node|null)[]}
             */
            static setContent(element, content) {
                element.innerHTML = '';
                DomBuilder.addContent(element, content);
            }
    
            /**
             *
             * @param element {HTMLElement}
             * @param attributes {object|null}
             */
            static putAttributes(element, attributes) {
                for (const key in attributes) {
                    const value = attributes[key];
                    const type = typeof value;
    
                    if (type === 'string' || type === 'boolean' || type === 'number') {
                        element.setAttribute(key, value);
                    } else if (key === 'style' && type === 'object') {
                        Object.assign(element.style, value);
                    } else if (value === null) ; else {
                        throw 'Unsupported attribute type: ' + (typeof value);
                    }
                }
            }
    
            /**
             *
             * @param html {string}
             * @return {HTMLElement}
             */
            static create(html) {
                const template = document.createElement('template');
                template.innerHTML = html.trim();
                return template.content.firstElementChild;
            }
    
            /**
             *
             * @param name {string}
             * @param attributes {object|null}
             * @param content {null|string|HTMLElement|HTMLElement[]}
             * @return {HTMLElement}
             */
            static element(name, attributes = null, content = null) {
                const element = document.createElement(name);
    
                // attributes
                DomBuilder.putAttributes(element, attributes);
    
                // content
                DomBuilder.addContent(element, content);
    
                return element;
            }
    
            /**
             *
             * @param attributes {object|null}
             * @param content {null|string|HTMLElement|HTMLElement[]}
             * @return {HTMLElement}
             */
            static div(attributes = null, content = null) {
                return DomBuilder.element('div', attributes, content);
            }
    
            /**
             *
             * @param attributes {object|null}
             * @param content {null|string|HTMLElement|HTMLElement[]}
             * @return {HTMLElement}
             */
            static par(attributes = null, content = null) {
                return DomBuilder.element('p', attributes, content);
            }
    
            /**
             *
             * @param text {string|null}
             * @param attributes {object|null}
             * @return {HTMLElement}
             */
            static span(text = null, attributes = null) {
                return DomBuilder.element('span', attributes, text);
            }
    
            /**
             *
             * @param text {string}
             * @param attributes {object|null}
             * @param handler {function()}
             * @return {HTMLElement}
             */
            static link(text, attributes = null, handler = null) {
                const link = DomBuilder.element('a', attributes, text);
                if (handler !== null) {
                    link.href = 'javascript:void(0)';
                    link.addEventListener('click', handler);
                }
                return link;
            }
    
            /**
             *
             * @param label {string|HTMLElement|HTMLElement[]}
             * @param attributes {object|null}
             * @param handler {function()}
             * @return {HTMLElement}
             */
            static button(label, attributes = null, handler = null) {
                if (attributes === null) {
                    attributes = {};
                }
                attributes['type'] = 'button';
    
                const button = DomBuilder.element('button', attributes, label);
                if (handler !== null) {
                    button.addEventListener('click', handler);
                }
                return button;
            }
    
            // bootstrap methods
    
            /**
             *
             * @param bodyContent {string|HTMLElement}
             * @return {HTMLElement}
             */
            static bootstrapAlertInfo(bodyContent) {
                const alertDiv = DomBuilder.div({ class: 'alert alert-info alert-dismissible fade show', role: 'alert' });
                DomBuilder.addContent(alertDiv, bodyContent);
                alertDiv.append(DomBuilder.button(null, { type: 'button', class: 'btn-close', 'data-bs-dismiss': 'alert', 'aria-label': 'Close' }));
                return alertDiv;
            }
    
            /**
             *
             * @param headerContent {string|HTMLElement|HTMLElement[]}
             * @param bodyContent {string|HTMLElement|HTMLElement[]}
             * @param attributes {object|null}
             * @return {HTMLElement}
             */
            static bootstrapCard(headerContent, bodyContent, attributes = null) {
                if (attributes === null) {
                    attributes = {};
                }
                if (attributes.class === undefined) {
                    attributes.class = 'card';
                }
    
                const card = DomBuilder.div(attributes);
    
                if (headerContent) {
                    card.append(DomBuilder.div({ class: 'card-header' }, headerContent));
                }
    
                card.append(DomBuilder.div({ class: 'card-body' }, bodyContent));
                return card;
            }
    
            /**
             *
             * @param title {string}
             * @param collapsed {boolean}
             * @param bodyContent {string|HTMLElement|HTMLElement[]}
             * @return {HTMLElement}
             */
            static bootstrapCardCollapsable(title, collapsed, bodyContent) {
                const id = 'collapsable_' + Math.floor(Math.random() * 999_999_999);
    
                return DomBuilder.div({ class: 'card' }, [
                    DomBuilder.div({ class: 'card-header' }, [
                        DomBuilder.element('a', { class: 'card-link', 'data-bs-toggle': 'collapse', href: '#' + id}, title)
                    ]),
                    DomBuilder.div({ id: id, class: (collapsed ? 'collapse' : 'collapse show') }, [
                        DomBuilder.div({ class: 'card-body' }, bodyContent)
                    ])
                ]);
            }
    
            /**
             *
             * @param content {string|HTMLElement}
             * @param node {HTMLElement}
             * @return {HTMLElement}
             */
            static bootstrapInitTooltip(content, node) {
                if (window.bootstrap === undefined) {
                    console.error('Bootstrap library not available');
                    return node;
                }
    
                const old = new window.bootstrap.Tooltip(node);
                if (old) {
                    old.dispose();
                }
    
                node.setAttribute('data-bs-toggle', 'tooltip');
                node.setAttribute('data-bs-placement', 'top');
                if (typeof content === 'object') {
                    node.setAttribute('data-bs-html', 'true');
                    node.setAttribute('title', content.innerHTML);
                } else {
                    node.setAttribute('title', content);
                }
    
                new window.bootstrap.Tooltip(node);
                return node;
            }
    
            /**
             *
             * @param text {string}
             * @param checked {boolean}
             * @param handler {function(boolean)}
             * @return {HTMLElement}
             */
            static bootstrapSwitchButton(text, checked, handler = null) {
                const id = 'switch-button_' + Math.floor(Math.random() * 999_999_999);
    
                const switchInput = DomBuilder.element('input', {
                    type: 'checkbox',
                    id: id,
                    class: 'form-check-input',
                    role: 'switch',
                    checked: checked
                });
    
                const control = DomBuilder.div({ class: 'form-check form-switch' }, [
                    switchInput,
                    DomBuilder.element('label', { class: 'form-check-label', for: id }, text)
                ]);
    
                if (handler !== null) {
                    switchInput.addEventListener('click', () => {
                        handler(switchInput.checked);
                    });
                }
                return control;
            }
    
            /**
             *
             * @param labelContent {string|HTMLElement}
             * @param buttonClass {string} e.g. btn-primary
             * @param checked {boolean}
             * @param handler {function(boolean)}
             * @return {HTMLElement[]}
             */
            static bootstrapToggleButton(labelContent, buttonClass, checked, handler = null) {
                const id = 'toggle-button_' + Math.floor(Math.random() * 999_999_999);
    
                const nodeInput = DomBuilder.element('input', {
                    type: 'checkbox',
                    class: 'btn-check',
                    checked: checked,
                    id: id
                });
                const nodeLabel = DomBuilder.element('label', {
                    class: 'btn ' + buttonClass,
                    for: id
                }, labelContent);
    
                nodeInput.addEventListener('change', (e) => {
                    if (handler !== null) {
                        handler(nodeInput.checked);
                    }
                });
    
                return [nodeInput, nodeLabel];
            }
    
            static bootstrapTableBuilder() {
                return new BootstrapTable();
            }
    
            static bootstrapDialogBuilder() {
                return new BootstrapDialog();
            }
    
            static bootstrapToastBuilder() {
                return new BootstrapToast();
            }
    
            static bootstrapSimpleFormBuilder() {
                return new BootstrapSimpleForm();
            }
        }
    
        /**
         *
         * @version 2023-12-21
         * @author Patrik Harag
         */
        class BootstrapTable {
    
            #tableBody = DomBuilder.element('tbody');
    
            addRow(row) {
                this.#tableBody.appendChild(row);
            }
    
            addRowBefore(row) {
                this.#tableBody.insertBefore(row, this.#tableBody.firstChild);
            }
    
            createNode() {
                const table = DomBuilder.element('table', { class: 'table table-striped' });
                table.appendChild(this.#tableBody);
    
                const tableResponsive = DomBuilder.div({ class: 'table-responsive' });
                tableResponsive.appendChild(table);
    
                return tableResponsive;
            }
        }
    
        /**
         *
         * @version 2023-12-24
         * @author Patrik Harag
         */
        class BootstrapDialog {
    
            // will be removed after close
            #persistent = false;
    
            #additionalStyle = '';
    
            #headerNode = null;
            #bodyNode = null;
            #footerNodeChildren = [];
    
            #dialog = null;
            #dialogBootstrap = null;
    
    
            setPersistent(persistent) {
                this.#persistent = persistent;
            }
    
            setSizeLarge() {
                this.#additionalStyle = 'modal-lg';
            }
    
            setSizeExtraLarge() {
                this.#additionalStyle = 'modal-xl';
            }
    
            setHeaderContent(headerNode) {
                if (typeof headerNode === 'string') {
                    this.#headerNode = DomBuilder.element('strong', null, headerNode);
                } else {
                    this.#headerNode = headerNode;
                }
            }
    
            setBodyContent(bodyNode) {
                this.#bodyNode = bodyNode;
            }
    
            addCloseButton(buttonText) {
                const button = DomBuilder.element('button', { type: 'button', class: 'btn btn-secondary', 'data-bs-dismiss': 'modal' }, buttonText);
                this.#footerNodeChildren.push(button);
            }
    
            addSubmitButton(buttonText, handler) {
                const button = DomBuilder.element('button', { type: 'button', class: 'btn btn-primary', 'data-bs-dismiss': 'modal' }, buttonText);
                button.addEventListener('click', handler);
                this.#footerNodeChildren.push(button);
            }
    
            addButton(button) {
                this.#footerNodeChildren.push(button);
            }
    
            show(dialogAnchor) {
                if (window.bootstrap === undefined) {
                    console.error('Bootstrap library not available');
                    return;
                }
    
                if (this.#dialog === null) {
                    this.#dialog = DomBuilder.div({ class: 'modal fade', tabindex: '-1', role: 'dialog', 'aria-hidden': 'true' }, [
                        DomBuilder.div({ class: `modal-dialog modal-dialog-centered ${this.#additionalStyle}` }, [
                            DomBuilder.div({ class: 'modal-content' }, [
                                DomBuilder.div({ class: 'modal-header' }, this.#headerNode),
                                DomBuilder.div({ class: 'modal-body' }, this.#bodyNode),
                                DomBuilder.div({ class: 'modal-footer' }, this.#footerNodeChildren)
                            ])
                        ])
                    ]);
    
                    // add into DOM
                    dialogAnchor.appendChild(this.#dialog);
                }
    
                this.#dialogBootstrap = new window.bootstrap.Modal(this.#dialog);
    
                if (!this.#persistent) {
                    // remove from DOM after hide
                    this.#dialog.addEventListener('hidden.bs.modal', () => {
                        dialogAnchor.removeChild(this.#dialog);
                    });
                }
    
                this.#dialogBootstrap.show();
            }
    
            hide() {
                if (this.#dialog !== null) {
                    this.#dialogBootstrap.hide();
                }
            }
        }
    
        /**
         *
         * @version 2023-12-22
         * @author Patrik Harag
         */
        class BootstrapToast {
    
            #headerNode = null;
            #bodyNode = null;
    
            #toast = null;
            #toastBootstrap = null;
    
            #dataDelay = 1000 * 60 * 60;  // ms
    
            setHeaderContent(headerNode) {
                if (typeof headerNode === 'string') {
                    headerNode = DomBuilder.element('strong', headerNode);
                }
                this.#headerNode = DomBuilder.span(headerNode, { class: 'me-auto' });
            }
    
            setBodyContent(bodyNode) {
                this.#bodyNode = bodyNode;
            }
    
            setDelay(milliseconds) {
                this.#dataDelay = milliseconds;
            }
    
            show(dialogAnchor) {
                if (window.bootstrap === undefined) {
                    console.error('Bootstrap library not available');
                    return;
                }
    
                const wrapperAttributes = {
                    class: 'position-fixed bottom-0 right-0 p-3',
                    style: 'z-index: 5; right: 0; bottom: 0;'
                };
                const toastAttributes = {
                    class: 'toast hide',
                    role: 'alert',
                    'aria-live': 'assertive',
                    'aria-atomic': 'true',
                    'data-bs-delay': this.#dataDelay
                };
                const wrapper = DomBuilder.div(wrapperAttributes, [
                    this.#toast = DomBuilder.div(toastAttributes, [
                        DomBuilder.div({ class: 'toast-header' }, [
                            this.#headerNode,
                            DomBuilder.button('', {
                                type: 'button',
                                class: 'btn-close',
                                'data-bs-dismiss': 'toast',
                                'aria-label': 'Close'
                            })
                        ]),
                        DomBuilder.div({ class: 'toast-body' }, [
                            this.#bodyNode,
    
                        ])
                    ])
                ]);
    
                // add into DOM
                dialogAnchor.append(wrapper);
    
                this.#toastBootstrap = new window.bootstrap.Toast(this.#toast);
    
                // remove from DOM after hide
                this.#toast.addEventListener('hidden.bs.toast', () => {
                    dialogAnchor.removeChild(wrapper);
                });
    
                this.#toastBootstrap.show();
            }
    
            hide() {
                if (this.#toast !== null) {
                    this.#toastBootstrap.hide();
                }
            }
        }
    
        /**
         *
         * @version 2023-12-22
         * @author Patrik Harag
         */
        class BootstrapSimpleForm {
    
            /** @type {{key:string,label:string,input:HTMLElement}[]} */
            #formFields = [];
            #submitButton = null;
    
            addTextArea(label, key, initialValue = '', rows = 8) {
                let input = DomBuilder.element('textarea', { class: 'form-control', rows: rows }, initialValue);
                this.#formFields.push({
                    key: key,
                    label: label,
                    input: input
                });
                return input;
            }
    
            addInput(label, key, initialValue = '') {
                let input = DomBuilder.element('input', { class: 'form-control' });
                if (initialValue) {
                    input.value = initialValue;
                }
                this.#formFields.push({
                    key: key,
                    label: label,
                    input: input
                });
                return input;
            }
    
            addSubmitButton(text, handler) {
                this.#submitButton = DomBuilder.button(text, { class: 'btn btn-primary' }, e => {
                    handler(this.getData());
                });
            }
    
            createNode() {
                let form = DomBuilder.element('form', { action: 'javascript:void(0);' });
    
                for (let formField of this.#formFields) {
                    form.append(DomBuilder.div({ class: 'mb-3' }, [
                        DomBuilder.element('label', null, formField.label),
                        formField.input
                    ]));
                }
    
                if (this.#submitButton) {
                    form.append(this.#submitButton);
                }
    
                return form;
            }
    
            getData() {
                let data = {};
                for (let formField of this.#formFields) {
                    data[formField.key] = formField.input.value;
                }
                return data;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2022-09-25
         */
        class Counter {
    
            #currentValue = 0;
            #lastValue = 0;
            #start = 0;
    
            tick(currentTimeMillis) {
                this.#currentValue++;
                if (currentTimeMillis - this.#start >= 1000) {
                    this.#lastValue = this.#currentValue;
                    this.#currentValue = 0;
                    this.#start = currentTimeMillis;
                }
            }
    
            getValue() {
                return this.#lastValue;
            }
    
            clear() {
                this.#lastValue = 0;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-24
         */
        class EntityPositionLookup {
    
            #table;
            #width;
            #height;
    
            /**
             *
             * @param entities {Entity[]}
             * @param width {number} element area width
             * @param height {number} element area height
             */
            constructor(entities, width, height) {
                this.#width = width;
                this.#height = height;
                const table = new Map();
                for (const entity of entities) {
                    const index = (entity.getY() * width) + entity.getX();
                    let array = table.get(index);
                    if (array === undefined) {
                        array = [];
                        table.set(index, array);
                    }
                    array.push(entity);
                }
                this.#table = table;
            }
    
            /**
             *
             * @param x {number}
             * @param y {number}
             * @return {Entity[]}
             */
            getAt(x, y) {
                if (x < 0 || y < 0) {
                    return [];
                }
                if (x >= this.#width || y >= this.#height) {
                    return [];
                }
                const array = this.#table.get((y * this.#width) + x);
                return array !== undefined ? array : [];
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-04
         */
        class EntityManager {
    
            /** @type GameState */
            #gameState;
    
            /** @type Entity[] */
            #entities = [];
    
            /** @type {EntityPositionLookup} */
            #positionLookupCache = null;
    
            /**
             *
             * @param serializedEntities {object[]}
             * @param gameState {GameState}
             */
            constructor(serializedEntities, gameState) {
                this.#gameState = gameState;
    
                for (let serializedEntity of serializedEntities) {
                    this.addSerializedEntity(serializedEntity, false);
                }
            }
    
            addSerializedEntity(serializedEntity, autoInitialize = true) {
                try {
                    const entity = this.#deserialize(serializedEntity);
                    this.#entities.push(entity);
                    if (autoInitialize) {
                        entity.initialize();
                    }
                    return entity;
                } catch (e) {
                    console.warn('Cannot deserialize entity', e);
                    return null;
                }
            }
    
            /**
             *
             * @param serialized {object}
             * @return {Entity}
             */
            #deserialize(serialized) {
                if (typeof serialized !== 'object') {
                    throw 'Serialized entity must be an object';
                }
                const factory = EntityFactories.findFactoryByEntityType(serialized.entity);
                if (factory !== null) {
                    return factory(serialized, this.#gameState);
                }
                throw 'Entity not recognized';
            }
    
            performBeforeProcessing() {
                for (let i = 0; i < this.#entities.length; i++) {
                    const entity = this.#entities[i];
                    entity.performBeforeProcessing();
                }
    
                this.#positionLookupCache = null;
            }
    
            performAfterProcessing() {
                let toDelete = null;
    
                for (let i = 0; i < this.#entities.length; i++) {
                    const entity = this.#entities[i];
    
                    let active;
                    try {
                        active = entity.performAfterProcessing();
                    } catch (e) {
                        // some entities are very complex...
                        // log error and remove broken entity
                        console.error('Entity error', e);
                        // TODO: rethrow + error reporting (when stable)
                        active = false;
                    }
    
                    if (active === false) {
                        if (toDelete === null) {
                            toDelete = [];
                        }
                        toDelete.push();
                    }
                }
    
                if (toDelete !== null) {
                    for (let i = toDelete.length - 1; i >= 0; i--) {
                        const j = toDelete[i];
                        this.#entities.splice(j, 1);
                    }
                }
    
                this.#positionLookupCache = null;
            }
    
            serializeEntities() {
                const list = [];
                for (let entity of this.#entities) {
                    list.push(entity.serialize());
                }
                return list;
            }
    
            /**
             *
             * @param x
             * @param y
             * @returns {Entity[]}
             */
            getAt(x, y) {
                if (this.#positionLookupCache === null) {
                    const width = this.#gameState.elementArea.getWidth();
                    const height = this.#gameState.elementArea.getHeight();
                    this.#positionLookupCache = new EntityPositionLookup(this.#entities, width, height);
                }
    
                return this.#positionLookupCache.getAt(x, y);
            }
    
            countEntities(type) {
                let count = 0;
                for (let i = 0; i < this.#entities.length; i++) {
                    const entity = this.#entities[i];
                    if (type === entity.getType()) {
                        count++;
                    }
                }
                return count;
            }
    
            getEntities() {
                return this.#entities;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class GameDefaults {
    
            /**
             * @returns function(GameState):Extension[]
             */
            getExtensionsFactory() {
                throw 'Not implemented';
            }
    
            /**
             *
             * @return BrushCollection
             */
            getBrushCollection() {
                throw 'Not implemented';
            }
    
            /**
             * @return Element
             */
            getDefaultElement() {
                throw 'Not implemented';
            }
    
            // brushes
    
            /**
             * @return Brush
             */
            getBrushWater() {
                throw 'Not implemented';
            }
    
            /**
             * @return Brush
             */
            getBrushSteam() {
                throw 'Not implemented';
            }
    
            /**
             * @return Brush
             */
            getBrushGrass() {
                throw 'Not implemented';
            }
    
            /**
             * @return Brush
             */
            getBrushTree() {
                throw 'Not implemented';
            }
    
            /**
             * @return Brush
             */
            getBrushTreeWood() {
                throw 'Not implemented';
            }
    
            /**
             * @return Brush
             */
            getBrushTreeWoodDark() {
                throw 'Not implemented';
            }
    
            /**
             * @return Brush
             */
            getBrushTreeRoot() {
                throw 'Not implemented';
            }
    
            /**
             * @return Brush
             */
            getBrushTreeLeaf() {
                throw 'Not implemented';
            }
    
            /**
             * @return Brush
             */
            getBrushTreeLeafDark() {
                throw 'Not implemented';
            }
    
            /**
             * @return Brush
             */
            getBrushFire() {
                throw 'Not implemented';
            }
    
            /**
             * @return Brush
             */
            getBrushAsh() {
                throw 'Not implemented';
            }
    
            // structures
    
            /**
             * @return []
             */
            getTreeTrunkTemplates() {
                throw 'Not implemented';
            }
    
            /**
             * @return []
             */
            getTreeLeafClusterTemplates() {
                throw 'Not implemented';
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-26
         */
        class ProcessorModuleSolidBody {
    
            static #QUEUED_PAINT_ID = 255;
            static #NEWLY_CREATED_PAINT_ID = 254;
            static #BODY_SIZE_LIMIT_MAX = 8192;
            static #BODY_SIZE_LIMIT_MIN = 32;
    
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type ProcessorContext */
            #processorContext;
    
            /** @type Uint8Array */
            #elementAreaOverlay;
    
            /** @type Set */
            #moved;
    
            constructor(elementArea, random, processorContext) {
                this.#elementArea = elementArea;
                this.#random = random;
                this.#processorContext = processorContext;
                this.#elementAreaOverlay = new Uint8Array(elementArea.getWidth() * elementArea.getHeight());
                this.#moved = new Set();
                this.#reusableLowerBorderMinY = new Uint16Array(elementArea.getWidth());
            }
    
            onSolidCreated(elementHead, x, y) {
                this.#elementAreaOverlay[x + (y * this.#elementArea.getWidth())] = ProcessorModuleSolidBody.#NEWLY_CREATED_PAINT_ID;
            }
    
            onNextIteration() {
                // TODO: optimize - do not clean if not used or needed
                this.#elementAreaOverlay.fill(0);
                this.#moved.clear();
            }
    
            behaviourSolid(elementHead, x, y) {
                const bodyId = ElementHead.getTypeModifierSolidBodyId(elementHead);
                // TODO: optimize - map paint id
                const paintId = bodyId;
    
                const point = x + (y * this.#elementArea.getWidth());
                const currentPaintId = this.#elementAreaOverlay[point];
                if (currentPaintId === ProcessorModuleSolidBody.#NEWLY_CREATED_PAINT_ID) {
                    // this handles newly created tree branches etc.
                    return true;
                }
                if (currentPaintId === paintId) {
                    // already processed
                    return this.#moved.has(paintId);
                }
    
                const [
                    originalCount, upperBorderStack, lowerBorderStack, lowerBorderMin, properties
                ] = this.#discoverBoundaries(x, y, elementHead, paintId);
    
                if (this.#processorContext.isFallThroughEnabled()) {
                    if (this.#bodyFallthrough(lowerBorderStack.shadowClone(), paintId)) {
                        return true;
                    }
                }
    
                this.#extendUpperBoundaries(upperBorderStack, lowerBorderMin, paintId);
    
                const [
                    borderCount, borderCountCanMove
                ] = this.#determineCanMove(lowerBorderStack.shadowClone(), paintId);
    
                // if (count >= ProcessorModuleSolidBody.#BODY_SIZE_LIMIT_MAX) {
                //     // too big
                //     return false;
                // }
    
                // if (count < ProcessorModuleSolidBody.#BODY_SIZE_LIMIT_MIN) {
                //     this.#bodyDestroy(paintId, borderStack);
                //     return true;
                // }
    
                if (properties.tree) {
                    // living trees are more stable
                    if (borderCount === borderCountCanMove) {
                        // falling
                        this.#bodyMove(paintId, lowerBorderStack);
                        this.#moved.add(paintId);
                        return true;
                    }
                } else {
                    if (borderCountCanMove / borderCount > 0.95) {
                        // falling or very unstable
                        this.#bodyMove(paintId, lowerBorderStack);
                        this.#moved.add(paintId);
                        return true;
                    }
    
                    if (borderCountCanMove / borderCount > 0.75) {
                        // unstable
                        this.#bodyPush(paintId, lowerBorderStack);
                        return false;
                    }
                }
    
                return false;
            }
    
            #bodyDestroy(paintId, lowerBorderStack) {
                const w = this.#elementArea.getWidth();
    
                let point;
                while ((point = lowerBorderStack.pop()) !== null) {
                    // process "column"
    
                    if (point === 0xffffffff) {
                        // null point
                        continue;
                    }
    
                    const bx = point % w;
                    const by = Math.trunc(point / w);
    
                    let i = 0;
                    do {
                        let elementHead = this.#elementArea.getElementHead(bx, by + i);
    
                        const type = this.#random.nextInt(100) < 20 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
                        elementHead = ElementHead.setType(elementHead, ElementHead.type8Powder(type, 4));
    
                        let elementTail = this.#elementArea.getElementTail(bx, by + i);
                        this.#elementArea.setElementHead(bx, by + i, elementHead);
                        this.#elementArea.setElementTail(bx, by + i, elementTail);
    
                        if (by + i >= 0) {
                            const nextPaintId = this.#elementAreaOverlay[bx + ((by + i - 1) * w)];
                            if (nextPaintId === paintId) {
                                i--;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    } while (true);
                }
            }
    
            #bodyMove(paintId, lowerBorderStack) {
                const w = this.#elementArea.getWidth();
                const h = this.#elementArea.getHeight();
    
                let point;
                while ((point = lowerBorderStack.pop()) !== null) {
                    // process "column"
    
                    if (point === 0xffffffff) {
                        // null point
                        continue;
                    }
    
                    const bx = point % w;
                    const by = Math.trunc(point / w);
    
                    let elementHeadOld = null;
                    let elementTailOld = null;
                    if (by + 1 < h) {
                        elementHeadOld = this.#elementArea.getElementHead(bx, by + 1);
                        elementTailOld = this.#elementArea.getElementTail(bx, by + 1);
                    }
    
                    let i = 0;
                    do {
                        const ty = by + 1 + i;
                        if (ty < h) {
                            this.#elementArea.setElementHead(bx, ty, this.#elementArea.getElementHead(bx, by + i));
                            this.#elementArea.setElementTail(bx, ty, this.#elementArea.getElementTail(bx, by + i));
                            this.#elementAreaOverlay[bx + (ty * w)] = paintId;
                        }
    
                        if (by + i >= 0) {
                            const nextPaintId = this.#elementAreaOverlay[bx + ((by + i - 1) * w)];
                            if (nextPaintId === paintId) {
                                i--;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    } while (true);
    
                    // deal with the old element
    
                    let reuseElement = false;
                    if (elementHeadOld != null) {
                        const typeClass = ElementHead.getTypeClass(elementHeadOld);
                        if (typeClass === ElementHead.TYPE_AIR) {
                            reuseElement = true;
                        } else if (typeClass <= ElementHead.TYPE_FLUID) {
                            reuseElement = this.#reuseFluid(Math.abs(i));
                        }
                    }
    
                    if (reuseElement) {
                        // move element above the solid body
                        this.#elementArea.setElementHead(bx, by + i, elementHeadOld);
                        this.#elementArea.setElementTail(bx, by + i, elementTailOld);
                    } else {
                        // set default element
                        this.#elementArea.setElement(bx, by + i, this.#processorContext.getDefaults().getDefaultElement());
                    }
    
                    // create some movement below
    
                    this.triggerPowderElement(bx, by + 2);
                }
            }
    
            #reuseFluid(distance) {
                let f = 1 - (1 / (1 + Math.exp(-(0.1) * (distance - 50))));  // https://en.wikipedia.org/wiki/Sigmoid_function
                return this.#random.next() < f;
            }
    
            #bodyPush(paintId, lowerBorderStack) {
                const w = this.#elementArea.getWidth();
    
                let point;
                while ((point = lowerBorderStack.pop()) !== null) {
                    // process "column"
    
                    if (point === 0xffffffff) {
                        // null point
                        continue;
                    }
    
                    const bx = point % w;
                    const by = Math.trunc(point / w);
    
                    // create some movement below
    
                    this.triggerPowderElement(bx, by + 1);
                }
            }
    
            triggerPowderElement(x, y) {
                if (this.#elementArea.isValidPosition(x, y)) {
                    const elementHeadUnder = this.#elementArea.getElementHead(x, y);
                    const typeUnder = ElementHead.getTypeClass(elementHeadUnder);
    
                    if (typeUnder === ElementHead.TYPE_POWDER || typeUnder === ElementHead.TYPE_POWDER_WET) {
                        let modified = elementHeadUnder;
                        modified = ElementHead.setTypeModifierPowderSliding(modified, 1);
                        if (this.#random.nextInt(15) === 0) {
                            // change direction only once a while to make it less chaotic
                            modified = ElementHead.setTypeModifierPowderDirection(modified, this.#random.nextInt(2));
                        }
                        this.#elementArea.setElementHead(x, y, modified);
                    }
                }
            }
    
            #determineCanMove(lowerBorderStack, paintId) {
                const w = this.#elementArea.getWidth();
                const h = this.#elementArea.getHeight();
    
                let borderCount = 0;
                let borderCountCanMove = 0;
    
                let point;
                while ((point = lowerBorderStack.pop()) !== null) {
    
                    const bx = point % w;
                    const by = Math.trunc(point / w);
    
                    if (by + 1 < h) {
                        const elementHead = this.#elementArea.getElementHead(bx, by + 1);
    
                        // check whether is not connected with other "column" by extendUpperBoundaries
                        if (this.#elementAreaOverlay[bx + ((by + 1) * w)] === paintId) {
                            lowerBorderStack.removePrevious();  // remove
                            continue;
                        }
    
                        borderCount++;
    
                        // can move here?
                        const typeClass = ElementHead.getTypeClass(elementHead);
                        switch (typeClass) {
                            case ElementHead.TYPE_AIR:
                            case ElementHead.TYPE_EFFECT:
                            case ElementHead.TYPE_GAS:
                            case ElementHead.TYPE_FLUID:
                                borderCountCanMove++;
                        }
                    } else {
                        borderCount++;
                    }
                }
    
                return [borderCount, borderCountCanMove];
            }
    
            #bodyFallthrough(lowerBorderStack, paintId) {
                const w = this.#elementArea.getWidth();
                const h = this.#elementArea.getHeight();
    
                let applied = false;
    
                let point;
                while ((point = lowerBorderStack.pop()) !== null) {
    
                    const bx = point % w;
                    const by = Math.trunc(point / w);
    
                    if (by === h - 1) {
                        // destroy
    
                        let elementHead = this.#elementArea.getElementHead(bx, by);
                        elementHead = ElementHead.setType(elementHead, ElementHead.type8Powder(ElementHead.TYPE_POWDER, 5));
    
                        let elementTail = this.#elementArea.getElementTail(bx, by);
                        elementTail = ElementTail.setBlurType(elementTail, ElementTail.BLUR_TYPE_1);
    
                        this.#elementArea.setElementHeadAndTail(bx, by, elementHead, elementTail);
    
                        applied = true;
                    }
                }
    
                return applied;
            }
    
            #extendUpperBoundaries(upperBorderStack, lowerBorderMinY, paintId) {
                // handles e.g. sand /stuck/ inside a solid body
    
                const w = this.#elementArea.getWidth();
                this.#elementArea.getHeight();
    
                let extendedCount = 0;
    
                let point;
                while ((point = upperBorderStack.pop()) !== null) {
                    const bx = point % w;
                    const by = Math.trunc(point / w);
    
                    const columnLowerBorderMinY = lowerBorderMinY[bx];
                    if (columnLowerBorderMinY >= by) {
                        continue;
                    }
                    // there is at leas one lower border above this upper border
    
                    let i = 0;
                    let ty;
                    while ((ty = by - (i + 1)) >= 0 && ty > columnLowerBorderMinY) {
                        const nextPaintId = this.#elementAreaOverlay[bx + (ty * w)];
    
                        if (nextPaintId === paintId) {
                            // lower boundary reached
                            break;
                        }
    
                        if (nextPaintId !== 0) {
                            // already in another body
                            break;
                        }
    
                        const elementHead = this.#elementArea.getElementHead(bx, ty);
                        const typeClass = ElementHead.getTypeClass(elementHead);
    
                        // TODO: Im not sure here
                        /*if (typeClass <= ElementHead.TYPE_FLUID) {
                            // light element
                            break;
                        } else*/ if (typeClass < ElementHead.TYPE_STATIC) {
                            // extend
                            this.#elementAreaOverlay[bx + (ty * w)] = paintId;
                            extendedCount++;
                            i++;
                        } else {
                            // too heavy element
                            break;
                        }
                    }
                }
    
                return extendedCount;
            }
    
            #reusableWorkStack = new Uint32Stack();
            #reusableUpperBorderStack = new Uint32Stack();
            #reusableLowerBorderStack = new Uint32Stack();
            #reusableLowerBorderMinY;  // new Uint16Array(width);
    
            /**
             *
             * @param x {number}
             * @param y {number}
             * @param elementHead {number}
             * @param paintId {number}
             * @return {[number, Uint32Stack, Uint32Stack, Uint16Array, object]} result
             */
            #discoverBoundaries(x, y, elementHead, paintId) {
                const pattern = 0b11110111;  // falling id and type class
                const matcher = this.#elementArea.getElementHead(x, y) & pattern;
    
                const w = this.#elementArea.getWidth();
    
                const stack = this.#reusableWorkStack;
                stack.reset();
    
                const upperBorderStack = this.#reusableUpperBorderStack;
                upperBorderStack.reset();
    
                const lowerBorderStack = this.#reusableLowerBorderStack;
                lowerBorderStack.reset();
    
                const lowerBorderMinY = this.#reusableLowerBorderMinY;
                lowerBorderMinY.fill(0xffff);  // not set
    
                const properties = {
                    tree: ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_TREE  // default value
                };
    
                let count = 0;
                let point = x + y * w;
                do {
                    const x = point % w;
                    const y = Math.trunc(point / w);
    
                    this.#elementAreaOverlay[point] = paintId;
                    count++;
    
                    const upperBorder = this.#discoverNeighbour(x, y - 1, pattern, matcher, stack, paintId, properties);
                    if (upperBorder) {
                        upperBorderStack.push(point);
                    }
    
                    this.#discoverNeighbour(x + 1, y, pattern, matcher, stack, paintId, properties);
                    this.#discoverNeighbour(x - 1, y, pattern, matcher, stack, paintId, properties);
    
                    if (ElementHead.getTypeModifierSolidNeighbourhoodType(this.#elementArea.getElementHead(x, y)) === 0) {
                        // extended neighbourhood
                        this.#discoverNeighbour(x + 1, y - 1, pattern, matcher, stack, paintId, properties);
                        this.#discoverNeighbour(x - 1, y - 1, pattern, matcher, stack, paintId, properties);
                        this.#discoverNeighbour(x + 1, y + 1, pattern, matcher, stack, paintId, properties);
                        this.#discoverNeighbour(x - 1, y + 1, pattern, matcher, stack, paintId, properties);
                    }
    
                    const lowerBorder = this.#discoverNeighbour(x, y + 1, pattern, matcher, stack, paintId, properties);
                    if (lowerBorder) {
                        lowerBorderStack.push(point);
                        const oldMin = lowerBorderMinY[x];
                        lowerBorderMinY[x] = (oldMin === 0xffff) ? y : Math.min(oldMin, y);
                    }
    
                } while ((point = stack.pop()) != null);
    
                return [count, upperBorderStack, lowerBorderStack, lowerBorderMinY, properties];
            }
    
            #discoverNeighbour(x, y, pattern, matcher, stack, targetPaintId, properties) {
                if (x < 0 || y < 0) {
                    return true;  // border
                }
    
                const w = this.#elementArea.getWidth();
                const h = this.#elementArea.getHeight();
                if (x >= w || y >= h) {
                    return true;  // border
                }
    
                const point = x + (y * w);
                const currentPaintId = this.#elementAreaOverlay[point];
                if (currentPaintId === ProcessorModuleSolidBody.#QUEUED_PAINT_ID) {
                    // already queued
                    return false;  // no border
                }
                if (currentPaintId === targetPaintId) {
                    // already done
                    return false;  // no border
                }
    
                const elementHead = this.#elementArea.getElementHead(x, y);
    
                if (!properties.tree) {
                    if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_TREE) {
                        properties.tree = true;
                    }
                }
    
                if ((elementHead & pattern) !== matcher) {
                    // no match
                    return true;  // border
                }
    
                this.#elementAreaOverlay[point] = ProcessorModuleSolidBody.#QUEUED_PAINT_ID;
                stack.push(point);
                return false;  // no border
            }
        }
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-03-23
         */
        class Uint32Stack {
            static create(size) {
                return new Uint32Stack(new Uint32Array(Math.max(1, size)));
            }
    
            /** @type Uint32Array */
            #array;
            #i = -1;
    
            constructor(array = new Uint32Array(1)) {
                this.#array = array;
            }
    
            push(value) {
                if (this.#array.length === this.#i + 1) {
                    // increase size
                    const newArray = new Uint32Array(this.#array.length * 2);
                    newArray.set(this.#array);
                    this.#array = newArray;
                }
                this.#array[++this.#i] = value;
            }
    
            pop() {
                if (this.#i === -1) {
                    return null;
                }
                return this.#array[this.#i--];
            }
    
            shadowClone() {
                const clone = new Uint32Stack(this.#array);
                clone.#i = this.#i;
                return clone;
            }
    
            removePrevious() {
                this.#array[this.#i + 1] = 0xffffffff;
            }
    
            reset() {
                this.#i = -1;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-25
         */
        class ProcessorModuleEntity {
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type ProcessorContext */
            #processorContext;
    
            constructor(elementArea, random, processorContext) {
                this.#elementArea = elementArea;
                this.#random = random;
                this.#processorContext = processorContext;
            }
    
            behaviourEntity(elementHead, x, y) {
                const special = ElementHead.getSpecial(elementHead);
    
                if (special < 5) {
                    // increment
                    const newElementHead = ElementHead.setSpecial(elementHead, special + 1);
                    this.#elementArea.setElementHead(x, y, newElementHead);
                } else {
                    // destroy
                    const type = this.#random.nextInt(100) < 20 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
    
                    let newElementHead = elementHead;
                    newElementHead = ElementHead.setType(newElementHead, ElementHead.type8Powder(type, 4));
                    newElementHead = ElementHead.setBehaviour(newElementHead, ElementHead.BEHAVIOUR_NONE);
                    newElementHead = ElementHead.setSpecial(newElementHead, 0);
                    this.#elementArea.setElementHead(x, y, newElementHead);
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-01
         */
        class ProcessorModuleFire {
    
            static #FIRE_MIN_TEMPERATURE = 34;
    
            static createFireElementHead(temperature) {
                let elementHead = ElementHead.of(ElementHead.TYPE_EFFECT, ElementHead.BEHAVIOUR_FIRE);
                elementHead = ElementHead.setTemperature(elementHead, temperature);
                return elementHead;
            }
    
            static createFireElementTail(temperature) {
                let elementTail = ElementTail.of(0, 0, 0);
    
                if (temperature > 213)
                    elementTail = ElementTail.setColor(elementTail, 249, 219, 30);
                else if (temperature > 170)
                    elementTail = ElementTail.setColor(elementTail, 248, 201,  7);
                else if (temperature > 128)
                    elementTail = ElementTail.setColor(elementTail, 250, 150,  3);
                else if (temperature > 85)
                    elementTail = ElementTail.setColor(elementTail, 255, 111,  0);
                else if (temperature > 80)
                    elementTail = ElementTail.setColor(elementTail, 255,  37,  0);
                else if (temperature > 75)
                    elementTail = ElementTail.setColor(elementTail, 250,   4,  5);
                else
                    elementTail = ElementTail.setColor(elementTail, 125,   0,  0);
    
                return elementTail;
            }
    
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type ProcessorContext */
            #processorContext;
    
            constructor(elementArea, random, processorContext) {
                this.#elementArea = elementArea;
                this.#random = random;
                this.#processorContext = processorContext;
            }
    
            // FIRE
    
            behaviourFire(elementHead, x, y) {
                if (this.#random.nextInt(4) !== 0) {
                    return;  // it would disappear too quickly...
                }
    
                // count new temperature
                const temperature = ElementHead.getTemperature(elementHead);
                const newTemperature = this.#countNewTemperature(x, y, temperature);
                if (newTemperature < ProcessorModuleFire.#FIRE_MIN_TEMPERATURE) {
                    // the fire will disappear
                    this.#elementArea.setElement(x, y, this.#processorContext.getDefaults().getDefaultElement());
                    return;
                }
    
                const elementHeadAbove = this.#elementArea.getElementHeadOrNull(x, y - 1);
                // check is above water
                if (ElementHead.getBehaviour(elementHeadAbove) === ElementHead.BEHAVIOUR_WATER) {
                    this.#elementArea.setElement(x, y, this.#processorContext.getDefaults().getDefaultElement());
                    return;
                }
    
                // spread or update
                if (elementHeadAbove !== null && this.#couldBeReplacedByFire(elementHeadAbove)) {
                    this.#elementArea.setElementHead(x, y - 1, ProcessorModuleFire.createFireElementHead(newTemperature));
                    this.#elementArea.setElementTail(x, y - 1, ProcessorModuleFire.createFireElementTail(newTemperature));
                } else {
                    this.#elementArea.setElementHead(x, y, ElementHead.setTemperature(elementHead, newTemperature));
                    this.#elementArea.setElementTail(x, y, ProcessorModuleFire.createFireElementTail(newTemperature));
                }
    
                // affect near elements:
                //   # #
                //   #O#
                //    #
                this.#fireEffect(x + 1, y - 1, newTemperature);
                this.#fireEffect(x - 1, y - 1, newTemperature);
                this.#fireEffect(x + 1, y, newTemperature);
                this.#fireEffect(x - 1, y, newTemperature);
                this.#fireEffect(x, y + 1, newTemperature);
            }
    
            #countNewTemperature(x, y, currentTemperature) {
                let newTemperature = currentTemperature
                        + this.#getTemperatureAt(x, y + 1)          // under
                        + this.#getTemperatureAt(x + 1, y + 1)   // under right
                        + this.#getTemperatureAt(x - 1, y + 1);  // under left
    
                newTemperature = newTemperature / 4;
    
                if (newTemperature < 76) {
                    if (this.#random.nextInt(2) === 0) {
                        newTemperature -= this.#random.nextInt(10);
                    }
                } else {
                    if (this.#random.nextInt(2) === 0) {
                        newTemperature -= this.#random.nextInt(50);
                    }
                }
                if (newTemperature < 0) {
                    newTemperature = 0;
                }
                return newTemperature;
            }
    
            #getTemperatureAt(x, y) {
                const elementHead = this.#elementArea.getElementHeadOrNull(x, y);
                if (elementHead !== null) {
                    return ElementHead.getTemperature(elementHead);
                }
                return null;
            }
    
            #couldBeReplacedByFire(elementHead) {
                return ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_AIR;
            }
    
            #fireEffect(x, y, temperature) {
                const elementHead = this.#elementArea.getElementHeadOrNull(x, y);
                if (elementHead == null) {
                    return;
                }
    
                if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_FIRE) {
                    // affect fire
                    const otherTemperature = ElementHead.getTemperature(elementHead);
                    if (otherTemperature < temperature) {
                        const newTemperature = Math.trunc((temperature - otherTemperature) / 2);
                        if (newTemperature > ProcessorModuleFire.#FIRE_MIN_TEMPERATURE) {
                            this.#elementArea.setElementHead(x, y, ProcessorModuleFire.createFireElementHead(newTemperature));
                            this.#elementArea.setElementTail(x, y, ProcessorModuleFire.createFireElementTail(newTemperature));
                        }
                    }
                    return;
                }
    
                // for air elements...
                if (ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_AIR) {
                    // spreading
                    const newTemperature = Math.trunc(temperature * 0.7);
                    if (newTemperature > ProcessorModuleFire.#FIRE_MIN_TEMPERATURE) {
                        this.#elementArea.setElementHead(x, y, ProcessorModuleFire.createFireElementHead(newTemperature));
                        this.#elementArea.setElementTail(x, y, ProcessorModuleFire.createFireElementTail(newTemperature));
                    }
                    return;
                }
    
                // for flammable elements...
                const heatModIndex = ElementHead.getHeatModIndex(elementHead);
                const flammableChance = ElementHead.hmiToFlammableChanceTo10000(heatModIndex);
                if (flammableChance !== 0) {
                    if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_FIRE_SOURCE) {
                        // already in fire
                        return;
                    }
                    if (this.#random.nextInt(10000) < flammableChance) {
                        // ignite
                        this.ignite(elementHead, x, y);
                        return;
                    }
                }
    
                // increase temperature
                if (this.#random.nextInt(5) === 0) {
                    const currentTemperature = ElementHead.getTemperature(elementHead);
                    if (currentTemperature < temperature) {
                        const modifiedElementHead = ElementHead.setTemperature(elementHead, temperature);
                        this.#elementArea.setElementHead(x, y, modifiedElementHead);
                    }
                }
    
                // visual change
                if (VisualEffects.isVisualBurnApplicable(elementHead)) {
                    if (this.#random.nextInt(10) === 0) {
                        const elementTail = this.#elementArea.getElementTail(x, y);
                        this.#elementArea.setElementTail(x, y, VisualEffects.visualBurn(elementTail, 1, 2));
                    }
                }
            }
    
            // FIRE SOURCE
    
            behaviourFireSource(elementHead, x, y) {
                const heatModIndex = ElementHead.getHeatModIndex(elementHead);
                const flameHeat = ElementHead.hmiToFlameHeat(heatModIndex);
                const burnDownChange = ElementHead.hmiToBurnDownChanceTo10000(heatModIndex);
    
                if (this.#random.nextInt(10000) < burnDownChange) {
                    // burned down
                    if (this.#random.nextInt(100) < 8) {
                        // turn into ash
                        const oldTemperature = ElementHead.getTemperature(elementHead);
                        const ashElement = this.#processorContext.getDefaults().getBrushAsh().apply(x, y, this.#random);
                        const modifiedAshElementHead = ElementHead.setTemperature(ashElement.elementHead, oldTemperature);
                        const modifiedAshElementTail = ashElement.elementTail;
                        this.#elementArea.setElementHeadAndTail(x, y, modifiedAshElementHead, modifiedAshElementTail);
                    } else {
                        // turn into fire element
                        this.#elementArea.setElementHead(x, y, ProcessorModuleFire.createFireElementHead(flameHeat));
                        this.#elementArea.setElementTail(x, y, ProcessorModuleFire.createFireElementTail(flameHeat));
                    }
                    return;
                }
    
                // affect others
                const flags = this.#fireSourceEffect(x, y - 1, flameHeat)
                        | this.#fireSourceEffect(x, y + 1, flameHeat)
                        | this.#fireSourceEffect(x - 1, y, flameHeat)
                        | this.#fireSourceEffect(x + 1, y, flameHeat);
    
                if (flags === 0b00 || (flags & 0b10) !== 0) {  // no air || some water
                    // extinguish
                    this.#elementArea.setElementHead(x, y, ElementHead.setBehaviour(elementHead, ElementHead.BEHAVIOUR_NONE));
                    return;
                }
    
                if (ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_STATIC) {
                    // occasionally a falling piece...
                    if (this.#random.nextInt(10000) < 2) {
                        const type = ElementHead.type8Powder(ElementHead.TYPE_POWDER, 5, 1, this.#random.nextInt(2));
                        this.#elementArea.setElementHead(x, y, ElementHead.setType(elementHead, type));
                        return;
                    }
                }
    
                // update temperature
                this.#elementArea.setElementHead(x, y, ElementHead.setTemperature(elementHead, flameHeat));
            }
    
            #fireSourceEffect(x, y, temperature) {
                const elementHead = this.#elementArea.getElementHeadOrNull(x, y);
                if (elementHead === null) {
                    return 0b00;
                }
    
                // water => extinguish
                if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_WATER) {
                    return 0b10;
                }
    
                // air => spawn fire
                if (ElementHead.getTypeClass(elementHead) <= ElementHead.TYPE_EFFECT) {
                    // air found
                    const actualTemperature = this.#random.nextInt(temperature);
                    if (actualTemperature >= ProcessorModuleFire.#FIRE_MIN_TEMPERATURE) {
                        this.#elementArea.setElementHead(x, y, ProcessorModuleFire.createFireElementHead(actualTemperature));
                        this.#elementArea.setElementTail(x, y, ProcessorModuleFire.createFireElementTail(actualTemperature));
                    }
                    return 0b01;
                }
    
                // visual change
                if (VisualEffects.isVisualBurnApplicable(elementHead)) {
                    if (this.#random.nextInt(1000) === 0) {
                        const elementTail = this.#elementArea.getElementTail(x, y);
                        this.#elementArea.setElementTail(x, y, VisualEffects.visualBurn(elementTail, 1, 2));
                    }
                }
    
                return 0b00;
            }
    
            // UTILS
    
            ignite(elementHead, x, y, heatModIndex) {
                let modifiedElementHead = ElementHead.setBehaviour(elementHead, ElementHead.BEHAVIOUR_FIRE_SOURCE);
                modifiedElementHead = ElementHead.setTemperature(modifiedElementHead, ElementHead.hmiToFlameHeat(heatModIndex));
                this.#elementArea.setElementHead(x, y, modifiedElementHead);
                // change visual
                const elementTail = this.#elementArea.getElementTail(x, y);
                this.#elementArea.setElementTail(x, y, VisualEffects.visualBurn(elementTail, 2));
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-07-23
         */
        class CircleIterator {
    
            // This may look ugly but it's all I need
    
            // BLUEPRINT_3 and BLUEPRINT_4 are not needed, but they are used frequently
    
            static BLUEPRINT_3 = [
                '  333',
                ' 32223',
                '3211123',
                '3210123',
                '3211123',
                ' 32223',
                '  333',
            ];
    
            static BLUEPRINT_4 = [
                '   444   ',
                '  43334',
                ' 4322234',
                '432111234',
                '432101234',
                '432111234',
                ' 4322234',
                '  43334',
                '   444'
            ];
    
            static BLUEPRINT_9 = [
                '       99999       ',
                '     998888899',
                '   9988777778899',
                '  998776666677899',
                '  987665555566789',
                ' 98766554445566789',
                ' 98765543334556789',
                '9876554322234556789',
                '9876543211123456789',
                '9876543210123456789',
                '9876543211123456789',
                '9876554322234556789',
                ' 98765543334556789',
                ' 98766554445566789',
                '  987665555566789',
                '  998776666677899',
                '   9988777778899',
                '     998888899',
                '       99999'
            ];
    
            /**
             *
             * @param blueprint {string[]}
             * @param handler {function(dx: number, dy: number, level: number)}
             */
            static iterate(blueprint, handler) {
                const w = blueprint[0].length;
                const h = blueprint.length;
                const offsetX = Math.trunc(w / 2);
                const offsetY = Math.trunc(h / 2);
    
                for (let i = 0; i < blueprint.length; i++) {
                    const row = blueprint[i];
                    for (let j = 0; j < row.length; j++) {
                        const char = row.charAt(j);
                        if (char !== ' ') {
                            handler(j - offsetX, i - offsetY, +char);
                        }
                    }
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-05
         */
        class ProcessorModuleMeteor {
    
            // TODO: leave some metal behind...
            // TODO: when water hit?
    
            static DIRECTION_FROM_TOP = 0;
            static DIRECTION_FROM_LEFT = 1;
            static DIRECTION_FROM_RIGHT = 2;
    
            static #HEAT = 100;
    
            static #EXPLOSION_MAX_HEAT_LVL_8 = 255;
            static #EXPLOSION_MAX_HEAT_LVL_9 = 220;
            static #EXPLOSION_MAX_HEAT_VARIANCE = 60;
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type ProcessorContext */
            #processorContext;
    
            constructor(elementArea, random, processorContext) {
                this.#elementArea = elementArea;
                this.#random = random;
                this.#processorContext = processorContext;
            }
    
            behaviourMeteor(elementHead, x, y) {
                this.#spawnFire(elementHead, x, y);
    
                const special = ElementHead.getSpecial(elementHead);
                const move = special & 0x1;
                let newSpecial = special ^ (!move);
                elementHead = ElementHead.setSpecial(elementHead, newSpecial);
                this.#elementArea.setElementHead(x, y, elementHead);
                if (!move) {
                    return;  // move only once per simulation iteration
                }
    
                // resolve direction
                const slope = 4;
                const direction = (special & (~0x1)) >> 1;
                let tx, ty;
                if (direction === ProcessorModuleMeteor.DIRECTION_FROM_TOP) {
                    ty = y + 1;
                    tx = x;
                } else if (direction === ProcessorModuleMeteor.DIRECTION_FROM_LEFT) {
                    ty = y + 1;
                    tx = x + (ty % slope === 0 ? 1 : 0);
                } else if (direction === ProcessorModuleMeteor.DIRECTION_FROM_RIGHT) {
                    ty = y + 1;
                    tx = x - (ty % slope === 0 ? 1 : 0);
                } else {
                    // unknown direction
                    ty = y + 1;
                    tx = x;
                }
    
                if (this.#elementArea.isValidPosition(tx, ty)) {
                    if (this.#processorContext.isFallThroughEnabled() && ty === this.#elementArea.getHeight() - 1) {
                        // handle meteor in fallthrough mode
                        if (this.#canMove(tx, 0)) {
                            // teleport
                            this.#elementArea.swap(x, y, tx, 0);
                            this.#processorContext.trigger(tx, 0);
                        }
                    } else if (this.#canMove(tx, ty)) {
                        // move
                        this.#elementArea.swap(x, y, tx, ty);
                    } else {
                       this.#explode(elementHead, x, y);
                    }
                } else {
                    this.#explode(elementHead, x, y);
                }
            }
    
            #canMove(x, y) {
                const targetElementHead = this.#elementArea.getElementHead(x, y);
                const typeClass = ElementHead.getTypeClass(targetElementHead);
                if (typeClass <= ElementHead.TYPE_GAS || typeClass === ElementHead.TYPE_FLUID) {
                    return true;
                }
                const behaviour = ElementHead.getBehaviour(targetElementHead);
                if (behaviour === ElementHead.BEHAVIOUR_TREE_LEAF) {
                    return true;
                }
                if (behaviour === ElementHead.BEHAVIOUR_GRASS) {
                    return true;
                }
                return false;
            }
    
            #spawnFire(elementHead, x, y) {
                CircleIterator.iterate(CircleIterator.BLUEPRINT_4, (dx, dy, level) => {
                    if (level === 0) {
                        return;  // ignore center
                    }
    
                    const tx = x + dx;
                    const ty = y + dy;
                    if (this.#elementArea.isValidPosition(tx, ty)) {
                        let targetElementHead = this.#elementArea.getElementHead(tx, ty);
                        if (ElementHead.getTypeClass(targetElementHead) <= ElementHead.TYPE_GAS) {
                            const brush = this.#processorContext.getDefaults().getBrushFire();
                            this.#elementArea.setElement(tx, ty, brush.apply(tx, ty, this.#random));
                        } else {
                            const modifiedElementHead = ElementHead.setTemperature(targetElementHead, ProcessorModuleMeteor.#HEAT);
                            this.#elementArea.setElementHead(tx, ty, modifiedElementHead);
                        }
                    }
                });
            }
    
            #explode(elementHead, x, y) {
                CircleIterator.iterate(CircleIterator.BLUEPRINT_9, (dx, dy, level) => {
                    const tx = x + dx;
                    const ty = y + dy;
                    if (this.#elementArea.isValidPosition(tx, ty)) {
                        let targetElementHead = this.#elementArea.getElementHead(tx, ty);
                        if (level !== 0 && ElementHead.getBehaviour(targetElementHead) === ElementHead.BEHAVIOUR_METEOR) {
                            // do not destroy other meteors
                            return;
                        }
    
                        if (level <= 7) {
                            // destroy elements & spawn fire
                            const brush = this.#processorContext.getDefaults().getBrushFire();
                            this.#elementArea.setElement(tx, ty, brush.apply(tx, ty, this.#random));
                        } else {
                            // set temperature, apply visual changes, break solid elements
    
                            // set temperature
                            const maxHeat = (level === 8)
                                    ? ProcessorModuleMeteor.#EXPLOSION_MAX_HEAT_LVL_8
                                    : ProcessorModuleMeteor.#EXPLOSION_MAX_HEAT_LVL_9;
                            const heat = maxHeat - this.#random.nextInt(ProcessorModuleMeteor.#EXPLOSION_MAX_HEAT_VARIANCE);
                            targetElementHead = ElementHead.setTemperature(targetElementHead, heat);
    
                            // visual burnt effect (color)
                            if (VisualEffects.isVisualBurnApplicable(targetElementHead)) {
                                let targetElementTail = this.#elementArea.getElementTail(tx, ty);
                                if (level === 8) {
                                    targetElementTail = VisualEffects.visualBurn(targetElementTail, 2);
                                } else {
                                    targetElementTail = VisualEffects.visualBurn(targetElementTail, 1);
                                }
                                this.#elementArea.setElementTail(tx, ty, targetElementTail);
                            }
    
                            // turn some solid elements into fragments
                            if (ElementHead.getTypeClass(targetElementHead) === ElementHead.TYPE_STATIC) {
                                if (level === 8 || (level === 9 && this.#random.nextInt(10) < 3)) {
                                    const type = ElementHead.type8Powder(ElementHead.TYPE_POWDER, 5);
                                    targetElementHead = ElementHead.setType(targetElementHead, type);
                                }
                            }
    
                            this.#elementArea.setElementHead(tx, ty, targetElementHead);
                        }
                    }
                });
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-08
         */
        class ProcessorModuleGrass {
    
            static #MAX_TEMPERATURE = 20;
    
            static canGrowUpHere(elementArea, x, y) {
                if (x < 0 || y - 1 < 0) {
                    return false;
                }
                if (x >= elementArea.getWidth() || y + 1 >= elementArea.getHeight()) {
                    return false;
                }
                let e1 = elementArea.getElementHead(x, y);
                if (ElementHead.getTypeClass(e1) !== ElementHead.TYPE_AIR) {
                    return false;
                }
                if (ElementHead.getTemperature(e1) >= this.#MAX_TEMPERATURE) {
                    return false;
                }
                let e2 = elementArea.getElementHead(x, y + 1);
                if (ElementHead.getBehaviour(e2) !== ElementHead.BEHAVIOUR_SOIL) {
                    return false;
                }
                if (ElementHead.getTemperature(e2) >= this.#MAX_TEMPERATURE) {
                    return false;
                }
                let e3 = elementArea.getElementHead(x, y - 1);
                if (ElementHead.getTypeClass(e3) !== ElementHead.TYPE_AIR) {
                    return false;
                }
                return true;
            }
    
            static spawnHere(elementArea, x, y, brush, random) {
                let element = brush.apply(x, y, random);
                let offset = 0;
                for (let i = ElementHead.getSpecial(element.elementHead); i >= 0; i--) {
                    if (y - offset < 0) {
                        break;
                    }
                    elementArea.setElementHead(x, y - offset, ElementHead.setSpecial(element.elementHead, i));
                    elementArea.setElementTail(x, y - offset, element.elementTail);
                    offset++;
                }
            }
    
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type ProcessorContext */
            #processorContext;
    
            constructor(elementArea, random, processorContext) {
                this.#elementArea = elementArea;
                this.#random = random;
                this.#processorContext = processorContext;
            }
    
            behaviourGrass(elementHead, x, y) {
                // check temperature
                if (ElementHead.getTemperature(elementHead) > ProcessorModuleGrass.#MAX_TEMPERATURE) {
                    this.#elementArea.setElementHead(x, y, ElementHead.setBehaviour(elementHead, 0));
                    const elementTail = this.#elementArea.getElementTail(x, y);
                    const visualEffectForce = this.#random.nextInt(2) + 1;
                    this.#elementArea.setElementTail(x, y, VisualEffects.visualBurn(elementTail, visualEffectForce));
                }
    
                let random = this.#random.nextInt(100);
                if (random < 3) {
                    // check above
                    if (y > 0) {
                        let above1 = this.#elementArea.getElementHead(x, y - 1);
                        if (ElementHead.getBehaviour(above1) !== ElementHead.BEHAVIOUR_GRASS) {
                            let typeAbove1 = ElementHead.getTypeClass(above1);
                            if (typeAbove1 > ElementHead.TYPE_FLUID
                                    || (typeAbove1 === ElementHead.TYPE_FLUID && this.#random.nextInt(100) === 0)) {
                                // note: it takes longer for water to suffocate the grass
                                // remove grass
                                this.#elementArea.setElement(x, y, this.#processorContext.getDefaults().getDefaultElement());
                                return;
                            }
                        }
                    }
    
                    if (random === 0) {
                        // grow up
                        let growIndex = ElementHead.getSpecial(elementHead);
                        if (growIndex === 0) {
                            // maximum height
                            if (this.#random.nextInt(5) === 0) {
                                // remove top element to create some movement
                                this.#elementArea.setElement(x, y, this.#processorContext.getDefaults().getDefaultElement());
                            }
                            return;
                        }
                        if (y === 0) {
                            return;
                        }
                        let above1 = this.#elementArea.getElementHead(x, y - 1);
                        if (ElementHead.getTypeClass(above1) !== ElementHead.TYPE_AIR) {
                            return;
                        }
                        if (y > 1) {
                            let above2 = this.#elementArea.getElementHead(x, y - 2);
                            if (ElementHead.getTypeClass(above2) !== ElementHead.TYPE_AIR) {
                                return;
                            }
                        }
                        this.#elementArea.setElementHead(x, y - 1, ElementHead.setSpecial(elementHead, growIndex - 1));
                        this.#elementArea.setElementTail(x, y - 1, this.#elementArea.getElementTail(x, y));
                    } else if (random === 1) {
                        // grow right
                        if (ProcessorModuleGrass.canGrowUpHere(this.#elementArea, x + 1, y + 1)) {
                            const brush = this.#processorContext.getDefaults().getBrushGrass();
                            this.#elementArea.setElement(x + 1, y + 1, brush.apply(x, y, this.#random));
                        }
                    } else if (random === 2) {
                        // grow left
                        if (ProcessorModuleGrass.canGrowUpHere(this.#elementArea, x - 1, y + 1)) {
                            const brush = this.#processorContext.getDefaults().getBrushGrass();
                            this.#elementArea.setElement(x - 1, y + 1, brush.apply(x, y, this.#random));
                        }
                    }
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-12
         */
        class ProcessorModuleTree {
    
            static TYPE_TRUNK = 1;
            static TYPE_BRANCH = 2;
            static TYPE_LEAF = 3;
            static TYPE_ROOT = 4;
    
            static #MAX_TREE_TEMPERATURE = 100;
            static #MAX_WOOD_TEMPERATURE = 50;
            static #MAX_LEAF_TEMPERATURE = 40;
    
            static #NOISE = VisualEffects.visualNoiseProvider(7616891641);
    
            static #LEAF_NOISE = (elementTail, x, y) => {
                return ProcessorModuleTree.#NOISE.visualNoise(elementTail, x, y, 10, 0.5, 1, 68, 77, 40);
            };
    
            static #TRUNK_NOISE = (elementTail, x, y) => {
                return ProcessorModuleTree.#NOISE.visualNoise(elementTail, x, y, 4, 0.5, 0.9, 87, 61, 39);
            };
    
            static spawnHere(elementArea, x, y, type, brush, random, processorContext, levelsToGrow = -1) {
                type = type % (1 << ElementHead.FIELD_SPECIAL_SIZE);
    
                const element = brush.apply(x, y, random);
                element.elementHead = ElementHead.setSpecial(element.elementHead, type);  // override tree type
                elementArea.setElement(x, y, element);
    
                // tree fast grow
                const template = processorContext.getDefaults().getTreeTrunkTemplates()[type];
                if (template === undefined) {
                    throw 'Tree template not found: ' + type;
                }
                const treeModule = new ProcessorModuleTree(elementArea, random, processorContext);
                treeModule.#treeGrow(element.elementHead, x, y, template, levelsToGrow);
    
                // roots fast grow
                for (let i = 1; i < 10; i++) {
                    for (let j = 0; j < 9; j++) {
                        const tx = x + j - 4;
                        const ty = y + i;
    
                        if (!elementArea.isValidPosition(tx, ty)) {
                            continue;
                        }
                        const targetElement = elementArea.getElementHead(tx, ty);
                        if (ElementHead.getBehaviour(targetElement) !== ElementHead.BEHAVIOUR_TREE_ROOT) {
                            continue;
                        }
                        const growIndex = ElementHead.getSpecial(targetElement);
                        if (growIndex === 0) {
                            continue;
                        }
    
                        const direction = random.nextInt(10);
                        treeModule.#treeRootGrow(tx, ty, targetElement, growIndex, direction);
                    }
                }
            }
    
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type ProcessorContext */
            #processorContext;
    
            #trunkTreeTemplates;
            #leafClusterTemplates;
    
            constructor(elementArea, random, processorContext) {
                this.#elementArea = elementArea;
                this.#random = random;
                this.#processorContext = processorContext;
    
                this.#trunkTreeTemplates = this.#processorContext.getDefaults().getTreeTrunkTemplates();
                this.#leafClusterTemplates = this.#processorContext.getDefaults().getTreeLeafClusterTemplates();
            }
    
            behaviourTree(elementHead, x, y) {
                // check temperature
                if (ElementHead.getTemperature(elementHead) > ProcessorModuleTree.#MAX_TREE_TEMPERATURE) {
                    // => destroy tree instantly
                    this.#elementArea.setElementHead(x, y, ElementHead.setBehaviour(elementHead, 0));
                    return;
                }
    
                const random = this.#random.nextInt(ProcessorContext.OPT_CYCLES_PER_SECOND);
                if (random === 0) {
                    // check status
                    const trunkTemplateId = ElementHead.getSpecial(elementHead);
                    const template = this.#trunkTreeTemplates[trunkTemplateId];
                    if (template === undefined) {
                        throw 'Tree template not found: ' + trunkTemplateId;
                    }
                    const level = this.#treeGrow(elementHead, x, y, template, 1);
                    this.#treeCheckStatus(x, y, level, template);
                }
            }
    
            #treeGrow(elementHead, x, y, template, levelsToGrow = 1) {
                let leafClusterIdRndSalt = this.#treeCreateOrGetSeed(x, y - 2);
    
                let level = 0;
                let levelGrown = 0;
    
                let parallelBranches = [{
                    entries: template.entries,
                    index: 0,
                    x: 0,
                    y: 0,
                    brush: null
                }];
    
                let grow = (nx, ny, brush, noise, increment) => {
                    let element = brush.apply(nx, ny, this.#random);
                    if (noise === null) {
                        this.#elementArea.setElement(nx, ny, element);
                    } else {
                        const tx = (x - nx) + (10 * x);  // unique pattern for each tree
                        const ty = (y - ny) + (10 * y);
                        const modifiedTail = noise(element.elementTail, tx, ty);
                        this.#elementArea.setElementHeadAndTail(nx, ny, element.elementHead, modifiedTail);
                    }
                    this.#processorContext.trigger(nx, ny);
                    this.#processorContext.triggerSolidCreated(element.elementHead, nx, ny);
                    if (increment) {
                        level++;
                        levelGrown++;
                    }
                };
    
                while (parallelBranches.length > 0) {
                    const length = parallelBranches.length;
                    let cleanupBranches = false;
    
                    for (let i = 0; i < length; i++) {
                        const branch = parallelBranches[i];
    
                        if (branch.index >= branch.entries.length) {
                            // end of branch
                            cleanupBranches = true;
                            continue;
                        }
    
                        const node = branch.entries[branch.index++];
                        const [templateX, templateY, nodeType] = node;
                        const nx = x + templateX + branch.x;
                        const ny = y - templateY - branch.y;
    
                        if (this.#elementArea.isValidPosition(nx, ny)) {
                            const currentElementHead = this.#elementArea.getElementHead(nx, ny);
                            const currentElementBehaviour = ElementHead.getBehaviour(currentElementHead);
    
                            switch (nodeType) {
                                case ProcessorModuleTree.TYPE_LEAF:
                                    if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_LEAF) {
                                        // is already here
                                        // update leaf vitality (if not dead already)
                                        if (ElementHead.getSpecial(currentElementHead) < 15) {
                                            this.#elementArea.setElementHead(nx, ny, ElementHead.setSpecial(currentElementHead, 0));
                                        }
                                    } else if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_TRUNK) {
                                        // replace trunk
                                        grow(nx, ny, branch.brush, ProcessorModuleTree.#LEAF_NOISE, false);
                                    } else if (ElementHead.getTypeClass(currentElementHead) === ElementHead.TYPE_AIR) {
                                        grow(nx, ny, branch.brush, ProcessorModuleTree.#LEAF_NOISE, false);
                                    }
                                    break;
    
                                case ProcessorModuleTree.TYPE_TRUNK:
                                    if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_TRUNK) {
                                        level++;  // trunk is already here
                                    } else if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_LEAF) {
                                        level++;  // leaf is already here
                                    }
                                    let trunkGrow = false;
                                    if (ElementHead.getTypeClass(currentElementHead) === ElementHead.TYPE_AIR) {
                                        trunkGrow = true;
                                    } else if (currentElementBehaviour === ElementHead.BEHAVIOUR_SOIL) {
                                        trunkGrow = true;
                                    } else if (currentElementBehaviour === ElementHead.BEHAVIOUR_GRASS) {
                                        trunkGrow = true;
                                    } else if (templateY < 5) {
                                        // bottom trunk only...
                                        if (ElementHead.getTypeClass(currentElementHead) !== ElementHead.TYPE_STATIC) {
                                            trunkGrow = true;
                                        }
                                    }
                                    if (trunkGrow) {
                                        const treeBrush = (templateY > 0)
                                            ? this.#processorContext.getDefaults().getBrushTreeWood()
                                            : this.#processorContext.getDefaults().getBrushTreeWoodDark();
                                        grow(nx, ny, treeBrush, ProcessorModuleTree.#TRUNK_NOISE, true);
                                        if (templateY === 2 && templateX === 0) {
                                            // set seed
                                            this.#treeSetSeed(nx, ny, leafClusterIdRndSalt);
                                        }
                                    }
                                    break;
    
                                case ProcessorModuleTree.TYPE_BRANCH:
                                    let branchGrow = false;
                                    if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_LEAF) {
                                        level++;  // is already here
                                        // update leaf vitality (if not dead already)
                                        if (ElementHead.getSpecial(currentElementHead) < 15) {
                                            this.#elementArea.setElementHead(nx, ny, ElementHead.setSpecial(currentElementHead, 0));
                                        }
                                    } else if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_TRUNK) {
                                        level++;  // is already here
                                    } else if (ElementHead.getTypeClass(currentElementHead) === ElementHead.TYPE_AIR) {
                                        branchGrow = true;
                                    } else {
                                        break;  // an obstacle...
                                    }
    
                                    let rnd = DeterministicRandom.next(leafClusterIdRndSalt + templateX + templateY);
                                    let leafClusterId = Math.trunc(rnd * this.#leafClusterTemplates.length);
                                    let leafCluster = this.#leafClusterTemplates[leafClusterId];
                                    let leafBrush = (Math.trunc(rnd * 1024) % 2 === 0)
                                            ? this.#processorContext.getDefaults().getBrushTreeLeaf()
                                            : this.#processorContext.getDefaults().getBrushTreeLeafDark();
                                    parallelBranches.push({
                                        entries: leafCluster.entries,
                                        index: 0,
                                        x: templateX,
                                        y: templateY,
                                        brush: leafBrush
                                    });
                                    if (branchGrow) {
                                        grow(nx, ny, leafBrush, ProcessorModuleTree.#LEAF_NOISE, true);
                                    }
                                    break;
    
                                case ProcessorModuleTree.TYPE_ROOT:
                                    if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_ROOT) {
                                        level++;  // is already here
                                    } else {
                                        grow(nx, ny, this.#processorContext.getDefaults().getBrushTreeRoot(), null, true);
                                    }
                                    break;
    
                                default:
                                    throw 'Unknown type: ' + nodeType;
                            }
                        }
    
                        let newParallelEntries = (node.length > 3) ? node[3] : undefined;
                        if (newParallelEntries !== undefined) {
                            parallelBranches.push({
                                entries: newParallelEntries,
                                index: 0,
                                x: branch.x,
                                y: branch.y,
                                brush: branch.brush
                            });
                        }
                    }
    
                    if (levelsToGrow !== -1 && levelGrown >= levelsToGrow) {
                        break;  // terminate
                    }
    
                    if (cleanupBranches) {
                        for (let i = parallelBranches.length - 1; i >= 0; i--) {
                            let branch = parallelBranches[i];
                            if (branch.index >= branch.entries.length) {
                                parallelBranches.splice(i, 1);
                            }
                        }
                    }
                }
                return level;
            }
    
            #treeCreateOrGetSeed(x, y) {
                if (this.#elementArea.isValidPosition(x, y)) {
                    let elementHead = this.#elementArea.getElementHead(x, y);
                    if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_TREE_TRUNK) {
                        return ElementHead.getSpecial(elementHead);
                    }
                }
                return this.#random.nextInt(1 << ElementHead.FIELD_SPECIAL_SIZE);
            }
    
            #treeSetSeed(x, y, seed) {
                // assume point exists
                // assume tree trunk
                let elementHead = this.#elementArea.getElementHead(x, y);
                elementHead = ElementHead.setSpecial(elementHead, seed);
                this.#elementArea.setElementHead(x, y, elementHead);
            }
    
            #treeCheckStatus(x, y, level, template) {
                // check tree status
                // - last tree status is carried by tree trunk above
                if (y > 0) {
                    let carrierElementHead = this.#elementArea.getElementHead(x, y - 1);
                    if (ElementHead.getBehaviour(carrierElementHead) === ElementHead.BEHAVIOUR_TREE_TRUNK) {
                        const maxStage = 15;
                        let lastStage = ElementHead.getSpecial(carrierElementHead);
                        let currentStage = Math.trunc(level / template.entriesCount * maxStage);
                        if (lastStage - currentStage > 5) {
                            // too big damage taken => kill tree
                            this.#elementArea.setElementHead(x, y - 1, ElementHead.setSpecial(carrierElementHead, 0));
                            const treeWoodBrush = this.#processorContext.getDefaults().getBrushTreeWoodDark();
                            this.#elementArea.setElement(x, y, treeWoodBrush.apply(x, y, this.#random));
                        } else {
                            // update stage
                            this.#elementArea.setElementHead(x, y - 1, ElementHead.setSpecial(carrierElementHead, currentStage));
                        }
                    }
                }
            }
    
            behaviourTreeRoot(elementHead, x, y) {
                // check temperature
                if (ElementHead.getTemperature(elementHead) > ProcessorModuleTree.#MAX_TREE_TEMPERATURE) {
                    // => destroy instantly
                    this.#elementArea.setElementHead(x, y, ElementHead.setBehaviour(elementHead, 0));
                    return;
                }
    
                let growIndex = ElementHead.getSpecial(elementHead);
                if (growIndex === 0) {
                    // maximum size
                    if (this.#processorContext.getIteration() % 1000 === 0) {
                        this.#treeRootHardenSurroundingElements(x, y);
                    }
                    return;
                }
    
                let random = this.#random.nextInt(ProcessorContext.OPT_CYCLES_PER_SECOND * 10);
                if (random < 10) {
                    this.#treeRootGrow(x, y, elementHead, growIndex, random);
                }
            }
    
            #treeRootHardenSurroundingElements(x, y) {
                const targetX = x + this.#random.nextInt(3) - 1;
                const targetY = y + this.#random.nextInt(3) - 1;
    
                if (this.#elementArea.isValidPosition(targetX, targetY)) {
                    let targetElementHead = this.#elementArea.getElementHead(targetX, targetY);
                    let type = ElementHead.getTypeClass(targetElementHead);
                    if (type === ElementHead.TYPE_POWDER || type === ElementHead.TYPE_POWDER_WET || type === ElementHead.TYPE_POWDER_FLOATING) {
                        let newType = ElementHead.type8(ElementHead.type8Solid(ElementHead.TYPE_STATIC, 3));
                        let modifiedElementHead = ElementHead.setType(targetElementHead, newType);
                        this.#elementArea.setElementHead(targetX, targetY, modifiedElementHead);
                    }
                }
            }
    
            #treeRootGrow(x, y, elementHead, growIndex, direction) {
                let doGrow = (nx, ny) => {
                    this.#elementArea.setElementHead(x, y, ElementHead.setSpecial(elementHead, 0));
    
                    let element = this.#processorContext.getDefaults().getBrushTreeRoot().apply(nx, ny, this.#random);
                    let modifiedHead = ElementHead.setSpecial(element.elementHead, growIndex - 1);
                    this.#elementArea.setElementHead(nx, ny, modifiedHead);
                    this.#elementArea.setElementTail(nx, ny, element.elementTail);
                };
    
                // grow down first if there is a free space
                if (y < this.#elementArea.getHeight() - 1) {
                    let targetElementHead = this.#elementArea.getElementHead(x, y + 1);
                    if (ElementHead.getTypeClass(targetElementHead) === ElementHead.TYPE_AIR) {
                        doGrow(x, y + 1);
                        return;
                    }
                }
    
                // grow in random way
                let nx = x;
                let ny = y;
                if (direction === 9 || direction === 8 || direction === 7) {
                    nx += 1;
                    ny += 1;
                } else if (direction === 6 || direction === 5 || direction === 4) {
                    nx += -1;
                    ny += 1;
                } else {
                    ny += 1;
                }
    
                if (this.#elementArea.isValidPosition(nx, ny)) {
                    let targetElementHead = this.#elementArea.getElementHead(nx, ny);
                    if (ElementHead.getTypeClass(targetElementHead) !== ElementHead.TYPE_STATIC) {
                        doGrow(nx, ny);
                    }
                }
            }
    
            behaviourTreeLeaf(elementHead, x, y) {
                let vitality = ElementHead.getSpecial(elementHead);
                if (vitality < 15) {
                    // check temperature
                    const temperature = ElementHead.getTemperature(elementHead);
                    if (temperature > ProcessorModuleTree.#MAX_LEAF_TEMPERATURE) {
                        // => destroy instantly, keep temperature
                        this.#dryLeaf(elementHead, x, y);
                        return;
                    }
    
                    // decrement vitality (if not dead already)
                    if (this.#processorContext.getIteration() % 32 === 0) {
                        if (this.#random.nextInt(10) === 0) {
                            vitality++;
                            if (vitality >= 15) {
                                this.#dryLeaf(elementHead, x, y);
                                return;
                            } else {
                                elementHead = ElementHead.setSpecial(elementHead, vitality);
                                this.#elementArea.setElementHead(x, y, elementHead);
                            }
                        }
                    }
                }
    
                // once a while "transport" element from above/left/right/left-above/right-above if possible
                if (this.#processorContext.getIteration() % 4 === 0 && this.#random.nextInt(10) === 0) {
    
                    const directions = [[0, -1], [0, -1], [-1, 0], [1, 0], [-1, -1], [1, -1]];
                    const randomDirection = directions[this.#random.nextInt(directions.length)];
                    const sourceX = x + randomDirection[0];
                    const sourceY = y + randomDirection[1];
    
                    const sourceElementHead = this.#elementArea.getElementHeadOrNull(sourceX, sourceY);
                    if (sourceElementHead !== null
                            && ElementHead.getTypeClass(sourceElementHead) >= ElementHead.TYPE_FLUID
                            && ElementHead.getTypeClass(sourceElementHead) < ElementHead.TYPE_STATIC) {
    
                        let destX = x;
                        let destY = y;
                        for (let step = 0; step < 25; step++) {
                            destX += this.#random.nextInt(3) - 1;  // random walk
                            destY += 1;
    
                            const destElementHead = this.#elementArea.getElementHeadOrNull(destX, destY);
                            if (destElementHead === null) {
                                break;
                            }
                            const destBehaviour = ElementHead.getBehaviour(destElementHead);
                            if (destBehaviour === ElementHead.BEHAVIOUR_TREE_LEAF) {
                                continue;
                            }
                            const destTypeClass = ElementHead.getTypeClass(destElementHead);
                            if (destTypeClass <= ElementHead.TYPE_GAS) {
                                this.#elementArea.swap(sourceX, sourceY, destX, destY);
                                return;
                            }
                            break;
                        }
    
                        // destroy buried leaf
                        if (this.#random.nextInt(20) === 0) {
                            this.#elementArea.setElement(x, y, this.#processorContext.getDefaults().getDefaultElement());
                        }
                    }
                }
            }
    
            #dryLeaf(elementHead, x, y) {
                const elementTail = this.#elementArea.getElementTail(x, y);
    
                // multiplication and alpha blending (for lighter color)
                const alpha = 0.85;
                const whiteBackground = 255 * (1.0 - alpha);
                let newElementTail = ElementTail.setColor(
                    Math.trunc(ElementTail.getColorRed(elementTail) * 1.4 * alpha + whiteBackground) & 0xFF,
                    Math.trunc(ElementTail.getColorGreen(elementTail) * 0.9 * alpha + whiteBackground) & 0xFF,
                    Math.trunc(ElementTail.getColorBlue(elementTail) * 0.8 * alpha + whiteBackground) & 0xFF
                );
    
                const newElementHead = ElementHead.setSpecial(elementHead, 15);
                this.#elementArea.setElementHeadAndTail(x, y, newElementHead, newElementTail);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-20
         */
        class ProcessorModuleWater {
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type ProcessorContext */
            #processorContext;
    
            constructor(elementArea, random, processorContext) {
                this.#elementArea = elementArea;
                this.#random = random;
                this.#processorContext = processorContext;
            }
    
            behaviourWater(elementHead, x, y) {
                const typeClass = ElementHead.getTypeClass(elementHead);
                const temperature = ElementHead.getTemperature(elementHead);
    
                if (typeClass === ElementHead.TYPE_FLUID) {
                    if (temperature > 20) {
                        const brush = this.#processorContext.getDefaults().getBrushSteam();
                        const element = brush.apply(x, y, this.#random);
                        const newElementHead = ElementHead.setTemperature(element.elementHead, temperature);
                        this.#elementArea.setElementHeadAndTail(x, y, newElementHead, element.elementTail);
                        return true;
                    }
    
                } else if (typeClass === ElementHead.TYPE_GAS) {
                    if (temperature < 10) {
                        const brush = this.#processorContext.getDefaults().getBrushWater();
                        const element = brush.apply(x, y, this.#random);
                        const newElementHead = ElementHead.setTemperature(element.elementHead, temperature);
                        this.#elementArea.setElementHeadAndTail(x, y, newElementHead, element.elementTail);
                        return true;
                    }
                }
                return false;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class Processor extends ProcessorContext {
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type number */
            #width;
            /** @type number */
            #height;
    
            /** @type number */
            #chunkSize;
            /** @type number */
            #horChunkCount;
            /** @type number */
            #verChunkCount;
    
            /** @type boolean[] */
            #activeChunks
            /** @type boolean[] */
            #changedChunks
            /** @type number[] */
            #chunkLastFullTest;
    
            /** @type number */
            #iteration = 0;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type boolean */
            #fallThroughEnabled = false;
            /** @type boolean */
            #erasingEnabled = false;
    
            /** @type GameDefaults */
            #defaults;
    
            static RANDOM_DATA_COUNT = 32;
    
            /** @type Uint32Array[] */
            #rndChunkOrder = [];
            /** @type Uint32Array[] */
            #rndChunkXRnd = [];
            /** @type Uint32Array[] */
            #rndChunkXOrder = [];
    
            /** @type ProcessorModuleSolidBody */
            #moduleSolidBody;
            /** @type ProcessorModuleEntity */
            #moduleEntity;
            /** @type ProcessorModuleWater */
            #moduleWater;
            /** @type ProcessorModuleFire */
            #moduleFire;
            /** @type ProcessorModuleMeteor */
            #moduleMeteor;
            /** @type ProcessorModuleGrass */
            #moduleGrass;
            /** @type ProcessorModuleTree */
            #moduleTree;
    
            /** @type Extension[] */
            #extensions = [];
    
            constructor(elementArea, chunkSize, random, defaults, sceneMetadata) {
                super();
                this.#elementArea = elementArea;
                this.#width = elementArea.getWidth();
                this.#height = elementArea.getHeight();
    
                this.#chunkSize = chunkSize;
                if (this.#chunkSize > 255) {
                    throw 'Chunk size limit: 255';
                }
                this.#horChunkCount = Math.ceil(this.#width / this.#chunkSize);
                this.#verChunkCount = Math.ceil(this.#height / this.#chunkSize);
                this.#activeChunks = new Array(this.#horChunkCount * this.#verChunkCount).fill(true);
                this.#changedChunks = new Array(this.#horChunkCount * this.#verChunkCount).fill(true);
                this.#chunkLastFullTest = new Array(this.#horChunkCount * this.#verChunkCount).fill(-1);
    
                let rndDataRandom = new DeterministicRandom(0);
                this.#rndChunkOrder = Processor.#generateArrayOfOrderData(
                    Processor.RANDOM_DATA_COUNT, this.#horChunkCount, rndDataRandom);
                this.#rndChunkXRnd = Processor.#generateArrayOfRandomData(
                    Processor.RANDOM_DATA_COUNT, this.#chunkSize, this.#chunkSize, rndDataRandom);
                this.#rndChunkXOrder = Processor.#generateArrayOfOrderData(
                    Processor.RANDOM_DATA_COUNT, this.#chunkSize, rndDataRandom);
    
                this.#random = random;
                this.#defaults = defaults;
    
                this.#moduleSolidBody = new ProcessorModuleSolidBody(elementArea, random, this);
                this.#moduleEntity = new ProcessorModuleEntity(elementArea, random, this);
                this.#moduleWater = new ProcessorModuleWater(elementArea, random, this);
                this.#moduleFire = new ProcessorModuleFire(elementArea, random, this);
                this.#moduleMeteor = new ProcessorModuleMeteor(elementArea, random, this);
                this.#moduleGrass = new ProcessorModuleGrass(elementArea, random, this);
                this.#moduleTree = new ProcessorModuleTree(elementArea, random, this);
    
                if (sceneMetadata) {
                    this.#iteration = sceneMetadata.iteration;
                    this.#fallThroughEnabled = sceneMetadata.fallThroughEnabled;
                    this.#erasingEnabled = sceneMetadata.erasingEnabled;
                }
            }
    
            static #shuffle(array, iterations, random) {
                for (let i = 0; i < iterations; i++) {
                    let a = random.nextInt(array.length);
                    let b = random.nextInt(array.length);
                    [array[a], array[b]] = [array[b], array[a]];
                }
            }
    
            static #generateArrayOfOrderData(arrayLength, count, random) {
                let data = Processor.#generateOrderData(count);
                Processor.#shuffle(data, arrayLength, random);
    
                let array = Array(arrayLength);
                for (let i = 0; i < arrayLength; i++) {
                    Processor.#shuffle(data, Math.ceil(arrayLength / 4), random);
                    array[i] = new Uint8Array(data);
                }
                return array;
            }
    
            static #generateOrderData(count) {
                let array = new Uint8Array(count);
                for (let i = 0; i < count; i++) {
                    array[i] = i;
                }
                return array;
            }
    
            static #generateArrayOfRandomData(arrayLength, count, max, random) {
                let array = Array(arrayLength);
                for (let i = 0; i < arrayLength; i++) {
                    array[i] = Processor.#generateRandomData(count, max, random);
                }
                return array;
            }
    
            static #generateRandomData(count, max, random) {
                let array = new Uint8Array(count);
                for (let i = 0; i < count; i++) {
                    array[i] = random.nextInt(max);
                }
                return array;
            }
    
            getIteration() {
                return this.#iteration;
            }
    
            getDefaults() {
                return this.#defaults;
            }
    
            setFallThroughEnabled(enabled) {
                this.#fallThroughEnabled = enabled;
            }
    
            setErasingEnabled(enabled) {
                this.#erasingEnabled = enabled;
            }
    
            isFallThroughEnabled() {
                return this.#fallThroughEnabled;
            }
    
            isErasingEnabled() {
                return this.#erasingEnabled;
            }
    
            /**
             *
             * @param extension {Extension}
             */
            addExtension(extension) {
                this.#extensions.push(extension);
            }
    
            trigger(x, y) {
                const cx = Math.floor(x / this.#chunkSize);
                const cy = Math.floor(y / this.#chunkSize);
                const chunkIndex = cy * this.#horChunkCount + cx;
                this.#activeChunks[chunkIndex] = true;
                // this.#changedChunks[chunkIndex] = true;
            }
    
            triggerSolidCreated(elementHead, x, y) {
                this.#moduleSolidBody.onSolidCreated(elementHead, x, y);
            }
    
            getActiveChunks() {
                return this.#activeChunks;
            }
    
            getChangedChunks() {
                return this.#changedChunks;
            }
    
            cleanChangedChunks() {
                this.#changedChunks.fill(false);
            }
    
            next() {
                this.#moduleSolidBody.onNextIteration();
    
                const activeChunks = Array.from(this.#activeChunks);
                this.#activeChunks.fill(false);
    
                // TODO: try extra temperature active chunks with extra loop
                // element temperature is processed once per 9 iterations...
                //   x
                // y 1 2 3
                //   4 5 6
                //   7 8 9
                const temperatureProcessingMod = this.#iteration % 9;
                const temperatureProcessingMod3Y = Math.trunc(temperatureProcessingMod / 3);
                const temperatureProcessingMod3X = temperatureProcessingMod % 3;
    
                for (let cy = this.#verChunkCount - 1; cy >= 0; cy--) {
                    const cyTop = cy * this.#chunkSize;
                    const cyBottom = Math.min((cy + 1) * this.#chunkSize - 1, this.#height - 1);
    
                    const chunkOrder = this.#rndChunkOrder[this.#random.nextInt(Processor.RANDOM_DATA_COUNT)];
                    const fullChunkLoop = this.#random.nextInt(2) === 0;
    
                    const chunkActiveElements = new Uint16Array(this.#horChunkCount);
    
                    for (let y = cyBottom; y >= cyTop; y--) {
                        for (let i = 0; i < this.#horChunkCount; i++) {
                            const cx = chunkOrder[i];
                            const chunkIndex = cy * this.#horChunkCount + cx;
    
                            const idx = this.#random.nextInt(Processor.RANDOM_DATA_COUNT);
                            const chunkXOder = (fullChunkLoop) ? this.#rndChunkXOrder[idx] : this.#rndChunkXRnd[idx];
    
                            if (activeChunks[chunkIndex]) {
                                // standard iteration
                                let activeElements = chunkActiveElements[cx];
                                for (let j = 0; j < this.#chunkSize; j++) {
                                    let x = cx * this.#chunkSize + chunkXOder[j];
                                    if (x < this.#width) {
                                        const processTemperature = (x % 3 === temperatureProcessingMod3X)
                                                && (y % 3 === temperatureProcessingMod3Y);
                                        const activeElement = this.#nextPoint(x, y, processTemperature);
                                        if (activeElement) {
                                            activeElements++;
                                        }
                                    }
                                }
                                chunkActiveElements[cx] = activeElements;
                            }
                        }
                    }
    
                    // fast check deactivated chunks (borders only - if they have active neighbours)
                    for (let cx = 0; cx < this.#horChunkCount; cx++) {
                        const chunkIndex = cy * this.#horChunkCount + cx;
                        if (!activeChunks[chunkIndex]) {
                            if (this.#fastTest(cx, cy, activeChunks)) {
                                // wake up chunk
                                activeChunks[chunkIndex] = true;
                                chunkActiveElements[cx] = 1;
                            }
                        }
                    }
    
                    // deactivate chunks if possible
                    if (fullChunkLoop) {
                        for (let cx = 0; cx < this.#horChunkCount; cx++) {
                            const chunkIndex = cy * this.#horChunkCount + cx;
                            if (activeChunks[chunkIndex] && chunkActiveElements[cx] === 0) {
                                // full test before deactivation
    
                                // this test is quite expensive, so we don't want to perform it every time
                                const lastFullTest = this.#chunkLastFullTest[chunkIndex];
                                if (lastFullTest === -1 || this.#iteration - lastFullTest >= 10) {
                                    if (!this.#fullTest(cx, cy)) {
                                        activeChunks[chunkIndex] = false;
                                        this.#changedChunks[chunkIndex] = true;  // last repaint
                                        this.#chunkLastFullTest[chunkIndex] = this.#iteration;
                                    }
                                }
                            }
                        }
                    }
                }
    
                // erasing mode
                if (this.#erasingEnabled) {
                    const defaultElement = this.#defaults.getDefaultElement();
                    for (let x = 0; x < this.#width; x++) {
                        this.#elementArea.setElement(x, 0, defaultElement);
                        this.#elementArea.setElement(x, this.#height - 1, defaultElement);
                    }
                    for (let y = 1; y < this.#height - 1; y++) {
                        this.#elementArea.setElement(0, y, defaultElement);
                        this.#elementArea.setElement(this.#width - 1, y, defaultElement);
                    }
                }
    
                // merge active chunks
                for (let i = 0; i < this.#horChunkCount * this.#verChunkCount; i++) {
                    let active = activeChunks[i];
                    if (active) {
                        this.#activeChunks[i] = true;
                        this.#changedChunks[i] = true;
                    }
                }
    
                // run extensions
                for (let extension of this.#extensions) {
                    extension.run();
                }
    
                this.#iteration++;
            }
    
            #fastTest(cx, cy, activeChunks) {
                // left
                if (cx > 0 && activeChunks[(cy * this.#horChunkCount) + cx - 1]) {
                    const x = cx * this.#chunkSize;
                    const my = Math.min((cy + 1) * this.#chunkSize, this.#height);
                    for (let y = cy * this.#chunkSize; y < my; y++) {
                        if (this.#testPoint(x, y)) {
                            return true;
                        }
                    }
                }
    
                // right
                if (cx < (this.#horChunkCount - 1) && activeChunks[(cy * this.#horChunkCount) + cx + 1]) {
                    const x = Math.min(((cx + 1) * this.#chunkSize) - 1, this.#width - 1);
                    const my = Math.min((cy + 1) * this.#chunkSize, this.#height);
                    for (let y = cy * this.#chunkSize; y < my; y++) {
                        if (this.#testPoint(x, y)) {
                            return true;
                        }
                    }
                }
    
                // top
                if ((cy > 0) && activeChunks[((cy - 1) * this.#horChunkCount) + cx]
                    || (this.#fallThroughEnabled
                        && cy === 0
                        && activeChunks[((this.#verChunkCount - 1) * this.#horChunkCount) + cx])) {
    
                    const y = cy * this.#chunkSize;
                    const mx = Math.min((cx + 1) * this.#chunkSize, this.#width);
                    for (let x = cx * this.#chunkSize; x < mx; x++) {
                        if (this.#testPoint(x, y)) {
                            return true;
                        }
                    }
                }
    
                // bottom
                if (cy < (this.#verChunkCount - 1) && activeChunks[((cy + 1) * this.#horChunkCount) + cx]) {
                    const y = (cy + 1) * this.#chunkSize - 1;
                    const mx = Math.min((cx + 1) * this.#chunkSize, this.#width);
                    for (let x = cx * this.#chunkSize; x < mx; x++) {
                        if (this.#testPoint(x, y)) {
                            return true;
                        }
                    }
                }
            }
    
            #fullTest(cx, cy) {
                const mx = Math.min((cx + 1) * this.#chunkSize, this.#width);
                const my = Math.min((cy + 1) * this.#chunkSize, this.#height);
                for (let y = cy * this.#chunkSize; y < my; y++) {
                    for (let x = cx * this.#chunkSize; x < mx; x++) {
                        if (this.#testPoint(x, y)) {
                            return true;
                        }
                    }
                }
                return false;
            }
    
            #testPoint(x, y) {
                const elementHead = this.#elementArea.getElementHead(x, y);
    
                if (ElementHead.getTemperature(elementHead) > 0) {
                    return true;
                }
                if (this.#testMovingBehaviour(elementHead, x, y)) {
                    return true;
                }
                switch (ElementHead.getBehaviour(elementHead)) {
                    case ElementHead.BEHAVIOUR_NONE:
                    case ElementHead.BEHAVIOUR_SOIL:
                    case ElementHead.BEHAVIOUR_TREE_TRUNK:
                        return false;
                    default:
                        return true;
                }
            }
    
            /**
             *
             * @param elementHead
             * @param x {number}
             * @param y {number}
             * @returns {boolean}
             */
            #testMovingBehaviour(elementHead, x, y) {
                const type = ElementHead.getTypeClass(elementHead);
                switch (type) {
                    case ElementHead.TYPE_AIR:
                        // no action
                        return false;
    
                    case ElementHead.TYPE_POWDER:
                    case ElementHead.TYPE_POWDER_FLOATING:
                    case ElementHead.TYPE_POWDER_WET:
                        if (ElementHead.getTypeModifierPowderSliding(elementHead)) {
                            return true;
                        } else {
                            return this.#testMove(elementHead, x, y, x, y + 1);
                        }
    
                    case ElementHead.TYPE_FLUID:
                        return this.#testMove(elementHead, x, y, x, y + 1)
                                || this.#testMove(elementHead, x, y, x + 1, y)
                                || this.#testMove(elementHead, x, y, x - 1, y);
    
                    case ElementHead.TYPE_GAS:
                        return this.#testMove(elementHead, x, y, x, y - 1)
                            || this.#testMove(elementHead, x, y, x + 1, y)
                            || this.#testMove(elementHead, x, y, x - 1, y);
    
                    case ElementHead.TYPE_STATIC:
                        const fallingId = ElementHead.getTypeModifierSolidBodyId(elementHead);
                        return (fallingId !== 0);
    
                    default:
                        return true;
                }
                throw "Unknown element type: " + type;
            }
    
            #testMove(elementHead, x, y, x2, y2) {
                if (!this.#elementArea.isValidPosition(x2, y2)) {
                    if (this.#fallThroughEnabled && y === this.#height - 1) {
                        // try fall through
                        y2 = 0;
                        if (!this.#elementArea.isValidPosition(x2, y2)) {
                            return false;
                        }
                        // continue move...
                    } else {
                        return false;
                    }
                }
    
                let elementHead2 = this.#elementArea.getElementHead(x2, y2);
                return this.#canMove(elementHead, elementHead2);
            }
    
            /**
             *
             * @param x {number}
             * @param y {number}
             * @param processTemperature {boolean}
             * @return {boolean} active
             */
            #nextPoint(x, y, processTemperature) {
                const elementHead = this.#elementArea.getElementHead(x, y);
                const moved = this.#performMovingBehaviour(elementHead, x, y);
    
                if (moved) {
                    return true;
                }
    
                const behaviour = ElementHead.getBehaviour(elementHead);
                let active = false;
                switch (behaviour) {
                    case ElementHead.BEHAVIOUR_NONE:
                    case ElementHead.BEHAVIOUR_SOIL:
                        break;
                    case ElementHead.BEHAVIOUR_WATER:
                        if (this.#moduleWater.behaviourWater(elementHead, x, y)) {
                            active = ElementHead.getTemperature(elementHead) > 0;
                            processTemperature = false;
                        }
                        break;
                    case ElementHead.BEHAVIOUR_FIRE:
                        this.#moduleFire.behaviourFire(elementHead, x, y);
                        active = true;
                        processTemperature = false;
                        break;
                    case ElementHead.BEHAVIOUR_GRASS:
                        this.#moduleGrass.behaviourGrass(elementHead, x, y);
                        active = true;
                        break;
                    case ElementHead.BEHAVIOUR_TREE:
                        this.#moduleTree.behaviourTree(elementHead, x, y);
                        active = true;
                        break;
                    case ElementHead.BEHAVIOUR_TREE_LEAF:
                        this.#moduleTree.behaviourTreeLeaf(elementHead, x, y);
                        active = true;
                        break;
                    case ElementHead.BEHAVIOUR_TREE_TRUNK:
                        break;
                    case ElementHead.BEHAVIOUR_TREE_ROOT:
                        this.#moduleTree.behaviourTreeRoot(elementHead, x, y);
                        active = true;
                        break;
                    case ElementHead.BEHAVIOUR_FIRE_SOURCE:
                        this.#moduleFire.behaviourFireSource(elementHead, x, y);
                        active = true;
                        processTemperature = false;
                        break;
                    case ElementHead.BEHAVIOUR_METEOR:
                        this.#moduleMeteor.behaviourMeteor(elementHead, x, y);
                        active = true;
                        processTemperature = false;
                        break;
                    case ElementHead.BEHAVIOUR_ENTITY:
                        this.#moduleEntity.behaviourEntity(elementHead, x, y);
                        processTemperature = true;
                        active = true;
                        break;
                    default:
                        throw "Unknown element behaviour: " + behaviour;
                }
    
                if (processTemperature) {
                    const temperatureRelatedActivity = this.#temperature(elementHead, x, y);
                    return active || temperatureRelatedActivity;
                } else {
                    return active
                }
            }
    
            /**
             *
             * @param elementHead
             * @param x {number}
             * @param y {number}
             * @return boolean
             */
            #temperature(elementHead, x, y) {
                const temp = ElementHead.getTemperature(elementHead);
    
                if (temp === 0) {
                    const heatModIndex = ElementHead.getHeatModIndex(elementHead);
                    if (temp < ElementHead.hmiToHardeningTemperature(heatModIndex)) {
                        this.#tryHardening(elementHead, x, y, heatModIndex);
                        return true;
                    }
                    return false;
                }
    
                // conduct temperature
    
                let tx = x, ty = y;
                switch (this.#random.nextInt(4)) {
                    case 0: ty--; break;  // Up
                    case 1: tx++; break;  // Right
                    case 2: ty++; break;  // Down
                    case 3: tx--; break;  // Left
                }
    
                const heatModIndex = ElementHead.getHeatModIndex(elementHead);
                const heatLoss = (this.#random.nextInt(10000) < ElementHead.hmiToHeatLossChanceTo10000(heatModIndex));
                let newTemp;
    
                if (this.#elementArea.isValidPosition(tx, ty)) {
                    const targetElementHead = this.#elementArea.getElementHead(tx, ty);
                    const targetTemp = ElementHead.getTemperature(targetElementHead);
    
                    if (temp + targetTemp > 1) {
                        const conductiveIndex = ElementHead.hmiToConductiveIndex(heatModIndex);
                        newTemp = Math.trunc((conductiveIndex * targetTemp) + (1 - conductiveIndex) * temp);
                    }
    
                    if (temp - newTemp !== 0) {
                        if (heatLoss) {
                            newTemp--;
                        }
                        newTemp = Math.max(newTemp, 0);
    
                        // update target temp
    
                        let newTargetTemp;
                        if (targetTemp - newTemp > 10) {
                            // limit max absolute dec change - it will look more natural...
                            newTargetTemp = targetTemp - 10;
                        } else {
                            newTargetTemp = targetTemp + (temp - newTemp);
                        }
    
                        newTargetTemp = Math.max(newTargetTemp, 0);
                        this.#elementArea.setElementHead(tx, ty, ElementHead.setTemperature(targetElementHead, newTargetTemp));
                        this.trigger(tx, ty);
    
                        // update this temp
    
                        if (temp - newTemp > 10) {
                            // limit max absolute dec change - it will look more natural...
                            newTemp = temp - 10;
                        }
                        elementHead = ElementHead.setTemperature(elementHead, newTemp);
                        this.#elementArea.setElementHead(x, y, elementHead);
    
                    }
                } else {
                    if (heatLoss) {
                        newTemp = Math.max(temp - 1, 0);
                        elementHead = ElementHead.setTemperature(elementHead, newTemp);
                        this.#elementArea.setElementHead(x, y, elementHead);
                    }
                }
    
                // self-ignition
                const chanceToIgnite = ElementHead.hmiToSelfIgnitionChanceTo10000(heatModIndex);
                if (newTemp > 100 && chanceToIgnite > 0) {
                    if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_FIRE_SOURCE) ; else {
                        if (this.#random.nextInt(10000) < chanceToIgnite) {
                            this.#moduleFire.ignite(elementHead, x, y, heatModIndex);
                            return true;
                        }
                    }
                }
    
                // melting
                if (newTemp > ElementHead.hmiToMeltingTemperature(heatModIndex)) {
                    elementHead = ElementHead.setType(elementHead, ElementHead.TYPE_FLUID);
                    elementHead = ElementHead.setHeatModIndex(elementHead, ElementHead.hmiToMeltingHMI(heatModIndex));
    
                    let elementTail = this.#elementArea.getElementTail(x, y);
                    elementTail = ElementTail.setBlurType(elementTail, ElementTail.BLUR_TYPE_1);
    
                    this.#elementArea.setElementHeadAndTail(x, y, elementHead, elementTail);
                    return true;
                }
    
                // hardening
                if (newTemp < ElementHead.hmiToHardeningTemperature(heatModIndex)) {
                    this.#tryHardening(elementHead, x, y, heatModIndex);
                }
    
                return true;
            }
    
            #tryHardening(elementHead, x, y, heatModIndex) {
                // there must be a solid element nearby
                if (this.#findHardeningSupport(x, y)) {
                    elementHead = ElementHead.setType(elementHead, ElementHead.type8Solid(ElementHead.TYPE_STATIC, 2));
                    elementHead = ElementHead.setHeatModIndex(elementHead, ElementHead.hmiToHardeningHMI(heatModIndex));
    
                    let elementTail = this.#elementArea.getElementTail(x, y);
                    elementTail = ElementTail.setBlurType(elementTail, ElementTail.BLUR_TYPE_NONE);
    
                    this.#elementArea.setElementHeadAndTail(x, y, elementHead, elementTail);
                }
            }
    
            #findHardeningSupport(x, y) {
                // below
                if (y !== this.#height - 1) {
                    if (this.#isHardeningSupport(this.#elementArea.getElementHead(x, y + 1))) {
                        return true;
                    }
                } else {
                    // bottom
                    if (!this.#fallThroughEnabled && !this.#erasingEnabled) {
                        return true;
                    }
                }
    
                // left
                if (this.#elementArea.isValidPosition(x - 1, y)) {
                    if (this.#isHardeningSupport(this.#elementArea.getElementHead(x - 1, y))) {
                        return true;
                    }
                }
    
                // right
                if (this.#elementArea.isValidPosition(x + 1, y)) {
                    if (this.#isHardeningSupport(this.#elementArea.getElementHead(x + 1, y))) {
                        return true;
                    }
                }
    
                return false;  // support not found
            }
    
            #isHardeningSupport(targetElementHead) {
                const typeClass = ElementHead.getTypeClass(targetElementHead);
                if (typeClass > ElementHead.TYPE_FLUID) {
                    return true;
                }
                return false;
            }
    
            /**
             *
             * @param elementHead
             * @param x {number}
             * @param y {number}
             * @returns {boolean}
             */
            #performMovingBehaviour(elementHead, x, y) {
                const type = ElementHead.getTypeClass(elementHead);
                switch (type) {
                    case ElementHead.TYPE_AIR:
                        // no action
                        return false;
    
                    case ElementHead.TYPE_POWDER:
                    case ElementHead.TYPE_POWDER_WET:
                    case ElementHead.TYPE_POWDER_FLOATING:
                        if (this.#move(elementHead, x, y, x, y + 1)) {
                            // moved down
    
                            if (y % 2 === 0) {
                                this.#wake(x - 1, y + 1, 0);
                            } else {
                                this.#wake(x + 1, y + 1, 1);
                            }
    
                            this.#wake(x, y + 1, y % 2);
    
                            if (y % 2 === 0) {
                                this.#wake(x + 1, y, 0);
                            } else {
                                this.#wake(x - 1, y, 1);
                            }
    
                            return true;
                        } else {
                            if (ElementHead.getTypeModifierPowderSliding(elementHead) === 1) {
                                const momentum = ElementHead.getTypeModifierPowderMomentum(elementHead);
    
                                const r = this.#random.nextInt(1000000);
                                if (r > Processor.#asMomentumMoveInMillion(momentum)) {
                                    // stop - lost momentum
                                    this.#elementArea.setElementHead(x, y, ElementHead.setTypeModifierPowderSliding(elementHead, 0));
                                    return false;
                                }
    
                                const direction = ElementHead.getTypeModifierPowderDirection(elementHead);
                                this.#wake(x, y + 1, direction);
    
                                const directionX = (direction === 0) ? -1 : 1;
                                if (this.#move(elementHead, x, y, x + directionX, y)) {
                                    // moved horizontally
                                    this.#wake(x + directionX, y + 1, direction);
                                    this.#wake(x - directionX, y, direction);
                                    return true;
                                } else {
                                    // stop - nowhere to go
                                    this.#wake(x + directionX, y + 1, direction);
                                    this.#elementArea.setElementHead(x, y, ElementHead.setTypeModifierPowderSliding(elementHead, 0));
                                    return false;
                                }
                            }
                            return false;
                        }
    
                    case ElementHead.TYPE_FLUID:
                        // slow moving fluid
                        // if (!this.#move(elementHead, x, y, x, y + 1)) {
                        //     let rnd = this.#random.nextInt(2);
                        //     if (rnd === 0) {
                        //         return this.#move(elementHead, x, y, x + 1, y)
                        //     } else {
                        //         return this.#move(elementHead, x, y, x - 1, y)
                        //     }
                        // }
                        // return true;
    
                        // fast moving fluid (it can move by 3)
                        if (!this.#move(elementHead, x, y, x, y + 1)) {
                            let rnd = this.#random.nextInt(2);
                            if (rnd === 0) {
                                if (this.#move(elementHead, x, y, x + 1, y)) {
                                    this.#wake(x + 1, y + 1, 1);
                                    if (this.#move(elementHead, x + 1, y, x + 2, y)) {
                                        if (this.#move(elementHead, x + 2, y, x + 3, y)) {
                                            this.trigger(x + 3, y);
                                        } else {
                                            this.trigger(x + 2, y);
                                        }
                                    }
                                    return true;
                                }
                                return false;
                            } else {
                                if (this.#move(elementHead, x, y, x - 1, y)) {
                                    this.#wake(x - 1, y + 1, 0);
                                    if (this.#move(elementHead, x - 1, y, x - 2, y)) {
                                        if (this.#move(elementHead, x - 2, y, x - 3, y)) {
                                            this.trigger(x - 3, y);
                                        } else {
                                            this.trigger(x - 2, y);
                                        }
                                    }
                                    return true;
                                }
                                return false;
                            }
                        }
                        return true;
    
                    case ElementHead.TYPE_GAS:
                        let rnd = this.#random.nextInt(8);
                        if (rnd === 0 || rnd === 2) {
                            if (this.#move(elementHead, x, y, x, y - 1)) {
                                // moved up
                                this.trigger(x, y - 1);
                                return true;
                            }
                        }
                        if (rnd === 3) {
                            if (this.#move(elementHead, x, y, x + 1, y)) {
                                // moved right
                                this.trigger(x + 1, y);
                                return true;
                            }
                        }
                        if (rnd === 4) {
                            if (this.#move(elementHead, x, y, x - 1, y)) {
                                // moved left
                                this.trigger(x - 1, y);
                                return true;
                            }
                        }
                        return false;
    
                    case ElementHead.TYPE_STATIC:
                        const fallingId = ElementHead.getTypeModifierSolidBodyId(elementHead);
                        if (fallingId === 0) {
                            return false;
                        } else {
                            return this.#moduleSolidBody.behaviourSolid(elementHead, x, y);
                        }
    
                    case ElementHead.TYPE_EFFECT:
                        // no action
                        return false;
                }
                throw "Unknown element type: " + type;
            }
    
            #move(elementHead, x, y, x2, y2) {
                if (!this.#elementArea.isValidPosition(x2, y2)) {
                    if (this.#fallThroughEnabled && y === this.#height - 1) {
                        // try fall through
                        y2 = 0;
                        if (!this.#elementArea.isValidPosition(x2, y2)) {
                            return false;
                        }
                        // continue move...
                    } else {
                        return false;
                    }
                }
    
                const elementHead2 = this.#elementArea.getElementHead(x2, y2);
                const elementType2 = ElementHead.getTypeClass(elementHead2);
                if (elementType2 === ElementHead.TYPE_POWDER_FLOATING || elementType2 === ElementHead.TYPE_POWDER) {
                    return false;
                }
    
                const elementType1 = ElementHead.getTypeClass(elementHead);
                if (elementType1 > elementType2) {
                    // move
    
                    if (elementType1 === ElementHead.TYPE_POWDER && elementType2 === ElementHead.TYPE_FLUID) {
                        // element may cover element2
    
                        const elementHeadWithAbsorbedFluid = ElementHead.setTypeClass(elementHead, ElementHead.TYPE_POWDER_WET);
                        const elementTail = this.#elementArea.getElementTail(x, y);
    
                        // sometimes element2 will not be covered - it looks better
                        if (this.#random.nextInt(100) > 9) {
                            this.#elementArea.setElement(x, y, this.#defaults.getDefaultElement());
                        } else {
                            const elementTail2 = this.#elementArea.getElementTail(x2, y2);
                            this.#elementArea.setElementHead(x, y, elementHead2);
                            this.#elementArea.setElementTail(x, y, elementTail2);
                        }
                        this.#elementArea.setElementHead(x2, y2, elementHeadWithAbsorbedFluid);
                        this.#elementArea.setElementTail(x2, y2, elementTail);
    
                    } else {
                        // swap
    
                        const elementTail = this.#elementArea.getElementTail(x, y);
                        const elementTail2 = this.#elementArea.getElementTail(x2, y2);
    
                        this.#elementArea.setElementHead(x2, y2, elementHead);
                        this.#elementArea.setElementHead(x, y, elementHead2);
                        this.#elementArea.setElementTail(x2, y2, elementTail);
                        this.#elementArea.setElementTail(x, y, elementTail2);
                    }
                    return true;
                }
                return false;
            }
    
            #canMove(elementHead1, elementHead2) {
                const elementType2 = ElementHead.getTypeClass(elementHead2);
                if (elementType2 === ElementHead.TYPE_POWDER_FLOATING || elementType2 === ElementHead.TYPE_POWDER) {
                    return false;
                }
    
                const elementType1 = ElementHead.getTypeClass(elementHead1);
                return elementType1 > elementType2;
            }
    
            #wake(x, y, direction) {
                if (this.#elementArea.isValidPosition(x, y)) {
                    let elementHead = this.#elementArea.getElementHead(x, y);
                    const type = ElementHead.getTypeClass(elementHead);
                    if (type === ElementHead.TYPE_POWDER
                            || type === ElementHead.TYPE_POWDER_WET
                            || type === ElementHead.TYPE_POWDER_FLOATING) {
    
                        const momentum = ElementHead.getTypeModifierPowderMomentum(elementHead);
                        if (momentum === 0) {
                            return;  // never wake up
                        }
    
                        const directionX = (direction === 0) ? -1 : 1;
                        if (this.#elementArea.isValidPosition(x + directionX, y)) {
                            const nextElementHead = this.#elementArea.getElementHead(x + directionX, y);
                            if (!this.#canMove(elementHead, nextElementHead)) {
                                return;  // target element has no space to move
                            }
                        }
    
                        const r = this.#random.nextInt(1000000);
                        if (r > Processor.#asMomentumWakeupInMillion(momentum)) {
                            return;  // not this time
                        }
    
                        elementHead = ElementHead.setTypeModifierPowderSliding(elementHead, 1);
                        elementHead = ElementHead.setTypeModifierPowderDirection(elementHead, direction);
                        this.#elementArea.setElementHead(x, y, elementHead);
                    }
                }
            }
    
    
            static #asMomentumMoveInMillion(momentum) {
                return [0, 400000, 600000, 700000, 700000, 800000, 950000, 950000][momentum];  // none .. almost always
            }
    
            static #asMomentumWakeupInMillion(momentum) {
                return [0, 400000, 400000, 400000, 600000, 600000, 850000, 900000][momentum];  // never .. almost always
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2023-08-27
         */
        class Renderer {
    
            trigger(x, y) {
                throw 'Not implemented';
            }
    
            /**
             *
             * @param changedChunks {boolean[]}
             * @return {void}
             */
            render(changedChunks) {
                throw 'Not implemented';
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @author Patrik Harag
         * @version 2023-02-18
         */
        class RenderingMode {
    
            /**
             * Element rendering function.
             *
             * Default implementation:
             * <pre>
             *     data[dataIndex] = ElementTail.getColorRed(elementTail);
             *     data[dataIndex + 1] = ElementTail.getColorGreen(elementTail);
             *     data[dataIndex + 2] = ElementTail.getColorBlue(elementTail);
             * </pre>
             *
             * @param data
             * @param dataIndex
             * @param elementHead
             * @param elementTail
             */
            apply(data, dataIndex, elementHead, elementTail) {
                throw 'Not implemented'
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * Double buffered renderer. With motion blur.
         *
         * @author Patrik Harag
         * @version 2023-08-27
         */
        class Renderer2D extends Renderer {
    
            /**
             *
             * @param elementArea {ElementArea}
             * @param context {CanvasRenderingContext2D}
             * @param alpha 0x00 = fully transparent, 0xFF = fully opaque
             */
            static renderPreview(elementArea, context, alpha=0xFF) {
                const w = elementArea.getWidth();
                const h = elementArea.getHeight();
    
                const buffer = context.createImageData(w, h);
                const data = buffer.data;
    
                for (let x = 0; x < w; x++) {
                    for (let y = 0; y < h; y++) {
                        const pixelIndex = w * y + x;
                        const dataIndex = pixelIndex * 4;
    
                        const elementTail = elementArea.getElementTail(x, y);
    
                        if (elementTail === ElementArea.TRANSPARENT_ELEMENT.elementTail
                                && elementArea.getElementHead(x, y) === ElementArea.TRANSPARENT_ELEMENT.elementHead) {
    
                            // transparent
                            data[dataIndex + 3] = 0;
                        } else {
                            data[dataIndex] = ElementTail.getColorRed(elementTail);
                            data[dataIndex + 1] = ElementTail.getColorGreen(elementTail);
                            data[dataIndex + 2] = ElementTail.getColorBlue(elementTail);
                            data[dataIndex + 3] = alpha;
                        }
                    }
                }
    
                context.putImageData(buffer, 0, 0, 0, 0, w, h);
            }
    
    
            /** @type CanvasRenderingContext2D */
            #context;
    
            /** @type RenderingMode|null */
            #mode = null;
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type number */
            #width;
            /** @type number */
            #height;
    
            /** @type number */
            #chunkSize;
            /** @type number */
            #horChunkCount;
            /** @type number */
            #verChunkCount;
    
            /** @type boolean[] */
            #triggeredChunks
    
            /** @type ImageData */
            #buffer;
    
            /** @type boolean[] */
            #blur;
    
            /** @type boolean[] */
            #canBeBlurred;
    
            constructor(elementArea, chunkSize, context) {
                super();
                this.#context = context;
                this.#elementArea = elementArea;
                this.#width = elementArea.getWidth();
                this.#height = elementArea.getHeight();
    
                this.#chunkSize = chunkSize;
                this.#horChunkCount = Math.ceil(this.#width / this.#chunkSize);
                this.#verChunkCount = Math.ceil(this.#height / this.#chunkSize);
                this.#triggeredChunks = new Array(this.#horChunkCount * this.#verChunkCount).fill(true);
    
                this.#buffer = this.#context.createImageData(this.#width, this.#height);
                // set up alpha color component
                const data = this.#buffer.data;
                for (let y = 0; y < this.#height; y++) {
                    for (let x = 0; x < this.#width; x++) {
                        let index = 4 * (this.#width * y + x);
                        data[index + 3] = 0xFF;
                    }
                }
    
                this.#blur = new Array(this.#width * this.#height).fill(false);
                this.#canBeBlurred = new Array(this.#width * this.#height).fill(false);
            }
    
            trigger(x, y) {
                const cx = Math.trunc(x / this.#chunkSize);
                const cy = Math.trunc(y / this.#chunkSize);
                const chunkIndex = cy * this.#horChunkCount + cx;
                this.#triggeredChunks[chunkIndex] = true;
            }
    
            triggerChunk(cx, cy) {
                const chunkIndex = cy * this.#horChunkCount + cx;
                this.#triggeredChunks[chunkIndex] = true;
            }
    
            triggerChunks(activeChunks) {
                if (activeChunks.length !== this.#triggeredChunks.length) {
                    throw 'Array must be of the same size';
                }
                for (let i = 0; i < activeChunks.length; i++) {
                    const active = activeChunks[i];
                    if (active) {
                        this.#triggeredChunks[i] = active;
                    }
                }
            }
    
            setMode(mode) {
                this.#mode = mode;
                // ensure repaint
                this.#triggeredChunks.fill(true);
                this.#blur.fill(false);
                this.#canBeBlurred.fill(false);
            }
    
            /**
             *
             * @param changedChunks {boolean[]}
             * @return {void}
             */
            render(changedChunks) {
                for (let cy = 0; cy < this.#verChunkCount; cy++) {
                    for (let cx = 0; cx < this.#horChunkCount; cx++) {
                        const chunkIndex = cy * this.#horChunkCount + cx;
    
                        const triggered = this.#triggeredChunks[chunkIndex];
                        if (triggered) {
                            // unset
                            this.#triggeredChunks[chunkIndex] = false;
                        }
    
                        const changed = changedChunks[chunkIndex];
                        if (changed) {
                            // repaint at least once
                            this.#triggeredChunks[chunkIndex] = true;
                        }
    
                        if (triggered || changed) {
    
                            // neighbours can be changed without triggering
                            let includeRowUnder = false;
                            if (cy + 1 < this.#horChunkCount) {
                                const chunkIndexUnder = (cy + 1) * this.#horChunkCount + cx;
                                if (!this.#triggeredChunks[chunkIndexUnder] && !changedChunks[chunkIndexUnder]) {
                                    includeRowUnder = true;
                                }
                            }
    
                            this.#renderChunk(cx, cy, includeRowUnder);
                        }
                    }
                }
    
                // TODO: ? multiple partial putImageData
                this.#context.putImageData(this.#buffer, 0, 0, 0, 0, this.#width, this.#height);
            }
    
            #renderChunk(cx, cy, includeRowUnder) {
                const mx = Math.min((cx + 1) * this.#chunkSize, this.#width);
                const my = Math.min((cy + 1) * this.#chunkSize + (includeRowUnder ? 1 : 0), this.#height);
                for (let y = cy * this.#chunkSize; y < my; y++) {
                    for (let x = cx * this.#chunkSize; x < mx; x++) {
                        this.#renderPixel(x, y, this.#buffer.data);
                    }
                }
            }
    
            #renderPixel(x, y, data) {
                const elementTail = this.#elementArea.getElementTail(x, y);
    
                const pixelIndex = this.#width * y + x;
                const dataIndex = pixelIndex * 4;
    
                const blurBehaviour = ElementTail.getBlurType(elementTail);
    
                if (blurBehaviour === ElementTail.BLUR_TYPE_BACKGROUND) {
                    // motion blur
    
                    if (this.#canBeBlurred[pixelIndex] && Renderer2D.#isWhite(elementTail)) {
                        // init fading here
    
                        this.#blur[pixelIndex] = true;
                        this.#canBeBlurred[pixelIndex] = false;
                    }
    
                    if (this.#blur[pixelIndex]) {
                        // paint - continue fading
    
                        const r = data[dataIndex];
                        const g = data[dataIndex + 1];
                        const b = data[dataIndex + 2];
    
                        const alpha = 0.875 + (Math.random() * 0.1 - 0.05);
                        const whiteBackground = 255 * (1.0 - alpha);
    
                        const nr = Math.trunc((r * alpha) + whiteBackground);
                        const ng = Math.trunc((g * alpha) + whiteBackground);
                        const nb = Math.trunc((b * alpha) + whiteBackground);
    
                        if (r === nr && g === ng && b === nb) {
                            // no change => fading completed
                            this.#blur[pixelIndex] = false;
                            data[dataIndex] = 0xFF;
                            data[dataIndex + 1] = 0xFF;
                            data[dataIndex + 2] = 0xFF;
                        } else {
                            data[dataIndex] = nr;
                            data[dataIndex + 1] = ng;
                            data[dataIndex + 2] = nb;
                            this.trigger(x, y);  // request next repaint
                        }
                        return;
                    }
                }
    
                // paint - no blur
                if (this.#mode === null) {
                    data[dataIndex] = ElementTail.getColorRed(elementTail);
                    data[dataIndex + 1] = ElementTail.getColorGreen(elementTail);
                    data[dataIndex + 2] = ElementTail.getColorBlue(elementTail);
                    this.#canBeBlurred[pixelIndex] = (blurBehaviour === ElementTail.BLUR_TYPE_1);
                    this.#blur[pixelIndex] = false;
                } else {
                    // custom rendering mode
                    let elementHead = this.#elementArea.getElementHead(x, y);
                    this.#mode.apply(data, dataIndex, elementHead, elementTail);
                }
            }
    
            static #isWhite(element) {
                return ElementTail.getColorRed(element) === 255
                    && ElementTail.getColorGreen(element) === 255
                    && ElementTail.getColorBlue(element) === 255;
            }
        }
    
        var img$4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAABCAIAAACnnMvDAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTUlEQVQ4T22QUZIjMQhDHzhH32PHYj/UZoiTLlcXloQQfsE/AF6QsM6/i4CABa9T5Kj5RPqfkL9s29y2l6e75lBff33Nx2h6AcfGxxP6ykjU+Exkw5m3YxqfbnPRucfPSFev1+p64rbqrm9NAif2xfYiPc5UCz5sixRLZLF2poDMylSmcilcLxkBMhShpBIlCirZiwoEGDz4U/tqxPqg1oMrqcEqkak2sW2g9WlrK2DiBsfQJ1JQi90ZAuLIEnmdwbrwXg+42ImggvpK8mQ+UTvMh//Fdh6D/Xrt1uITqc77/C2SUlRFKaVUpSpFbFKECAEgEGwo2CCog3Bwawy6qNNrZOJumV3XiIu98I4xRztMt7Smz1zkW3YtcmnMXtTPqK35yZ4RJd4bQELiLarYG4m9nwltsMe61/COY6rgfWa+x8xmO1FbWd91P5Lr/2afRpQBYZvbAAAAAElFTkSuQmCC";
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @author Patrik Harag
         * @version 2023-08-14
         */
        class RenderingModeHeatmap extends RenderingMode {
    
            /** @type ImageData */
            #gradientImageData = null;
    
            constructor() {
                super();
                Assets.asImageData(img$4).then(d => this.#gradientImageData = d);
            }
    
            apply(data, dataIndex, elementHead, elementTail) {
                if (this.#gradientImageData === null) {
                    // not loaded yet
                    return;
                }
    
                if (elementHead === 0x00) {
                    // background
                    data[dataIndex] = 0x00;
                    data[dataIndex + 1] = 0x00;
                    data[dataIndex + 2] = 0x00;
                } else {
                    const temperature = ElementHead.getTemperature(elementHead);
                    const x = Math.trunc(temperature / (1 << ElementHead.FIELD_TEMPERATURE_SIZE) * this.#gradientImageData.width);
                    const gradIndex = x * 4;
                    data[dataIndex] = this.#gradientImageData.data[gradIndex];
                    data[dataIndex + 1] = this.#gradientImageData.data[gradIndex + 1];
                    data[dataIndex + 2] = this.#gradientImageData.data[gradIndex + 2];
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @author Patrik Harag
         * @version 2023-08-18
         */
        class RenderingModeElementType extends RenderingMode {
    
            constructor() {
                super();
            }
    
            #asColor(elementHead) {
                switch (ElementHead.getTypeClass(elementHead)) {
                    case ElementHead.TYPE_AIR: return [255, 255, 255];
                    case ElementHead.TYPE_STATIC: return [0, 0, 0];
                    case ElementHead.TYPE_FLUID: return [0, 0, 255];
                    case ElementHead.TYPE_POWDER:
                    case ElementHead.TYPE_POWDER_WET:
                    case ElementHead.TYPE_POWDER_FLOATING:
                        if (ElementHead.getTypeModifierPowderSliding(elementHead) === 1) {
                            if (ElementHead.getTypeModifierPowderDirection(elementHead) === 1) {
                                return [232, 137, 70];
                            } else {
                                return [255, 0, 0];
                            }
                        }
                        switch (ElementHead.getTypeClass(elementHead)) {
                            case ElementHead.TYPE_POWDER: return [36, 163, 57];
                            case ElementHead.TYPE_POWDER_WET: return [44, 122, 57];
                            case ElementHead.TYPE_POWDER_FLOATING: return [16, 194, 45];
                        }
                        // fallthrough
                    default: return [255, 0, 125];
                }
            }
    
            apply(data, dataIndex, elementHead, elementTail) {
                const [r, g, b] = this.#asColor(elementHead);
    
                data[dataIndex] = r;
                data[dataIndex + 1] = g;
                data[dataIndex + 2] = b;
    
                return false;
            }
        }
    
        var _ASSET_PALETTE_TEMPERATURE_COLORS = "255,51,0\n255,69,0\n255,82,0\n255,93,0\n255,102,0\n255,111,0\n255,118,0\n255,124,0\n255,130,0\n255,135,0\n255,141,11\n255,146,29\n255,152,41\n255,157,51\n255,162,60\n255,166,69\n255,170,77\n255,174,84\n255,178,91\n255,182,98\n255,185,105\n255,189,111\n255,192,118\n255,195,124\n255,198,130\n255,201,135\n255,203,141\n255,206,146\n255,208,151\n255,211,156\n255,213,161\n255,215,166\n255,217,171\n255,219,175\n255,221,180\n255,223,184\n255,225,188\n255,226,192\n255,228,196\n255,229,200\n255,231,204\n255,232,208\n255,234,211\n255,235,215\n255,237,218\n255,238,222\n255,239,225\n255,240,228\n255,241,231\n255,243,234\n255,244,237\n255,245,240\n255,246,243\n255,247,245\n255,248,248\n255,249,251\n255,249,253\n254,250,255\n252,248,255\n250,247,255\n247,245,255\n245,244,255\n243,243,255\n241,241,255\n239,240,255\n238,239,255\n236,238,255\n234,237,255\n233,236,255\n231,234,255\n229,233,255\n228,233,255\n227,232,255\n225,231,255\n224,230,255\n223,229,255\n221,228,255\n220,227,255\n219,226,255\n218,226,255\n217,225,255\n216,224,255\n215,223,255\n214,223,255\n213,222,255\n212,221,255\n211,221,255\n210,220,255\n209,220,255\n208,219,255\n207,218,255";
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        // TODO: Currently element tail bytes are stored as floats (0..1) in texture and then transformed back to integers
        // TODO: https://www.khronos.org/webgl/wiki/HandlingContextLost
    
        /**
         * WebGL renderer.
         *
         * @author Patrik Harag
         * @version 2024-04-06
         */
        class RendererWebGL extends Renderer {
    
            /** @type WebGLRenderingContext */
            #context;
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type number */
            #width;
            /** @type number */
            #height;
    
            #doRendering;
    
            constructor(elementArea, chunkSize, context) {
                super();
                this.#context = context;
                this.#elementArea = elementArea;
                this.#width = elementArea.getWidth();
                this.#height = elementArea.getHeight();
    
                const gl = this.#context;
    
                // --- build programs
    
                const temperaturePaletteData = this.#parsePalette(_ASSET_PALETTE_TEMPERATURE_COLORS);
                const temperaturePaletteSize = temperaturePaletteData.byteLength / 4;
    
                const function_applyTemperature = `
                float countTemperaturePaletteIndex(float c) {
                    float k = c + 273.0;  // 0 C = 273 K
                    if (k < 1000.0) {
                        return 0.0;
                    } else {
                        return floor(k / 100.0 - 10.0);
                    }
                }
                
                void applyTemperature(float temperature, int heatType, inout float r, inout float g, inout float b) {
                    float tFactor;
                    float aFactor = 0.001;
                    if (heatType == 0x01) {
                        tFactor = 0.5;
                    } else if (heatType == 0x02) {
                        tFactor = 1.0;
                    } else {  // heatType == 0x03
                        tFactor = 1.45;
                    }
                    
                    float sTemp = (temperature * 255.0 * 10.0) * tFactor;
                    float i = countTemperaturePaletteIndex(sTemp);
                    vec4 color = texture(u_temperature_palette, vec2((i + 0.5) / ${temperaturePaletteSize}.0, 0.5));
                    float cr = color[0];
                    float cg = color[1];
                    float cb = color[2];
                    
                    float alpha = 1.0 - sTemp * aFactor;
                    
                    // alpha blending
                    r = (r * alpha) + (cr * (1.0 - alpha));
                    g = (g * alpha) + (cg * (1.0 - alpha));
                    b = (b * alpha) + (cb * (1.0 - alpha));
                }
            `;
    
                const vertexShaderBlur = `#version 300 es
                in vec4 a_position;
                
                out vec2 v_texcoord;
                
                void main() {
                  gl_Position = a_position;
                  v_texcoord = a_position.xy * vec2(0.5, 0.5) + 0.5;
                }
            `;
    
                const fragmentShaderBlur = `#version 300 es
                precision mediump float;
                
                in vec2 v_texcoord;
                out vec4 v_color;
                
                uniform sampler2D u_element_heads;
                uniform sampler2D u_element_tails;
                uniform sampler2D u_blur;
                uniform sampler2D u_temperature_palette;
                
                ${function_applyTemperature}
    
                float rand(vec2 co) {
                    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
                }
    
                void main() {
                    vec4 elementTail = texture(u_element_tails, v_texcoord);
                    int flags = int(floor(elementTail[3] * 255.0 + 0.5));
                    int blurType = (flags & 0x3);
                
                    if (blurType == 0x0) {  // == BLUR_TYPE_NONE
                        // do not render non-blurrable elements
                        v_color = vec4(1.0, 1.0, 1.0, 1.0);
                        
                    } else if (blurType == 0x1) {  // == BLUR_TYPE_BACKGROUND
                        // fade out... using alpha blending with white background
                        
                        vec4 oldPixel = texture(u_blur, v_texcoord);
                        float r = oldPixel[0];  // 0..1
                        float g = oldPixel[1];
                        float b = oldPixel[2];
                        
                        float alpha;  // dynamic alpha
                        float m = max(r, max(g, b));
                        if (m > 0.9) {
                            alpha = 0.875 + (rand(v_texcoord.xy) * 0.1 - 0.05);
                        } else {
                            alpha = 0.775 + (rand(v_texcoord.xy) * 0.04 - 0.02);
                        }
                        float whiteBackground = 1.0 - alpha;
                        
                        float nr = (r * alpha) + whiteBackground;
                        float ng = (g * alpha) + whiteBackground;
                        float nb = (b * alpha) + whiteBackground;
                        
                        if (int(nr * 255.0) == int(r * 255.0)
                                && int(ng * 255.0) == int(g * 255.0)
                                && int(nb * 255.0) == int(b * 255.0)) {
                                
                            // no change - delete blur (otherwise there could be visible remains)
                            v_color = vec4(1.0, 1.0, 1.0, 1.0);
                            
                        } else {
                            v_color = vec4(nr, ng, nb, 1.0);
                        }
                        
                    } else {  // == BLUR_TYPE_1
                        // render element
                        float r = elementTail[2];  // 0..1
                        float g = elementTail[1];
                        float b = elementTail[0];
                        
                        // apply temperature
                        int heatType = (flags >> 4) & 0x3;
                        if (heatType > 0) {
                            vec4 elementHead = texture(u_element_heads, v_texcoord);
                            float temperature = elementHead[3];  // 0..1
                            
                            if (temperature >= 0.001) {
                                applyTemperature(temperature, heatType, r, g, b);
                            }
                        }
                        
                        v_color = vec4(r, g, b, 1.0);
                    }
                }
            `;
    
                const blurProgram = this.#loadProgram(gl, vertexShaderBlur, fragmentShaderBlur);
                const blurProgramLocationElementHeads = gl.getUniformLocation(blurProgram, "u_element_heads");
                const blurProgramLocationElementTails = gl.getUniformLocation(blurProgram, "u_element_tails");
                const blurProgramLocationBlur = gl.getUniformLocation(blurProgram, "u_blur");
                const blurProgramLocationTemperaturePalette = gl.getUniformLocation(blurProgram, "u_temperature_palette");
    
                const vertexShaderMerging = `#version 300 es
                in vec4 a_position;
                
                out vec2 v_texcoord;
                
                void main() {
                  gl_Position = a_position;
    
                  // Flip Y though so we get the top at 0
                  v_texcoord = a_position.xy * vec2(0.5, -0.5) + 0.5;
                }
            `;
    
                const fragmentShaderMerging = `#version 300 es
                precision mediump float;
                
                in vec2 v_texcoord;
                out vec4 v_color;
                
                uniform sampler2D u_element_heads;
                uniform sampler2D u_element_tails;
                uniform sampler2D u_blur;
                uniform sampler2D u_temperature_palette;
                
                ${function_applyTemperature}
                
                void main() {
                    vec4 elementTail = texture(u_element_tails, v_texcoord);
                    int flags = int(floor(elementTail[3] * 255.0 + 0.5));
                    int blurType = (flags & 0x3);
                    
                    if (blurType == 0x00) {  // == BLUR_TYPE_NONE
                        // render element
                        float r = elementTail[2];  // 0..1
                        float g = elementTail[1];
                        float b = elementTail[0];
                        
                        // apply temperature
                        int heatType = (flags >> 4) & 0x3;
                        if (heatType > 0) {
                            vec4 elementHead = texture(u_element_heads, v_texcoord);
                            float temperature = elementHead[3];  // 0..1
                            
                            if (temperature >= 0.001) {
                                applyTemperature(temperature, heatType, r, g, b);
                            }
                        }
                        
                        v_color = vec4(r, g, b, 1.0);
                    
                    } else {
                        v_color = texture(u_blur, v_texcoord);
                    }
                }
            `;
    
                const mergeProgram = this.#loadProgram(gl, vertexShaderMerging, fragmentShaderMerging);
                const mergeProgramLocationElementHeads = gl.getUniformLocation(mergeProgram, "u_element_heads");
                const mergeProgramLocationElementTails = gl.getUniformLocation(mergeProgram, "u_element_tails");
                const mergeProgramLocationBlur = gl.getUniformLocation(mergeProgram, "u_blur");
                const mergeProgramLocationTemperaturePalette = gl.getUniformLocation(mergeProgram, "u_temperature_palette");
    
                // --- setup a unit quad
    
                const positions = [
                    1,  1,
                    -1,  1,
                    -1, -1,
                    1,  1,
                    -1, -1,
                    1, -1,
                ];
                const vertBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    
                // --- prepare texture and associated frame buffer for motion blur
                // it is not possible to sample a texture and render to that same texture at the same time
                // two textures needs to be used - "ping-pong" approach
    
                const createTextureAndFrameBuffer = (textureId) => {
                    const motionBlurData = new Uint8Array(this.#elementArea.getDataTails().byteLength).fill(0xFF);
                    const motionBlurTexture = gl.createTexture();
                    gl.activeTexture(textureId);
                    gl.bindTexture(gl.TEXTURE_2D, motionBlurTexture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.#width, this.#height, 0, gl.RGBA, gl.UNSIGNED_BYTE, motionBlurData);
    
                    const motionBlurFrameBuffer = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, motionBlurFrameBuffer);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, motionBlurTexture, 0);
    
                    return motionBlurFrameBuffer;
                };
    
                const motionBlurFrameBuffer1 = createTextureAndFrameBuffer(gl.TEXTURE2);
                const motionBlurFrameBuffer2 = createTextureAndFrameBuffer(gl.TEXTURE3);
    
                // --- prepare element heads texture - TEXTURE0
                // move the texture definition into rendering loop to create a memory leak - to test WebGL failure recovery
    
                const elementHeadsTexture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, elementHeadsTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    
                // --- prepare element tails texture - TEXTURE1
                const elementTailsTexture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, elementTailsTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    
                // --- prepare temperature colors
    
                const temperaturePaletteTexture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, temperaturePaletteTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    
                // ---
    
                let blurTextureIndex = 2;  // "ping-pong" approach - see above
                this.#doRendering = () => {
    
                    // update element heads texture
                    const elementHeads = new Uint8Array(this.#elementArea.getDataHeads());
                    gl.bindTexture(gl.TEXTURE_2D, elementHeadsTexture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.#width, this.#height, 0, gl.RGBA, gl.UNSIGNED_BYTE, elementHeads);
    
                    // update element tails texture
                    const elementTails = new Uint8Array(this.#elementArea.getDataTails());
                    gl.bindTexture(gl.TEXTURE_2D, elementTailsTexture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.#width, this.#height, 0, gl.RGBA, gl.UNSIGNED_BYTE, elementTails);
    
                    // update color palette texture
                    gl.bindTexture(gl.TEXTURE_2D, temperaturePaletteTexture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, temperaturePaletteSize, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, temperaturePaletteData);
    
                    // render blurrable elements and blur into a texture
                    // - reduce blur from previous iterations (fading out) and render blurrable elements over
                    gl.bindFramebuffer(gl.FRAMEBUFFER, blurTextureIndex === 2 ? motionBlurFrameBuffer1 : motionBlurFrameBuffer2);
    
                    gl.useProgram(blurProgram);
                    gl.uniform1i(blurProgramLocationElementHeads, 0);  // texture 0
                    gl.uniform1i(blurProgramLocationElementTails, 1);  // texture 1
                    gl.uniform1i(blurProgramLocationBlur, (blurTextureIndex === 2) ? 3 : 2);  // texture 3 or 2
                    gl.uniform1i(blurProgramLocationTemperaturePalette, 4);  // texture 4
    
                    gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);
    
                    // render to canvas
                    // - blurrable elements and blur will be merged with elements that cannot be blurred
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    
                    gl.useProgram(mergeProgram);
                    gl.uniform1i(mergeProgramLocationElementHeads, 0);  // texture 0
                    gl.uniform1i(mergeProgramLocationElementTails, 1);  // texture 1
                    gl.uniform1i(mergeProgramLocationBlur, blurTextureIndex);  // texture 2 or 3
                    gl.uniform1i(mergeProgramLocationTemperaturePalette, 4);  // texture 4
    
                    gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);
    
                    blurTextureIndex = (blurTextureIndex === 2) ? 3 : 2;  // swap textures 2 and 3
                };
            }
    
            trigger(x, y) {
                // ignore
            }
    
            /**
             *
             * @param changedChunks {boolean[]}
             * @return {void}
             */
            render(changedChunks) {
                this.#doRendering();
            }
    
            /**
             *
             * @param gl {WebGLRenderingContext} The WebGLRenderingContext to use.
             * @param vertexShader {string} vertex shader code
             * @param fragmentShader {string} fragment shader code
             * @return {WebGLProgram}
             */
            #loadProgram(gl, vertexShader, fragmentShader) {
                const program = gl.createProgram();
    
                gl.attachShader(program, this.#loadShader(gl, vertexShader, gl.VERTEX_SHADER));
                gl.bindAttribLocation(program, 0, "a_position");
    
                gl.attachShader(program, this.#loadShader(gl, fragmentShader, gl.FRAGMENT_SHADER));
    
                gl.linkProgram(program);
    
                // Check the link status
                if (!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {
                    // Something went wrong with the link
                    const lastError = gl.getProgramInfoLog(program);
                    throw `Error in program linking: ${lastError}`;
                }
    
                return program;
            }
    
            /**
             *
             * @param gl {WebGLRenderingContext} The WebGLRenderingContext to use.
             * @param shaderSource {string} The shader source.
             * @param shaderType {number} The type of shader.
             * @return {WebGLShader}
             */
            #loadShader(gl, shaderSource, shaderType) {
                // Create the shader object
                const shader = gl.createShader(shaderType);
                if (shader === null) {
                    throw 'Error compiling shader: cannot create shader';
                }
    
                // Load the shader source
                gl.shaderSource(shader, shaderSource);
    
                // Compile the shader
                gl.compileShader(shader);
    
                // Check the compile status
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {
                    // Something went wrong during compilation; get the error
                    const lastError = gl.getShaderInfoLog(shader);
                    throw `Error compiling shader: ${lastError}`;
                }
    
                return shader;
            }
    
            #parsePalette(palette) {
                const colors = palette.split('\n').map(line => line.split(',').map(Number));
                const array = new Uint8Array(colors.length * 4);
                for (let i = 0; i < colors.length; i++) {
                    const color = colors[i];
                    array[i * 4] = color[0];  // r
                    array[i * 4 + 1] = color[1];  // g
                    array[i * 4 + 2] = color[2];  // b
                }
                return array;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * Null renderer. For testing purposes - to measure effects of rendering...
         *
         * @author Patrik Harag
         * @version 2023-10-11
         */
        class RendererNull extends Renderer {
    
            constructor() {
                super();
            }
    
            trigger(x, y) {
                // ignore
            }
    
            render(changedChunks) {
                // ignore
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-06
         */
        class RenderingWebGLException {
    
            #error;
    
            constructor(error) {
                this.#error = error;
            }
    
            getError() {
                return this.#error;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2024-04-06
         */
        class RendererInitializer {
    
            getContextType() {
                throw 'Not implemented'
            }
    
            /**
             *
             * @param elementArea
             * @param chunkSize
             * @param context
             * @return {Renderer}
             */
            initialize(elementArea, chunkSize, context) {
                throw 'Not implemented'
            }
    
            // static factory methods
    
            static canvas2d() {
                return new RendererInitializer2D(null);
            }
    
            static canvas2dHeatmap() {
                return new RendererInitializer2D(new RenderingModeHeatmap());
            }
    
            static canvas2dElementType() {
                return new RendererInitializer2D(new RenderingModeElementType())
            }
    
            static canvasWebGL() {
                return new RendererInitializerWebGL();
            }
    
            static nullRenderer() {
                return new RendererInitializerNull();
            }
        }
    
        class RendererInitializer2D extends RendererInitializer {
    
            #mode;
    
            constructor(mode) {
                super();
                this.#mode = mode;
            }
    
            getContextType() {
                return '2d';
            }
    
            initialize(elementArea, chunkSize, context) {
                let renderer = new Renderer2D(elementArea, chunkSize, context);
                if (this.#mode !== null) {
                    renderer.setMode(this.#mode);
                }
                return renderer;
            }
        }
    
        class RendererInitializerWebGL extends RendererInitializer {
    
            getContextType() {
                return 'webgl2';
            }
    
            initialize(elementArea, chunkSize, context) {
                try {
                    return new RendererWebGL(elementArea, chunkSize, context);
                } catch (e) {
                    throw new RenderingWebGLException(e);
                }
            }
        }
    
        class RendererInitializerNull extends RendererInitializer {
    
            constructor() {
                super();
            }
    
            getContextType() {
                return '2d';
            }
    
            initialize(elementArea, chunkSize, context) {
                return new RendererNull();
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @typedef {object} MarkerConfig
         * @property {CSSStyleDeclaration} style
         * @property {string|HTMLElement} label
         * @property {boolean} visible
         */
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-17
         */
        class Marker {
    
            /** @type number */
            #x1;
            /** @type number */
            #y1;
            /** @type number */
            #x2;
            /** @type number */
            #y2;
    
            /** @type MarkerConfig */
            #config;
    
            /** @type boolean */
            #visible = true;
            /** @type function(boolean)[] */
            #onVisibleChanged = [];
    
            constructor(x1, y1, x2, y2, config) {
                this.#x1 = x1;
                this.#y1 = y1;
                this.#x2 = x2;
                this.#y2 = y2;
                this.#config = config;
                this.#visible = config.visible === true;
            }
    
            getPosition() {
                return [ this.#x1, this.#y1, this.#x2, this.#y2 ];
            }
    
            /**
             *
             * @returns {MarkerConfig}
             */
            getConfig() {
                return this.#config;
            }
    
            // visibility
    
            isVisible() {
                return this.#visible;
            }
    
            setVisible(visible) {
                if (this.#visible !== visible) {
                    // handlers are triggered only on change
                    this.#visible = visible;
                    for (let handler of this.#onVisibleChanged) {
                        handler(visible);
                    }
                }
            }
    
            addOnVisibleChanged(handler) {
                this.#onVisibleChanged.push(handler);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-08
         */
        class SandGameGraphics {
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type SandGameEntities */
            #entities;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type GameDefaults */
            #defaults;
    
            /** @type {function(number,number)} */
            #triggerFunction;
    
            constructor(elementArea, entities, random, defaults, triggerFunction) {
                this.#elementArea = elementArea;
                this.#entities = entities;
                this.#random = random;
                this.#defaults = defaults;
                this.#triggerFunction = triggerFunction;
            }
    
            /**
             *
             * @param aX {number}
             * @param aY {number}
             * @param bX {number}
             * @param bY {number}
             */
            swap(aX, aY, bX, bY) {
                aX = Math.trunc(aX);
                aY = Math.trunc(aY);
                bX = Math.trunc(bX);
                bY = Math.trunc(bY);
    
                if (this.#elementArea.isValidPosition(aX, aY) && this.#elementArea.isValidPosition(bX, bY)) {
                    this.#elementArea.swap(aX, aY, bX, bY);
                    this.#triggerFunction(aX, aY);
                    this.#triggerFunction(bX, bY);
                }
            }
    
            /**
             *
             * @param x {number}
             * @param y {number}
             * @param brushOrElement {Brush|Element|null}
             */
            draw(x, y, brushOrElement) {
                x = Math.trunc(x);
                y = Math.trunc(y);
    
                if (this.#elementArea.isValidPosition(x, y)) {
                    if (brushOrElement === null) {
                        this.#elementArea.setElement(x, y, this.#defaults.getDefaultElement());
                        this.#triggerFunction(x, y);
                    } else if (brushOrElement instanceof Element) {
                        this.#elementArea.setElement(x, y, brushOrElement);
                        this.#triggerFunction(x, y);
                    } else if (brushOrElement instanceof Brush) {
                        let oldElement = this.#elementArea.getElement(x, y);
                        let newElement = brushOrElement.apply(x, y, this.#random, oldElement);
                        this.#elementArea.setElement(x, y, newElement);
                        this.#triggerFunction(x, y);
                    } else {
                        throw 'Brush or Element expected';
                    }
                }
            }
    
            drawRectangle(x1, y1, x2, y2, brushOrElement, supportNegativeCoordinates = false) {
                if (!(brushOrElement instanceof Brush || brushOrElement instanceof Element)) {
                    throw 'Brush expected';
                }
    
                x1 = Math.trunc(x1);
                y1 = Math.trunc(y1);
                x2 = Math.trunc(x2);
                y2 = Math.trunc(y2);
    
                if (supportNegativeCoordinates) {
                    x1 = (x1 >= 0) ? x1 : this.getWidth() + x1 + 1;
                    x2 = (x2 >= 0) ? x2 : this.getWidth() + x2 + 1;
                    y1 = (y1 >= 0) ? y1 : this.getHeight() + y1 + 1;
                    y2 = (y2 >= 0) ? y2 : this.getHeight() + y2 + 1;
                }
    
                x1 = Math.max(Math.min(x1, this.getWidth()), 0);
                x2 = Math.max(Math.min(x2, this.getWidth()), 0);
                y1 = Math.max(Math.min(y1, this.getHeight()), 0);
                y2 = Math.max(Math.min(y2, this.getHeight()), 0);
    
                for (let y = y1; y < y2; y++) {
                    for (let x = x1; x < x2; x++) {
                        this.draw(x, y, brushOrElement);
                    }
                }
            }
    
            drawRectangleWH(x, y, w, h, brush) {
                this.drawRectangle(x, y, x + w, y + h, brush, false);
            }
    
            drawLine(x1, y1, x2, y2, size, brushOrElement, round=false) {
                if (!(brushOrElement instanceof Brush || brushOrElement instanceof Element)) {
                    throw 'Brush expected';
                }
    
                x1 = Math.trunc(x1);
                y1 = Math.trunc(y1);
                x2 = Math.trunc(x2);
                y2 = Math.trunc(y2);
    
                let consumer;
                if (round) {
                    let maxLevel = Math.trunc(size / 2);
    
                    let blueprint;
                    if (maxLevel <= 3) {
                        blueprint = CircleIterator.BLUEPRINT_3;
                    } else if (maxLevel === 4) {
                        blueprint = CircleIterator.BLUEPRINT_4;
                    } else {
                        blueprint = CircleIterator.BLUEPRINT_9;
                    }
    
                    consumer = (x, y) => {
                        CircleIterator.iterate(blueprint, (dx, dy, level) => {
                            if (level <= maxLevel) {
                                this.draw(x + dx, y + dy, brushOrElement);
                            }
                        });
                    };
                } else {
                    const d = Math.ceil(size / 2);
                    consumer = (x, y) => {
                        this.drawRectangle(x - d, y - d, x + d, y + d, brushOrElement);
                    };
                }
    
                SandGameGraphics.#lineAlgorithm(x1, y1, x2, y2, consumer);
            }
    
            static #lineAlgorithm(x1, y1, x2, y2, consumer) {
                consumer(x1, y1);
    
                if ((x1 !== x2) || (y1 !== y2)) {
                    const moveX = x1 < x2 ? 1 : -1;
                    const moveY = y1 < y2 ? 1 : -1;
    
                    const dx = Math.abs(x2 - x1);
                    const dy = Math.abs(y2 - y1);
                    let diff = dx - dy;
    
                    while ((x1 !== x2) || (y1 !== y2)) {
                        const p = 2 * diff;
    
                        if (p > -dy) {
                            diff = diff - dy;
                            x1 = x1 + moveX;
                        }
                        if (p < dx) {
                            diff = diff + dx;
                            y1 = y1 + moveY;
                        }
                        consumer(x1, y1);
                    }
                }
            }
    
            /**
             *
             * @param shape {Marker}
             * @param brushOrElement {Brush|Element}
             */
            drawShape(shape, brushOrElement) {
                if (shape instanceof Marker) {
                    const [x1, y1, x2, y2] = shape.getPosition();
                    this.drawRectangle(x1, y1, x2, y2, brushOrElement, false);
                } else {
                    throw 'Shape not supported';
                }
            }
    
            fill(brush) {
                this.drawRectangle(0, 0, this.#elementArea.getWidth(), this.#elementArea.getHeight(), brush);
            }
    
            floodFill(x, y, brush, neighbourhood) {
                x = Math.trunc(x);
                y = Math.trunc(y);
    
                let floodFillPainter = new FloodFillPainter(this.#elementArea, neighbourhood, this);
                floodFillPainter.paint(x, y, brush);
            }
    
            replace(elementTarget, elementReplacement) {
                const width = this.getWidth();
                const height = this.getHeight();
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const next = this.#elementArea.getElement(x, y);
                        if (next.elementHead === elementTarget.elementHead && next.elementTail === elementTarget.elementTail) {
                            this.#elementArea.setElement(x, y, elementReplacement);
                        }
                    }
                }
            }
    
            flipVertically() {
                const width = this.getWidth();
                const height = this.getHeight();
                const halfHeight = Math.trunc(height / 2);
                for (let x = 0; x < width; x++) {
                    for (let yd = 0; yd < halfHeight; yd++) {
                        this.swap(x, yd, x, height - yd - 1);
                    }
                }
            }
    
            flipHorizontally() {
                const width = this.getWidth();
                const height = this.getHeight();
                const halfWidth = Math.trunc(width / 2);
                for (let y = 0; y < height; y++) {
                    for (let xd = 0; xd < halfWidth; xd++) {
                        this.swap(xd, y, width - xd - 1, y);
                    }
                }
            }
    
            insertElementArea(elementArea, offsetX = 0, offsetY = 0) {
                for (let y = 0; y < elementArea.getHeight(); y++) {
                    for (let x = 0; x < elementArea.getWidth(); x++) {
                        if (this.#elementArea.isValidPosition(x + offsetX, y + offsetY)) {
                            const elementHead = elementArea.getElementHead(x, y);
                            const elementTail = elementArea.getElementTail(x, y);
                            this.#elementArea.setElementHeadAndTail(x + offsetX, y + offsetY, elementHead, elementTail);
                            this.#triggerFunction(x + offsetX, y + offsetY);
                        }
                    }
                }
            }
    
            getWidth() {
                return this.#elementArea.getWidth();
            }
    
            getHeight() {
                return this.#elementArea.getHeight();
            }
    
            entities() {
                return this.#entities;
            }
    
            getDefaults() {
                return this.#defaults;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * Public API for working with entities.
         *
         * @author Patrik Harag
         * @version 2024-05-04
         */
        class SandGameEntities {
    
            /** @type number */
            #width;
            /** @type number */
            #height;
    
            /** @type EntityManager */
            #entityManager;
    
            /** @type {function(number,number)} */
            #triggerFunction;
    
            constructor(width, height, entityManager, triggerFunction) {
                this.#width = width;
                this.#height = height;
                this.#entityManager = entityManager;
                this.#triggerFunction = triggerFunction;
            }
    
            insertEntity(serializedEntity) {
                if (serializedEntity instanceof Entity) {
                    throw 'Entity instance not supported here';
                }
    
                // check is not out of bounds
                if (typeof serializedEntity.y === 'number') {
                    if (serializedEntity.y < 0 || serializedEntity.y >= this.#height) {
                        return;  // out of bounds
                    }
                }
                if (typeof serializedEntity.x === 'number') {
                    if (serializedEntity.x < 0 || serializedEntity.x >= this.#width) {
                        return;  // out of bounds
                    }
                }
    
                this.#entityManager.addSerializedEntity(serializedEntity);
    
                if (typeof serializedEntity.x === 'number' && typeof serializedEntity.y === 'number') {
                    this.#triggerFunction(serializedEntity.x, serializedEntity.y);
                }
            }
    
            // TODO: hide _elementArea, etc.
            /**
             *
             * @param x
             * @param y
             * @returns {Entity[]}
             */
            getAt(x, y) {
                return this.#entityManager.getAt(x, y);
            }
    
            assignWaypoint(x, y) {
                for (const entity of this.#entityManager.getEntities()) {
                    if (typeof entity.assignWaypoint === 'function') {
                        entity.assignWaypoint(x, y);
                    }
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-08
         */
        class SandGameOverlay {
    
            /** @type number */
            #width;
            /** @type number */
            #height;
    
            /** @type Marker[] */
            #markers = [];
    
            /** @type function(Marker)[] */
            #onMarkerAdded = [];
    
            constructor(width, height) {
                this.#width = width;
                this.#height = height;
            }
    
            /**
             *
             * @param x1
             * @param y1
             * @param x2
             * @param y2
             * @param config {MarkerConfig}
             * @param supportNegativeCoordinates {boolean}
             * @returns {Marker}
             */
            createRectangle(x1, y1, x2, y2, config, supportNegativeCoordinates = false) {
                x1 = Math.trunc(x1);
                y1 = Math.trunc(y1);
                x2 = Math.trunc(x2);
                y2 = Math.trunc(y2);
    
                if (supportNegativeCoordinates) {
                    x1 = (x1 >= 0) ? x1 : this.#width + x1 + 1;
                    x2 = (x2 >= 0) ? x2 : this.#width + x2 + 1;
                    y1 = (y1 >= 0) ? y1 : this.#height + y1 + 1;
                    y2 = (y2 >= 0) ? y2 : this.#height + y2 + 1;
                }
    
                x1 = Math.max(Math.min(x1, this.#width - 1), 0);
                x2 = Math.max(Math.min(x2, this.#width - 1), 0);
                y1 = Math.max(Math.min(y1, this.#height - 1), 0);
                y2 = Math.max(Math.min(y2, this.#height - 1), 0);
    
                const marker = new Marker(x1, y1, x2, y2, config);
                this.#markers.push(marker);
                for (let handler of this.#onMarkerAdded) {
                    handler(marker);
                }
    
                return marker;
            }
    
            createRectangleWH(x, y, w, h, cssStyles) {
                return this.createRectangle(x, y, x + w, y + h, cssStyles);
            }
    
            /**
             *
             * @returns {Marker[]}
             */
            getMarkers() {
                return [...this.#markers];
            }
    
            addOnMarkerAdded(handler) {
                this.#onMarkerAdded.push(handler);
            }
    
            getWidth() {
                return this.#width;
            }
    
            getHeight() {
                return this.#height
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @typedef {object} SplashConfig
         * @property {HTMLElement|string} content
         * @property {CSSStyleDeclaration} style
         * @property {SplashButton[]} buttons
         * @property {boolean} visible
         */
        /**
         * @typedef {object} SplashButton
         * @property {string} title
         * @property {string} class
         * @property {boolean} focus
         * @property {function(Splash):void} action
         */
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-13
         */
        class Splash {
    
            /** @type SplashConfig */
            #config;
    
            /** @type boolean */
            #visible;
            /** @type function(boolean)[] */
            #onVisibleChanged = [];
    
            /**
             *
             * @param config {SplashConfig}
             */
            constructor(config) {
                this.#config = config;
                this.#visible = config.visible === true;
            }
    
            getConfig() {
                return this.#config;  // TODO: immutable
            }
    
            // visibility
    
            isVisible() {
                return this.#visible;
            }
    
            setVisible(visible) {
                if (this.#visible !== visible) {
                    // handlers are triggered only on change
                    this.#visible = visible;
                    for (let handler of this.#onVisibleChanged) {
                        handler(visible);
                    }
                }
            }
    
            addOnVisibleChanged(handler) {
                this.#onVisibleChanged.push(handler);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @typedef {object} ObjectiveConfig
         * @property {string} name
         * @property {string} description
         * @property {boolean} visible
         * @property {boolean} active
         * @property {function(iteration:number)} checkHandler
         */
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-13
         */
        class Objective {
    
            /** @type ObjectiveConfig */
            #config;
    
            /** @type boolean */
            #visible;
            /** @type function(boolean)[] */
            #onVisibleChanged = [];
    
            /** @type boolean */
            #active;
            /** @type function(boolean)[] */
            #onActiveChanged = [];
    
            /** @type boolean */
            #completed = false;
            /** @type function(boolean)[] */
            #onCompletedChanged = [];
    
            /**
             *
             * @param config {ObjectiveConfig}
             */
            constructor(config) {
                this.#config = config;
                this.#visible = config.visible === true;
                this.#active = config.active === true;
            }
    
            getConfig() {
                return this.#config;  // TODO: immutable
            }
    
            // visible
    
            isVisible() {
                return this.#visible;
            }
    
            setVisible(visible) {
                if (this.#visible !== visible) {
                    // handlers are triggered only on change
                    this.#visible = visible;
                    for (let handler of this.#onVisibleChanged) {
                        handler(visible);
                    }
                }
            }
    
            addOnVisibleChanged(handler) {
                this.#onVisibleChanged.push(handler);
            }
    
            // active
    
            isActive() {
                return this.#active;
            }
    
            setActive(active) {
                if (this.#active !== active) {
                    // handlers are triggered only on change
                    this.#active = active;
                    for (let handler of this.#onActiveChanged) {
                        handler(active);
                    }
                }
            }
    
            addOnActiveChanged(handler) {
                this.#onActiveChanged.push(handler);
            }
    
            // status
    
            isCompleted() {
                return this.#completed;
            }
    
            setCompleted(completed) {
                if (this.#completed !== completed) {
                    // handlers are triggered only on change
                    this.#completed = completed;
                    for (let handler of this.#onCompletedChanged) {
                        handler(completed);
                    }
                }
            }
    
            addOnCompleted(handler) {
                this.#onCompletedChanged.push(handler);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-11
         */
        class SandGameScenario {
    
            /** @type Splash[] */
            #splashes = [];
    
            /** @type function(Splash)[] */
            #onSplashAdded = [];
    
            /** @type Objective[] */
            #objectives = [];
    
            /** @type function(Objective)[] */
            #onObjectiveAdded = [];
    
            #statusCompleted = false;
    
            /** @type function()[] */
            #onStatusCompleted = [];
    
            constructor() {
                // empty
            }
    
            // splash
    
            /**
             *
             * @param config {SplashConfig}
             * @returns {Splash}
             */
            createSplash(config) {
                const splash = new Splash(config);
                this.#splashes.push(splash);
                for (let handler of this.#onSplashAdded) {
                    handler(splash);
                }
                return splash;
            }
    
            getSplashes() {
                return [...this.#splashes];
            }
    
            /**
             *
             * @param handler {function(Splash)}
             */
            addOnSplashAdded(handler) {
                this.#onSplashAdded.push(handler);
            }
    
            // objectives
    
            /**
             *
             * @param config {ObjectiveConfig}
             * @returns {Objective}
             */
            createObjective(config) {
                const objective = new Objective(config);
                this.#objectives.push(objective);
                for (let handler of this.#onObjectiveAdded) {
                    handler(objective);
                }
                return objective;
            }
    
            getObjectives() {
                return [...this.#objectives];
            }
    
            /**
             *
             * @param handler {function(Objective)}
             */
            addOnObjectiveAdded(handler) {
                this.#onObjectiveAdded.push(handler);
            }
    
            // status
    
            setCompleted() {
                if (!this.#statusCompleted) {
                    this.#statusCompleted = true;
                    Analytics.triggerFeatureUsed(Analytics.FEATURE_SCENARIO_COMPLETED);
                    for (let handler of this.#onStatusCompleted) {
                        handler();
                    }
                }
            }
    
            addOnStatusCompleted(handler) {
                this.#onStatusCompleted.push(handler);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class Snapshot {
    
            /** @type SnapshotMetadata */
            metadata;
    
            /** @type ArrayBuffer */
            dataHeads;
    
            /** @type ArrayBuffer */
            dataTails;
    
            /** @type object[] */
            serializedEntities;
    
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class SnapshotMetadata {
    
            static CURRENT_FORMAT_VERSION = 7;
    
    
            /** @type number */
            formatVersion;
    
            /** @type string */
            appVersion;
    
            /** @type number|undefined */
            created;
    
            /** @type number|undefined */
            width;
    
            /** @type number|undefined */
            height;
    
            /** @type number|undefined */
            scale;
    
            /** @type number|undefined */
            random;
    
            /** @type number|undefined */
            iteration;
    
            /** @type boolean|undefined */
            fallThroughEnabled;
    
            /** @type boolean|undefined */
            erasingEnabled;
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2022-09-21
         */
        class TemplateBlockPainter {
    
            /** @type SandGameGraphics */
            #graphics;
    
            /** @type string|string[]|null */
            #blueprint = null;
            /** @type object|null */
            #brushes = null;
    
            /** @type number */
            #maxHeight = Number.MAX_SAFE_INTEGER;
    
            /** @type string */
            #verticalAlign = 'bottom';
    
            /**
             *
             * @param graphics {SandGameGraphics}
             */
            constructor(graphics) {
                this.#graphics = graphics;
            }
    
            /**
             *
             * @param blueprint {string|string[]}
             * @returns {TemplateBlockPainter}
             */
            withBlueprint(blueprint) {
                this.#blueprint = blueprint;
                return this;
            }
    
            /**
             *
             * @param brushes
             * @returns {TemplateBlockPainter}
             */
            withBrushes(brushes) {
                this.#brushes = brushes;
                return this;
            }
    
            /**
             *
             * @param maxHeight max template height
             * @param align {string} bottom|top
             * @returns {TemplateBlockPainter}
             */
            withMaxHeight(maxHeight, align = 'bottom') {
                this.#maxHeight = maxHeight;
                this.#verticalAlign = align;
                return this;
            }
    
            paint() {
                if (this.#blueprint === null || this.#blueprint.length === 0) {
                    throw 'Blueprint not set';
                }
                if (this.#brushes === null) {
                    throw 'Brushes not set';
                }
    
                const blueprint = (typeof this.#blueprint === 'string')
                    ? this.#blueprint.split('\n')
                    : this.#blueprint;
    
                const w = blueprint[0].length;
                const h = blueprint.length;
    
                const ww = Math.ceil(this.#graphics.getWidth() / w);
                const hh = Math.ceil(Math.min(this.#graphics.getHeight(), this.#maxHeight) / h);
                // note: rounding up is intentional - we don't want gaps, drawRectangle can handle drawing out of canvas
    
                const verticalOffset = (this.#verticalAlign === 'bottom' ? this.#graphics.getHeight() - (hh * h) : 0);
    
                for (let y = 0; y < h; y++) {
                    const line = blueprint[y];
                    for (let x = 0; x < Math.min(w, line.length); x++) {
                        const char = line.charAt(x);
                        let brush = this.#brushes[char];
                        if (brush === undefined) {
                            if (char === ' ') {
                                // let this cell empty
                                continue;
                            }
                            throw 'Brush not found: ' + char;
                        }
                        this.#graphics.drawRectangle(
                            x * ww, verticalOffset + (y * hh),
                            x * ww + ww + 1, verticalOffset + (y * hh) + hh + 1, brush);
                    }
                }
            }
        }
    
        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
    
        var cubicSpline = class Spline {
          constructor(xs, ys) {
            this.xs = xs;
            this.ys = ys;
            this.ks = this.getNaturalKs(new Float64Array(this.xs.length));
          }
    
          getNaturalKs(ks) {
            const n = this.xs.length - 1;
            const A = zerosMat(n + 1, n + 2);
    
            for (
              let i = 1;
              i < n;
              i++ // rows
            ) {
              A[i][i - 1] = 1 / (this.xs[i] - this.xs[i - 1]);
              A[i][i] =
                2 *
                (1 / (this.xs[i] - this.xs[i - 1]) + 1 / (this.xs[i + 1] - this.xs[i]));
              A[i][i + 1] = 1 / (this.xs[i + 1] - this.xs[i]);
              A[i][n + 1] =
                3 *
                ((this.ys[i] - this.ys[i - 1]) /
                  ((this.xs[i] - this.xs[i - 1]) * (this.xs[i] - this.xs[i - 1])) +
                  (this.ys[i + 1] - this.ys[i]) /
                    ((this.xs[i + 1] - this.xs[i]) * (this.xs[i + 1] - this.xs[i])));
            }
    
            A[0][0] = 2 / (this.xs[1] - this.xs[0]);
            A[0][1] = 1 / (this.xs[1] - this.xs[0]);
            A[0][n + 1] =
              (3 * (this.ys[1] - this.ys[0])) /
              ((this.xs[1] - this.xs[0]) * (this.xs[1] - this.xs[0]));
    
            A[n][n - 1] = 1 / (this.xs[n] - this.xs[n - 1]);
            A[n][n] = 2 / (this.xs[n] - this.xs[n - 1]);
            A[n][n + 1] =
              (3 * (this.ys[n] - this.ys[n - 1])) /
              ((this.xs[n] - this.xs[n - 1]) * (this.xs[n] - this.xs[n - 1]));
    
            return solve(A, ks);
          }
    
          /**
           * inspired by https://stackoverflow.com/a/40850313/4417327
           */
          getIndexBefore(target) {
            let low = 0;
            let high = this.xs.length;
            let mid = 0;
            while (low < high) {
              mid = Math.floor((low + high) / 2);
              if (this.xs[mid] < target && mid !== low) {
                low = mid;
              } else if (this.xs[mid] >= target && mid !== high) {
                high = mid;
              } else {
                high = low;
              }
            }
            return low + 1;
          }
    
          at(x) {
            let i = this.getIndexBefore(x);
            const t = (x - this.xs[i - 1]) / (this.xs[i] - this.xs[i - 1]);
            const a =
              this.ks[i - 1] * (this.xs[i] - this.xs[i - 1]) -
              (this.ys[i] - this.ys[i - 1]);
            const b =
              -this.ks[i] * (this.xs[i] - this.xs[i - 1]) +
              (this.ys[i] - this.ys[i - 1]);
            const q =
              (1 - t) * this.ys[i - 1] +
              t * this.ys[i] +
              t * (1 - t) * (a * (1 - t) + b * t);
            return q;
          }
        };
    
        function solve(A, ks) {
          const m = A.length;
          let h = 0;
          let k = 0;
          while (h < m && k <= m) {
            let i_max = 0;
            let max = -Infinity;
            for (let i = h; i < m; i++) {
              const v = Math.abs(A[i][k]);
              if (v > max) {
                i_max = i;
                max = v;
              }
            }
    
            if (A[i_max][k] === 0) {
              k++;
            } else {
              swapRows(A, h, i_max);
              for (let i = h + 1; i < m; i++) {
                const f = A[i][k] / A[h][k];
                A[i][k] = 0;
                for (let j = k + 1; j <= m; j++) A[i][j] -= A[h][j] * f;
              }
              h++;
              k++;
            }
          }
    
          for (
            let i = m - 1;
            i >= 0;
            i-- // rows = columns
          ) {
            var v = 0;
            if (A[i][i]) {
              v = A[i][m] / A[i][i];
            }
            ks[i] = v;
            for (
              let j = i - 1;
              j >= 0;
              j-- // rows
            ) {
              A[j][m] -= A[j][i] * v;
              A[j][i] = 0;
            }
          }
          return ks;
        }
    
        function zerosMat(r, c) {
          const A = [];
          for (let i = 0; i < r; i++) A.push(new Float64Array(c));
          return A;
        }
    
        function swapRows(m, k, l) {
          let p = m[k];
          m[k] = m[l];
          m[l] = p;
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class TemplateLayeredPainter {
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type SandGameGraphics */
            #graphics;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type ProcessorContext */
            #processorContext;
    
            #lastLevel;
    
            /**
             *
             * @param elementArea {ElementArea}
             * @param graphics {SandGameGraphics}
             * @param random {DeterministicRandom}
             * @param processorContext {ProcessorContext}
             */
            constructor(elementArea, graphics, random, processorContext) {
                this.#elementArea = elementArea;
                this.#graphics = graphics;
                this.#random = random;
                this.#processorContext = processorContext;
                this.#lastLevel = new Array(elementArea.getWidth()).fill(0);
            }
    
            /**
             *
             * @param constant {number}
             * @param relative {boolean}
             * @param brush {Brush}
             * @param shuffleWithLevelBelow {number}
             * @returns {TemplateLayeredPainter}
             */
            layer(constant, relative, brush, shuffleWithLevelBelow = 0) {
                function func(x) {
                    return Math.trunc(constant);
                }
    
                this.layerFunction(func, relative, brush, shuffleWithLevelBelow);
                return this;
            }
    
            /**
             *
             * @param points {[number,number][]}
             * @param relative {boolean}
             * @param brush {Brush}
             * @param shuffleWithLevelBelow {number}
             * @returns {TemplateLayeredPainter}
             */
            layerSpline(points, relative, brush, shuffleWithLevelBelow = 0) {
                const xs = new Array(points.length);
                const ys = new Array(points.length);
                for (let i = 0; i < points.length; i++) {
                    xs[i] = points[i][0];
                    ys[i] = points[i][1];
                }
                const spline = new cubicSpline(xs, ys);
                function func (x) {
                    return Math.max(Math.trunc(spline.at(x)), 0);
                }
    
                this.layerFunction(func, relative, brush, shuffleWithLevelBelow);
                return this;
            }
    
            /**
             *
             * @param config {{seed:number,factor:number,threshold:number,force:number}[]}
             * @param relative {boolean}
             * @param brush {Brush}
             * @param shuffleWithLevelBelow {number}
             * @returns {TemplateLayeredPainter}
             */
            layerPerlin(config, relative, brush, shuffleWithLevelBelow = 0) {
                const levels = [];
                for (let levelConfig of config) {
                    if (levelConfig.seed === undefined) {
                        DeterministicRandom.DEFAULT.next();
                        levelConfig.seed = DeterministicRandom.DEFAULT.getState();
                    }
                    if (levelConfig.factor === undefined) {
                        throw 'factor not defined';
                    }
                    if (levelConfig.threshold === undefined) {
                        throw 'threshold not defined';
                    }
                    if (levelConfig.force === undefined) {
                        throw 'force not defined';
                    }
    
                    const random = new DeterministicRandom(levelConfig.seed);
                    const noise2d = createNoise2D(() => random.next());
    
                    levels.push({ instance: noise2d, levelConfig: levelConfig });
                }
    
                function func(x) {
                    let result = 0;
                    for (const { instance, levelConfig } of levels) {
                        const { factor, threshold, force } = levelConfig;
    
                        let value = (instance(x / factor, 0) + 1) / 2;  // 0..1
    
                        // apply threshold
                        if (value < threshold) {
                            value = 0;
                        }
                        value = (value - threshold) * (1 / (1 - threshold));  // normalized 0..1
    
                        // apply force
                        value = value * force;
    
                        result += value;
                    }
                    return Math.trunc(result);
                }
    
                this.layerFunction(func, relative, brush, shuffleWithLevelBelow);
                return this;
            }
    
            /**
             *
             * @param func {function(x:number):number}
             * @param relative {boolean}
             * @param brush {Brush}
             * @param shuffleWithLevelBelow {number}
             * @returns {TemplateLayeredPainter}
             */
            layerFunction(func, relative, brush, shuffleWithLevelBelow = 0) {
                for (let x = 0; x < this.#elementArea.getWidth(); x++) {
                    const lastLevel = this.#lastLevel[x];
    
                    const level = (relative)
                            ? lastLevel + func(x)
                            : func(x);
    
                    if (lastLevel < level) {
                        let count = 0;
                        for (let i = lastLevel; i < level && i < this.#elementArea.getHeight(); i++) {
                            let y = this.#elementArea.getHeight() - 1 - i;
                            this.#graphics.draw(x, y, brush);
                            count++;
                        }
    
                        // shuffle
                        if (shuffleWithLevelBelow > 0 && count > 0) {
                            for (let i = 0; i < shuffleWithLevelBelow; i++) {
                                const max = Math.min(Math.trunc(count / 2), 10);
                                if (max > 1) {
                                    const r = this.#random.nextInt(Math.ceil(max)) - Math.trunc(max / 2);
                                    const y1 = this.#elementArea.getHeight() - 1 - lastLevel + r;
                                    const y2 = this.#elementArea.getHeight() - 1 - lastLevel + r + 1;
                                    if (y1 < this.#elementArea.getHeight() && y2 < this.#elementArea.getHeight()) {
                                        this.#elementArea.swap(x, y1, x, y2);
                                    }
                                }
                            }
                        }
    
                        this.#lastLevel[x] = level;
                    }
                }
                return this;
            }
    
            grass(from = 0, to = -1) {
                if (to === -1) {
                    to = this.#elementArea.getWidth();
                }
                for (let x = from; x < to; x++) {
                    const lastLevel = this.#lastLevel[x];
                    const y = this.#elementArea.getHeight() - 1 - lastLevel;
    
                    if (ProcessorModuleGrass.canGrowUpHere(this.#elementArea, x, y)) {
                        const brush = this.#processorContext.getDefaults().getBrushGrass();
                        ProcessorModuleGrass.spawnHere(this.#elementArea, x, y, brush, this.#random);
                    }
                }
    
                // TODO: update lastLevel
                return this;
            }
    
            tree(x, type = undefined, levelsToGrow = undefined, force = false) {
                if (x <= 5 || x >= this.#elementArea.getWidth() - 5) {
                    return this;  // out of bounds
                }
    
                const lastLevel = this.#lastLevel[x];
                const y = this.#elementArea.getHeight() - 1 - lastLevel;
    
                const brush = this.#processorContext.getDefaults().getBrushTree();
    
                // check element under
                if (this.#elementArea.isValidPosition(x, y + 1)) {
                    if (!force) {
                        const elementHeadUnder = this.#elementArea.getElementHead(x, y + 1);
                        if (ElementHead.getBehaviour(elementHeadUnder) !== ElementHead.BEHAVIOUR_SOIL) {
                            return this;
                        }
                    }
                } else {
                    return this;
                }
    
                if (type === undefined) {
                    type = this.#random.nextInt(8);
                }
    
                ProcessorModuleTree.spawnHere(this.#elementArea, x, y, type, brush, this.#random, this.#processorContext, levelsToGrow);
    
                // TODO: update lastLevel
                return this;
            }
    
            tool(x, relativeY, tool) {
                if (x < 0 || x >= this.#elementArea.getWidth()) {
                    return this;  // out of bounds
                }
    
                const lastLevel = this.#lastLevel[x];
                const y = this.#elementArea.getHeight() - relativeY - lastLevel;
                if (y < 0 || y >= this.#elementArea.getHeight()) {
                    return this;  // out of bounds
                }
    
                tool.applyPoint(x, y, this.#graphics, false);
    
                // TODO: update lastLevel
                return this;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-04
         */
        class SandGame {
    
            /** @type ElementArea */
            #elementArea;
    
            /** @type number */
            #width;
    
            /** @type number */
            #height;
    
            /** @type EntityManager */
            #entityManager;
    
            /** @type DeterministicRandom */
            #random;
    
            /** @type Counter */
            #framesCounter;
    
            /** @type Counter */
            #iterationsCounter;
    
            /** @type Processor */
            #processor;
    
            /** @type Renderer */
            #renderer;
    
            /** @type number|null */
            #processorIntervalHandle = null;
    
            /** @type number|null */
            #rendererIntervalHandle = null;
    
            /** @type function[] */
            #onRendered = [];
            /** @type function[] */
            #onRenderingFailed = [];
    
            /** @type function(number)[] */
            #onProcessed = [];
    
            /** @type SandGameGraphics */
            #graphics;
    
            /** @type SandGameEntities */
            #entities;
    
            /** @type SandGameOverlay */
            #overlay;
    
            /** @type SandGameScenario */
            #scenario;
    
            /**
             *
             * @param elementArea {ElementArea}
             * @param serializedEntities {object[]}
             * @param sceneMetadata {SnapshotMetadata|null}
             * @param gameDefaults {GameDefaults}
             * @param context {CanvasRenderingContext2D|WebGLRenderingContext}
             * @param rendererInitializer {RendererInitializer}
             */
            constructor(elementArea, serializedEntities, sceneMetadata, gameDefaults,
                    context, rendererInitializer) {
    
                this.#random = new DeterministicRandom((sceneMetadata) ? sceneMetadata.random : 0);
                this.#elementArea = elementArea;
                this.#width = elementArea.getWidth();
                this.#height = elementArea.getHeight();
                this.#framesCounter = new Counter();
                this.#iterationsCounter = new Counter();
                this.#processor = new Processor(this.#elementArea, 16, this.#random, gameDefaults, sceneMetadata);
                this.#renderer = rendererInitializer.initialize(this.#elementArea, 16, context);
                this.#entityManager = new EntityManager(serializedEntities, new GameState(elementArea, this.#random, this.#processor, null));
                const triggerFunction = (x, y) => {
                    this.#processor.trigger(x, y);
                    this.#renderer.trigger(x, y);
                };
                this.#entities = new SandGameEntities(elementArea.getWidth(), elementArea.getHeight(), this.#entityManager, triggerFunction);
                this.#graphics = new SandGameGraphics(this.#elementArea, this.#entities, this.#random, gameDefaults, triggerFunction);
                this.#overlay = new SandGameOverlay(elementArea.getWidth(), elementArea.getHeight());
                this.#scenario = new SandGameScenario();
    
                this.#initExtensions(gameDefaults);
                this.#initObjectives();
            }
    
            #initObjectives() {
                let activeObjectives = [];
                const updateActiveObjectives = () => {
                    activeObjectives = this.#scenario.getObjectives().filter(o => {
                        return o.isActive() && (typeof o.getConfig().checkHandler === 'function');
                    });
                };
    
                this.#scenario.addOnObjectiveAdded(objective => {
                    updateActiveObjectives();
                    objective.addOnActiveChanged(() => updateActiveObjectives());
                    objective.addOnCompleted(() => updateActiveObjectives());
                });
                this.#onProcessed.push(() => {
                    for (let objective of activeObjectives) {
                        objective.getConfig().checkHandler(this.#processor.getIteration() - 1);
                    }
                });
            }
    
            #initExtensions(gameDefaults) {
                const gameState = new GameState(this.#elementArea, this.#random, this.#processor, this.#entityManager);
                const extensionsFactory = gameDefaults.getExtensionsFactory();
                const extensions = extensionsFactory(gameState);
                for (const extension of extensions) {
                    this.#processor.addExtension(extension);
                }
            }
    
            getBrushCollection() {
                return this.#processor.getDefaults().getBrushCollection();
            }
    
            startProcessing() {
                if (this.#processorIntervalHandle === null) {
                    const interval = Math.trunc(1000 / Processor.OPT_CYCLES_PER_SECOND);  // ms
                    this.#processorIntervalHandle = setInterval(() => this.doProcessing(), interval);
                }
            }
    
            startRendering() {
                if (this.#rendererIntervalHandle === null) {
                    const interval = Math.trunc(1000 / Processor.OPT_FRAMES_PER_SECOND);  // ms
                    this.#rendererIntervalHandle = setInterval(() => this.doRendering(), interval);
                }
            }
    
            stopProcessing() {
                if (this.#processorIntervalHandle !== null) {
                    clearInterval(this.#processorIntervalHandle);
                    this.#processorIntervalHandle = null;
                }
                this.#iterationsCounter.clear();
            }
    
            stopRendering() {
                if (this.#rendererIntervalHandle !== null) {
                    clearInterval(this.#rendererIntervalHandle);
                    this.#rendererIntervalHandle = null;
                }
                this.#framesCounter.clear();
            }
    
            doProcessing() {
                // TODO: error reporting
    
                this.#entityManager.performBeforeProcessing();
                this.#processor.next();
                this.#entityManager.performAfterProcessing();
    
                const t = Date.now();
                this.#iterationsCounter.tick(t);
                for (let func of this.#onProcessed) {
                    func(this.#processor.getIteration());
                }
            }
    
            doRendering() {
                const changedChunks = this.#processor.getChangedChunks();
                try {
                    this.#renderer.render(changedChunks);
                } catch (e) {
                    this.stopRendering();
                    for (let func of this.#onRenderingFailed) {
                        func(e);
                    }
                    return;
                }
                const t = Date.now();
                this.#framesCounter.tick(t);
                for (let func of this.#onRendered) {
                    func(changedChunks);
                }
                this.#processor.cleanChangedChunks();
            }
    
            /**
             *
             * @returns {SandGameGraphics}
             */
            graphics() {
                return this.#graphics;
            }
    
            /**
             *
             * @returns {SandGameEntities}
             */
            entities() {
                return this.#entities;
            }
    
            /**
             *
             * @returns {SandGameOverlay}
             */
            overlay() {
                return this.#overlay;
            }
    
            /**
             *
             * @returns {SandGameScenario}
             */
            scenario() {
                return this.#scenario;
            }
    
            /**
             *
             * @returns {TemplateBlockPainter}
             */
            blockTemplate() {
                return new TemplateBlockPainter(this.graphics());
            }
    
            /**
             *
             * @returns {TemplateLayeredPainter}
             */
            layeredTemplate() {
                return new TemplateLayeredPainter(this.#elementArea, this.graphics(), this.#random, this.#processor);
            }
    
            setBoxedMode() {
                this.#processor.setFallThroughEnabled(false);
                this.#processor.setErasingEnabled(false);
            }
    
            setFallThroughMode() {
                this.#processor.setFallThroughEnabled(true);
                this.#processor.setErasingEnabled(false);
            }
    
            setErasingMode() {
                this.#processor.setFallThroughEnabled(false);
                this.#processor.setErasingEnabled(true);
            }
    
            /**
             *
             * @param handler {function(iteration:number)}
             */
            addOnProcessed(handler) {
                this.#onProcessed.push(handler);
            }
    
            addOnRendered(handler) {
                this.#onRendered.push(handler);
            }
    
            addOnRenderingFailed(handler) {
                this.#onRenderingFailed.push(handler);
            }
    
            getFramesPerSecond() {
                return this.#framesCounter.getValue();
            }
    
            getIterationsPerSecond() {
                return this.#iterationsCounter.getValue();
            }
    
            getWidth() {
                return this.#width;
            }
    
            getHeight() {
                return this.#height;
            }
    
            getChunkSize() {
                return 16;
            }
    
            /**
             * @returns {Snapshot}
             */
            createSnapshot() {
                let metadata = new SnapshotMetadata();
                metadata.formatVersion = SnapshotMetadata.CURRENT_FORMAT_VERSION;
                metadata.created = new Date().getTime();
                metadata.width = this.#width;
                metadata.height = this.#height;
                metadata.random = this.#random.getState();
                metadata.iteration = this.#processor.getIteration();
                metadata.fallThroughEnabled = this.#processor.isFallThroughEnabled();
                metadata.erasingEnabled = this.#processor.isErasingEnabled();
    
                let snapshot = new Snapshot();
                snapshot.metadata = metadata;
                snapshot.dataHeads = this.#elementArea.getDataHeads();
                snapshot.dataTails = this.#elementArea.getDataTails();
                snapshot.serializedEntities = this.#entityManager.serializeEntities();
                return snapshot;
            }
    
            debugElementAt(x, y) {
                if (!this.#elementArea.isValidPosition(x, y)) {
                    return 'Out of bounds';
                }
    
                const elementHead = this.#elementArea.getElementHead(x, y);
                const elementTail = this.#elementArea.getElementTail(x, y);
    
                function toHex(n) {
                    let t = n.toString(16).padStart(8, '0');
                    return '0x' + t;
                }
                let hex = toHex(elementHead) + ' ' + toHex(elementTail);
    
                const json = {
                    type: {
                        class: ElementHead.getTypeClass(elementHead),
                    },
                    behaviour: {
                        type: ElementHead.getBehaviour(elementHead),
                        special: ElementHead.getSpecial(elementHead)
                    },
                    heatModIndex: ElementHead.getHeatModIndex(elementHead),
                    temperature: ElementHead.getTemperature(elementHead),
                    color: [
                        ElementTail.getColorRed(elementTail),
                        ElementTail.getColorGreen(elementTail),
                        ElementTail.getColorBlue(elementTail)
                    ],
                    blurType: ElementTail.getBlurType(elementTail),
                    burntLevel: ElementTail.getBurntLevel(elementTail),
                    heatEffect: ElementTail.getHeatEffect(elementTail)
                };
    
                if (json.type.class === ElementHead.TYPE_STATIC) {
                    json.type.neighbourhood = ElementHead.getTypeModifierSolidNeighbourhoodType(elementHead);
                    json.type.body = ElementHead.getTypeModifierSolidBodyId(elementHead);
                }
    
                let structure = JSON.stringify(json)
                        .replaceAll('"', '')
                        .replaceAll(',', ', ')
                        .replaceAll(':', '=');
                structure = structure.substring(1, structure.length - 1);  // remove {}
    
                return hex + '\n' + structure;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2024-05-08
         */
        class Scene {
    
            /**
             * @returns [width: number, height: number]
             */
            countSize(prefWidth, prefHeight) {
                throw 'Not implemented';
            }
    
            /**
             * @param prefWidth {number}
             * @param prefHeight {number}
             * @param defaults {GameDefaults}
             * @param context {CanvasRenderingContext2D|WebGLRenderingContext}
             * @param rendererInitializer {RendererInitializer}
             * @returns Promise<SandGame>
             */
            createSandGame(prefWidth, prefHeight, defaults, context, rendererInitializer) {
                throw 'Not implemented';
            }
    
            /**
             * @param prefWidth
             * @param prefHeight
             * @param defaultElement
             * @returns ElementArea
             */
            createElementArea(prefWidth, prefHeight, defaultElement) {
                throw 'Not implemented';
            }
    
            /**
             * Creates entities in serialized state.
             * It may not be supported, but it doesn't mean that there are none - they man be generated in createSandGame.
             *
             * @returns {object[]}
             */
            createEntities() {
                return null;
            }
    
            executeOnOpened(sandGame) {
                // no action by default
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class SceneImplTmpResize extends Scene {
    
            /**
             * @type Snapshot
             */
            #snapshot;
    
            constructor(snapshot) {
                super();
                this.#snapshot = snapshot;
            }
    
            countSize(prefWidth, prefHeight) {
                return [prefWidth, prefHeight];
            }
    
            async createSandGame(prefWidth, prefHeight, defaults, context, rendererInitializer) {
                const oldWidth = this.#snapshot.metadata.width;
                const oldHeight = this.#snapshot.metadata.height;
                const oldMetadata = this.#snapshot.metadata;
                const oldElementArea = ElementArea.from(oldWidth, oldHeight, this.#snapshot.dataHeads, this.#snapshot.dataTails);
                const oldSerializedEntities = this.#snapshot.serializedEntities;
    
                const newElementArea = this.createElementArea(prefWidth, prefHeight, defaults.getDefaultElement());
                const newSandGame = new SandGame(newElementArea, [], oldMetadata, defaults, context, rendererInitializer);
    
                let offsetY;
                if (prefHeight === oldHeight) {
                    offsetY = 0;
                } else if (prefHeight > oldHeight) {
                    offsetY = prefHeight - oldHeight;
                } else {
                    offsetY = -(oldHeight - prefHeight);
                }
    
                // copy elements
                newSandGame.graphics().insertElementArea(oldElementArea, 0, offsetY);
    
                // copy entities
                for (let serializedEntity of oldSerializedEntities) {
                    // map entity position
                    const serializedClone = Object.assign({}, serializedEntity);
                    if (offsetY !== 0) {
                        if (typeof serializedClone.y === 'number') {
                            serializedClone.y += offsetY;
                        }
                    }
                    newSandGame.entities().insertEntity(serializedClone);
                }
    
                return newSandGame;
            }
    
            createElementArea(prefWidth, prefHeight, defaultElement) {
                return ElementArea.create(prefWidth, prefHeight, defaultElement);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-15
         */
        class ServiceToolManager {
    
            #primaryTool;
            #secondaryTool;
            #tertiaryTool;
    
            /** @type function(Tool)[] */
            #onPrimaryToolChanged = [];
    
    
            /** @type boolean */
            #inputDisabled;
            /** @type function(boolean)[] */
            #onInputDisabledChanged = [];
    
            constructor(primaryTool, secondaryTool, tertiaryTool) {
                this.#primaryTool = primaryTool;
                this.#secondaryTool = secondaryTool;
                this.#tertiaryTool = tertiaryTool;
            }
    
            /**
             *
             * @param tool {Tool}
             * @returns void
             */
            setPrimaryTool(tool) {
                this.#primaryTool = tool;
                for (let handler of this.#onPrimaryToolChanged) {
                    handler(tool);
                }
            }
    
            /**
             *
             * @param tool {Tool}
             * @returns void
             */
            setSecondaryTool(tool) {
                this.#secondaryTool = tool;
            }
    
            /**
             *
             * @param tool {Tool}
             * @returns void
             */
            setTertiaryTool(tool) {
                this.#tertiaryTool = tool;
            }
    
            /**
             * @returns {Tool}
             */
            getPrimaryTool() {
                return this.#primaryTool;
            }
    
            /**
             * @returns {Tool}
             */
            getSecondaryTool() {
                return this.#secondaryTool;
            }
    
            /**
             * @returns {Tool}
             */
            getTertiaryTool() {
                return this.#tertiaryTool;
            }
    
            /**
             *
             * @param handler {function(Tool)}
             */
            addOnPrimaryToolChanged(handler) {
                this.#onPrimaryToolChanged.push(handler);
            }
    
            /**
             *
             * @returns {boolean}
             */
            isInputDisabled() {
                return this.#inputDisabled;
            }
    
            /**
             *
             * @param handler {function(boolean)}
             */
            addOnInputDisabledChanged(handler) {
                this.#onInputDisabledChanged.push(handler);
            }
    
            setInputDisabled(disabled) {
                if (this.#inputDisabled !== disabled) {
                    this.#inputDisabled = disabled;
                    for (let handler of this.#onInputDisabledChanged) {
                        handler(disabled);
                    }
                }
            }
    
            createRevertAction() {
                const oldPrimary = this.getPrimaryTool();
                const oldSecondary = this.getSecondaryTool();
                const oldTertiary = this.getTertiaryTool();
                return () => {
                    this.setPrimaryTool(oldPrimary);
                    this.setSecondaryTool(oldSecondary);
                    this.setTertiaryTool(oldTertiary);
                };
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class SceneImplSnapshot extends Scene {
    
            /**
             * @type Snapshot
             */
            #snapshot;
    
            /**
             *
             * @param snapshot {Snapshot}
             */
            constructor(snapshot) {
                super();
                this.#snapshot = snapshot;
            }
    
            countSize(prefWidth, prefHeight) {
                return [this.#snapshot.metadata.width, this.#snapshot.metadata.height];
            }
    
            async createSandGame(prefWidth, prefHeight, defaults, context, rendererInitializer) {
                const elementArea = this.createElementArea(prefWidth, prefHeight, defaults.getDefaultElement());
                const serializedEntities = this.createEntities();
                const metadata = this.#snapshot.metadata;
                return new SandGame(elementArea, serializedEntities, metadata, defaults, context, rendererInitializer);
            }
    
            createElementArea(prefWidth, prefHeight, defaultElement) {
                return ElementArea.from(
                        this.#snapshot.metadata.width,
                        this.#snapshot.metadata.height,
                        this.#snapshot.dataHeads,
                        this.#snapshot.dataTails);
            }
    
            createEntities() {
                return this.#snapshot.serializedEntities;
            }
        }
    
        // DEFLATE is a complex format; to read this code, you should probably check the RFC first:
    
        // aliases for shorter compressed code (most minifers don't do this)
        var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
        // fixed length extra bits
        var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
        // fixed distance extra bits
        // see fleb note
        var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
        // code length index map
        var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        // get base, reverse index map from extra bits
        var freb = function (eb, start) {
            var b = new u16(31);
            for (var i = 0; i < 31; ++i) {
                b[i] = start += 1 << eb[i - 1];
            }
            // numbers here are at max 18 bits
            var r = new u32(b[30]);
            for (var i = 1; i < 30; ++i) {
                for (var j = b[i]; j < b[i + 1]; ++j) {
                    r[j] = ((j - b[i]) << 5) | i;
                }
            }
            return [b, r];
        };
        var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
        // we can ignore the fact that the other numbers are wrong; they never happen anyway
        fl[28] = 258, revfl[258] = 28;
        var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
        // map of value to reverse (assuming 16 bits)
        var rev = new u16(32768);
        for (var i = 0; i < 32768; ++i) {
            // reverse table algorithm from SO
            var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);
            x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);
            x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);
            rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;
        }
        // create huffman tree from u8 "map": index -> code length for code index
        // mb (max bits) must be at most 15
        // TODO: optimize/split up?
        var hMap = (function (cd, mb, r) {
            var s = cd.length;
            // index
            var i = 0;
            // u16 "map": index -> # of codes with bit length = index
            var l = new u16(mb);
            // length of cd must be 288 (total # of codes)
            for (; i < s; ++i) {
                if (cd[i])
                    ++l[cd[i] - 1];
            }
            // u16 "map": index -> minimum code for bit length = index
            var le = new u16(mb);
            for (i = 0; i < mb; ++i) {
                le[i] = (le[i - 1] + l[i - 1]) << 1;
            }
            var co;
            if (r) {
                // u16 "map": index -> number of actual bits, symbol for code
                co = new u16(1 << mb);
                // bits to remove for reverser
                var rvb = 15 - mb;
                for (i = 0; i < s; ++i) {
                    // ignore 0 lengths
                    if (cd[i]) {
                        // num encoding both symbol and bits read
                        var sv = (i << 4) | cd[i];
                        // free bits
                        var r_1 = mb - cd[i];
                        // start value
                        var v = le[cd[i] - 1]++ << r_1;
                        // m is end value
                        for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                            // every 16 bit value starting with the code yields the same result
                            co[rev[v] >>> rvb] = sv;
                        }
                    }
                }
            }
            else {
                co = new u16(s);
                for (i = 0; i < s; ++i) {
                    if (cd[i]) {
                        co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);
                    }
                }
            }
            return co;
        });
        // fixed length tree
        var flt = new u8(288);
        for (var i = 0; i < 144; ++i)
            flt[i] = 8;
        for (var i = 144; i < 256; ++i)
            flt[i] = 9;
        for (var i = 256; i < 280; ++i)
            flt[i] = 7;
        for (var i = 280; i < 288; ++i)
            flt[i] = 8;
        // fixed distance tree
        var fdt = new u8(32);
        for (var i = 0; i < 32; ++i)
            fdt[i] = 5;
        // fixed length map
        var flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);
        // fixed distance map
        var fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
        // find max of array
        var max = function (a) {
            var m = a[0];
            for (var i = 1; i < a.length; ++i) {
                if (a[i] > m)
                    m = a[i];
            }
            return m;
        };
        // read d, starting at bit p and mask with m
        var bits = function (d, p, m) {
            var o = (p / 8) | 0;
            return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
        };
        // read d, starting at bit p continuing for at least 16 bits
        var bits16 = function (d, p) {
            var o = (p / 8) | 0;
            return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
        };
        // get end of byte
        var shft = function (p) { return ((p + 7) / 8) | 0; };
        // typed array slice - allows garbage collector to free original reference,
        // while being more compatible than .slice
        var slc = function (v, s, e) {
            if (s == null || s < 0)
                s = 0;
            if (e == null || e > v.length)
                e = v.length;
            // can't use .constructor in case user-supplied
            var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);
            n.set(v.subarray(s, e));
            return n;
        };
        // error codes
        var ec = [
            'unexpected EOF',
            'invalid block type',
            'invalid length/literal',
            'invalid distance',
            'stream finished',
            'no stream handler',
            ,
            'no callback',
            'invalid UTF-8 data',
            'extra field too long',
            'date not in range 1980-2099',
            'filename too long',
            'stream finishing',
            'invalid zip data'
            // determined by unknown compression method
        ];
        var err = function (ind, msg, nt) {
            var e = new Error(msg || ec[ind]);
            e.code = ind;
            if (Error.captureStackTrace)
                Error.captureStackTrace(e, err);
            if (!nt)
                throw e;
            return e;
        };
        // expands raw DEFLATE data
        var inflt = function (dat, buf, st) {
            // source length
            var sl = dat.length;
            if (!sl || (st && st.f && !st.l))
                return buf || new u8(0);
            // have to estimate size
            var noBuf = !buf || st;
            // no state
            var noSt = !st || st.i;
            if (!st)
                st = {};
            // Assumes roughly 33% compression ratio average
            if (!buf)
                buf = new u8(sl * 3);
            // ensure buffer can fit at least l elements
            var cbuf = function (l) {
                var bl = buf.length;
                // need to increase size to fit
                if (l > bl) {
                    // Double or set to necessary, whichever is greater
                    var nbuf = new u8(Math.max(bl * 2, l));
                    nbuf.set(buf);
                    buf = nbuf;
                }
            };
            //  last chunk         bitpos           bytes
            var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
            // total bits
            var tbts = sl * 8;
            do {
                if (!lm) {
                    // BFINAL - this is only 1 when last chunk is next
                    final = bits(dat, pos, 1);
                    // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
                    var type = bits(dat, pos + 1, 3);
                    pos += 3;
                    if (!type) {
                        // go to end of byte boundary
                        var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                        if (t > sl) {
                            if (noSt)
                                err(0);
                            break;
                        }
                        // ensure size
                        if (noBuf)
                            cbuf(bt + l);
                        // Copy over uncompressed data
                        buf.set(dat.subarray(s, t), bt);
                        // Get new bitpos, update byte count
                        st.b = bt += l, st.p = pos = t * 8, st.f = final;
                        continue;
                    }
                    else if (type == 1)
                        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
                    else if (type == 2) {
                        //  literal                            lengths
                        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                        var tl = hLit + bits(dat, pos + 5, 31) + 1;
                        pos += 14;
                        // length+distance tree
                        var ldt = new u8(tl);
                        // code length tree
                        var clt = new u8(19);
                        for (var i = 0; i < hcLen; ++i) {
                            // use index map to get real code
                            clt[clim[i]] = bits(dat, pos + i * 3, 7);
                        }
                        pos += hcLen * 3;
                        // code lengths bits
                        var clb = max(clt), clbmsk = (1 << clb) - 1;
                        // code lengths map
                        var clm = hMap(clt, clb, 1);
                        for (var i = 0; i < tl;) {
                            var r = clm[bits(dat, pos, clbmsk)];
                            // bits read
                            pos += r & 15;
                            // symbol
                            var s = r >>> 4;
                            // code length to copy
                            if (s < 16) {
                                ldt[i++] = s;
                            }
                            else {
                                //  copy   count
                                var c = 0, n = 0;
                                if (s == 16)
                                    n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                                else if (s == 17)
                                    n = 3 + bits(dat, pos, 7), pos += 3;
                                else if (s == 18)
                                    n = 11 + bits(dat, pos, 127), pos += 7;
                                while (n--)
                                    ldt[i++] = c;
                            }
                        }
                        //    length tree                 distance tree
                        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                        // max length bits
                        lbt = max(lt);
                        // max dist bits
                        dbt = max(dt);
                        lm = hMap(lt, lbt, 1);
                        dm = hMap(dt, dbt, 1);
                    }
                    else
                        err(1);
                    if (pos > tbts) {
                        if (noSt)
                            err(0);
                        break;
                    }
                }
                // Make sure the buffer can hold this + the largest possible addition
                // Maximum chunk size (practically, theoretically infinite) is 2^17;
                if (noBuf)
                    cbuf(bt + 131072);
                var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
                var lpos = pos;
                for (;; lpos = pos) {
                    // bits read, code
                    var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
                    pos += c & 15;
                    if (pos > tbts) {
                        if (noSt)
                            err(0);
                        break;
                    }
                    if (!c)
                        err(2);
                    if (sym < 256)
                        buf[bt++] = sym;
                    else if (sym == 256) {
                        lpos = pos, lm = null;
                        break;
                    }
                    else {
                        var add = sym - 254;
                        // no extra bits needed if less
                        if (sym > 264) {
                            // index
                            var i = sym - 257, b = fleb[i];
                            add = bits(dat, pos, (1 << b) - 1) + fl[i];
                            pos += b;
                        }
                        // dist
                        var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                        if (!d)
                            err(3);
                        pos += d & 15;
                        var dt = fd[dsym];
                        if (dsym > 3) {
                            var b = fdeb[dsym];
                            dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;
                        }
                        if (pos > tbts) {
                            if (noSt)
                                err(0);
                            break;
                        }
                        if (noBuf)
                            cbuf(bt + 131072);
                        var end = bt + add;
                        for (; bt < end; bt += 4) {
                            buf[bt] = buf[bt - dt];
                            buf[bt + 1] = buf[bt + 1 - dt];
                            buf[bt + 2] = buf[bt + 2 - dt];
                            buf[bt + 3] = buf[bt + 3 - dt];
                        }
                        bt = end;
                    }
                }
                st.l = lm, st.p = lpos, st.b = bt, st.f = final;
                if (lm)
                    final = 1, st.m = lbt, st.d = dm, st.n = dbt;
            } while (!final);
            return bt == buf.length ? buf : slc(buf, 0, bt);
        };
        // starting at p, write the minimum number of bits that can hold v to d
        var wbits = function (d, p, v) {
            v <<= p & 7;
            var o = (p / 8) | 0;
            d[o] |= v;
            d[o + 1] |= v >>> 8;
        };
        // starting at p, write the minimum number of bits (>8) that can hold v to d
        var wbits16 = function (d, p, v) {
            v <<= p & 7;
            var o = (p / 8) | 0;
            d[o] |= v;
            d[o + 1] |= v >>> 8;
            d[o + 2] |= v >>> 16;
        };
        // creates code lengths from a frequency table
        var hTree = function (d, mb) {
            // Need extra info to make a tree
            var t = [];
            for (var i = 0; i < d.length; ++i) {
                if (d[i])
                    t.push({ s: i, f: d[i] });
            }
            var s = t.length;
            var t2 = t.slice();
            if (!s)
                return [et, 0];
            if (s == 1) {
                var v = new u8(t[0].s + 1);
                v[t[0].s] = 1;
                return [v, 1];
            }
            t.sort(function (a, b) { return a.f - b.f; });
            // after i2 reaches last ind, will be stopped
            // freq must be greater than largest possible number of symbols
            t.push({ s: -1, f: 25001 });
            var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
            t[0] = { s: -1, f: l.f + r.f, l: l, r: r };
            // efficient algorithm from UZIP.js
            // i0 is lookbehind, i2 is lookahead - after processing two low-freq
            // symbols that combined have high freq, will start processing i2 (high-freq,
            // non-composite) symbols instead
            // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
            while (i1 != s - 1) {
                l = t[t[i0].f < t[i2].f ? i0++ : i2++];
                r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
                t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };
            }
            var maxSym = t2[0].s;
            for (var i = 1; i < s; ++i) {
                if (t2[i].s > maxSym)
                    maxSym = t2[i].s;
            }
            // code lengths
            var tr = new u16(maxSym + 1);
            // max bits in tree
            var mbt = ln(t[i1 - 1], tr, 0);
            if (mbt > mb) {
                // more algorithms from UZIP.js
                // TODO: find out how this code works (debt)
                //  ind    debt
                var i = 0, dt = 0;
                //    left            cost
                var lft = mbt - mb, cst = 1 << lft;
                t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });
                for (; i < s; ++i) {
                    var i2_1 = t2[i].s;
                    if (tr[i2_1] > mb) {
                        dt += cst - (1 << (mbt - tr[i2_1]));
                        tr[i2_1] = mb;
                    }
                    else
                        break;
                }
                dt >>>= lft;
                while (dt > 0) {
                    var i2_2 = t2[i].s;
                    if (tr[i2_2] < mb)
                        dt -= 1 << (mb - tr[i2_2]++ - 1);
                    else
                        ++i;
                }
                for (; i >= 0 && dt; --i) {
                    var i2_3 = t2[i].s;
                    if (tr[i2_3] == mb) {
                        --tr[i2_3];
                        ++dt;
                    }
                }
                mbt = mb;
            }
            return [new u8(tr), mbt];
        };
        // get the max length and assign length codes
        var ln = function (n, l, d) {
            return n.s == -1
                ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))
                : (l[n.s] = d);
        };
        // length codes generation
        var lc = function (c) {
            var s = c.length;
            // Note that the semicolon was intentional
            while (s && !c[--s])
                ;
            var cl = new u16(++s);
            //  ind      num         streak
            var cli = 0, cln = c[0], cls = 1;
            var w = function (v) { cl[cli++] = v; };
            for (var i = 1; i <= s; ++i) {
                if (c[i] == cln && i != s)
                    ++cls;
                else {
                    if (!cln && cls > 2) {
                        for (; cls > 138; cls -= 138)
                            w(32754);
                        if (cls > 2) {
                            w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);
                            cls = 0;
                        }
                    }
                    else if (cls > 3) {
                        w(cln), --cls;
                        for (; cls > 6; cls -= 6)
                            w(8304);
                        if (cls > 2)
                            w(((cls - 3) << 5) | 8208), cls = 0;
                    }
                    while (cls--)
                        w(cln);
                    cls = 1;
                    cln = c[i];
                }
            }
            return [cl.subarray(0, cli), s];
        };
        // calculate the length of output from tree, code lengths
        var clen = function (cf, cl) {
            var l = 0;
            for (var i = 0; i < cl.length; ++i)
                l += cf[i] * cl[i];
            return l;
        };
        // writes a fixed block
        // returns the new bit pos
        var wfblk = function (out, pos, dat) {
            // no need to write 00 as type: TypedArray defaults to 0
            var s = dat.length;
            var o = shft(pos + 2);
            out[o] = s & 255;
            out[o + 1] = s >>> 8;
            out[o + 2] = out[o] ^ 255;
            out[o + 3] = out[o + 1] ^ 255;
            for (var i = 0; i < s; ++i)
                out[o + i + 4] = dat[i];
            return (o + 4 + s) * 8;
        };
        // writes a block
        var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
            wbits(out, p++, final);
            ++lf[256];
            var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];
            var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];
            var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
            var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
            var lcfreq = new u16(19);
            for (var i = 0; i < lclt.length; ++i)
                lcfreq[lclt[i] & 31]++;
            for (var i = 0; i < lcdt.length; ++i)
                lcfreq[lcdt[i] & 31]++;
            var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
            var nlcc = 19;
            for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
                ;
            var flen = (bl + 5) << 3;
            var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
            var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
            if (flen <= ftlen && flen <= dtlen)
                return wfblk(out, p, dat.subarray(bs, bs + bl));
            var lm, ll, dm, dl;
            wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
            if (dtlen < ftlen) {
                lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
                var llm = hMap(lct, mlcb, 0);
                wbits(out, p, nlc - 257);
                wbits(out, p + 5, ndc - 1);
                wbits(out, p + 10, nlcc - 4);
                p += 14;
                for (var i = 0; i < nlcc; ++i)
                    wbits(out, p + 3 * i, lct[clim[i]]);
                p += 3 * nlcc;
                var lcts = [lclt, lcdt];
                for (var it = 0; it < 2; ++it) {
                    var clct = lcts[it];
                    for (var i = 0; i < clct.length; ++i) {
                        var len = clct[i] & 31;
                        wbits(out, p, llm[len]), p += lct[len];
                        if (len > 15)
                            wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;
                    }
                }
            }
            else {
                lm = flm, ll = flt, dm = fdm, dl = fdt;
            }
            for (var i = 0; i < li; ++i) {
                if (syms[i] > 255) {
                    var len = (syms[i] >>> 18) & 31;
                    wbits16(out, p, lm[len + 257]), p += ll[len + 257];
                    if (len > 7)
                        wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];
                    var dst = syms[i] & 31;
                    wbits16(out, p, dm[dst]), p += dl[dst];
                    if (dst > 3)
                        wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];
                }
                else {
                    wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
                }
            }
            wbits16(out, p, lm[256]);
            return p + ll[256];
        };
        // deflate options (nice << 13) | chain
        var deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
        // empty
        var et = /*#__PURE__*/ new u8(0);
        // compresses data into a raw DEFLATE buffer
        var dflt = function (dat, lvl, plvl, pre, post, lst) {
            var s = dat.length;
            var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
            // writing to this writes to the output buffer
            var w = o.subarray(pre, o.length - post);
            var pos = 0;
            if (!lvl || s < 8) {
                for (var i = 0; i <= s; i += 65535) {
                    // end
                    var e = i + 65535;
                    if (e >= s) {
                        // write final block
                        w[pos >> 3] = lst;
                    }
                    pos = wfblk(w, pos + 1, dat.subarray(i, e));
                }
            }
            else {
                var opt = deo[lvl - 1];
                var n = opt >>> 13, c = opt & 8191;
                var msk_1 = (1 << plvl) - 1;
                //    prev 2-byte val map    curr 2-byte val map
                var prev = new u16(32768), head = new u16(msk_1 + 1);
                var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
                var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };
                // 24576 is an arbitrary number of maximum symbols per block
                // 424 buffer for last block
                var syms = new u32(25000);
                // length/literal freq   distance freq
                var lf = new u16(288), df = new u16(32);
                //  l/lcnt  exbits  index  l/lind  waitdx  bitpos
                var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;
                for (; i < s; ++i) {
                    // hash value
                    // deopt when i > s - 3 - at end, deopt acceptable
                    var hv = hsh(i);
                    // index mod 32768    previous index mod
                    var imod = i & 32767, pimod = head[hv];
                    prev[imod] = pimod;
                    head[hv] = imod;
                    // We always should modify head and prev, but only add symbols if
                    // this data is not yet processed ("wait" for wait index)
                    if (wi <= i) {
                        // bytes remaining
                        var rem = s - i;
                        if ((lc_1 > 7000 || li > 24576) && rem > 423) {
                            pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                            li = lc_1 = eb = 0, bs = i;
                            for (var j = 0; j < 286; ++j)
                                lf[j] = 0;
                            for (var j = 0; j < 30; ++j)
                                df[j] = 0;
                        }
                        //  len    dist   chain
                        var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;
                        if (rem > 2 && hv == hsh(i - dif)) {
                            var maxn = Math.min(n, rem) - 1;
                            var maxd = Math.min(32767, i);
                            // max possible length
                            // not capped at dif because decompressors implement "rolling" index population
                            var ml = Math.min(258, rem);
                            while (dif <= maxd && --ch_1 && imod != pimod) {
                                if (dat[i + l] == dat[i + l - dif]) {
                                    var nl = 0;
                                    for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                                        ;
                                    if (nl > l) {
                                        l = nl, d = dif;
                                        // break out early when we reach "nice" (we are satisfied enough)
                                        if (nl > maxn)
                                            break;
                                        // now, find the rarest 2-byte sequence within this
                                        // length of literals and search for that instead.
                                        // Much faster than just using the start
                                        var mmd = Math.min(dif, nl - 2);
                                        var md = 0;
                                        for (var j = 0; j < mmd; ++j) {
                                            var ti = (i - dif + j + 32768) & 32767;
                                            var pti = prev[ti];
                                            var cd = (ti - pti + 32768) & 32767;
                                            if (cd > md)
                                                md = cd, pimod = ti;
                                        }
                                    }
                                }
                                // check the previous match
                                imod = pimod, pimod = prev[imod];
                                dif += (imod - pimod + 32768) & 32767;
                            }
                        }
                        // d will be nonzero only when a match was found
                        if (d) {
                            // store both dist and len data in one Uint32
                            // Make sure this is recognized as a len/dist with 28th bit (2^28)
                            syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];
                            var lin = revfl[l] & 31, din = revfd[d] & 31;
                            eb += fleb[lin] + fdeb[din];
                            ++lf[257 + lin];
                            ++df[din];
                            wi = i + l;
                            ++lc_1;
                        }
                        else {
                            syms[li++] = dat[i];
                            ++lf[dat[i]];
                        }
                    }
                }
                pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
                // this is the easiest way to avoid needing to maintain state
                if (!lst && pos & 7)
                    pos = wfblk(w, pos + 1, et);
            }
            return slc(o, 0, pre + shft(pos) + post);
        };
        // CRC32 table
        var crct = /*#__PURE__*/ (function () {
            var t = new Int32Array(256);
            for (var i = 0; i < 256; ++i) {
                var c = i, k = 9;
                while (--k)
                    c = ((c & 1) && -306674912) ^ (c >>> 1);
                t[i] = c;
            }
            return t;
        })();
        // CRC32
        var crc = function () {
            var c = -1;
            return {
                p: function (d) {
                    // closures have awful performance
                    var cr = c;
                    for (var i = 0; i < d.length; ++i)
                        cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);
                    c = cr;
                },
                d: function () { return ~c; }
            };
        };
        // deflate with opts
        var dopt = function (dat, opt, pre, post, st) {
            return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);
        };
        // Walmart object spread
        var mrg = function (a, b) {
            var o = {};
            for (var k in a)
                o[k] = a[k];
            for (var k in b)
                o[k] = b[k];
            return o;
        };
        // read 2 bytes
        var b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };
        // read 4 bytes
        var b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };
        var b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };
        // write bytes
        var wbytes = function (d, b, v) {
            for (; v; ++b)
                d[b] = v, v >>>= 8;
        };
        /**
         * Compresses data with DEFLATE without any wrapper
         * @param data The data to compress
         * @param opts The compression options
         * @returns The deflated version of the data
         */
        function deflateSync(data, opts) {
            return dopt(data, opts || {}, 0, 0);
        }
        /**
         * Expands DEFLATE data with no wrapper
         * @param data The data to decompress
         * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
         * @returns The decompressed version of the data
         */
        function inflateSync(data, out) {
            return inflt(data, out);
        }
        // flatten a directory structure
        var fltn = function (d, p, t, o) {
            for (var k in d) {
                var val = d[k], n = p + k, op = o;
                if (Array.isArray(val))
                    op = mrg(o, val[1]), val = val[0];
                if (val instanceof u8)
                    t[n] = [val, op];
                else {
                    t[n += '/'] = [new u8(0), op];
                    fltn(val, n, t, o);
                }
            }
        };
        // text encoder
        var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();
        // text decoder
        var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
        // text decoder stream
        var tds = 0;
        try {
            td.decode(et, { stream: true });
            tds = 1;
        }
        catch (e) { }
        // decode UTF8
        var dutf8 = function (d) {
            for (var r = '', i = 0;;) {
                var c = d[i++];
                var eb = (c > 127) + (c > 223) + (c > 239);
                if (i + eb > d.length)
                    return [r, slc(d, i - 1)];
                if (!eb)
                    r += String.fromCharCode(c);
                else if (eb == 3) {
                    c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,
                        r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));
                }
                else if (eb & 1)
                    r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));
                else
                    r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));
            }
        };
        /**
         * Converts a string into a Uint8Array for use with compression/decompression methods
         * @param str The string to encode
         * @param latin1 Whether or not to interpret the data as Latin-1. This should
         *               not need to be true unless decoding a binary string.
         * @returns The string encoded in UTF-8/Latin-1 binary
         */
        function strToU8(str, latin1) {
            if (latin1) {
                var ar_1 = new u8(str.length);
                for (var i = 0; i < str.length; ++i)
                    ar_1[i] = str.charCodeAt(i);
                return ar_1;
            }
            if (te)
                return te.encode(str);
            var l = str.length;
            var ar = new u8(str.length + (str.length >> 1));
            var ai = 0;
            var w = function (v) { ar[ai++] = v; };
            for (var i = 0; i < l; ++i) {
                if (ai + 5 > ar.length) {
                    var n = new u8(ai + 8 + ((l - i) << 1));
                    n.set(ar);
                    ar = n;
                }
                var c = str.charCodeAt(i);
                if (c < 128 || latin1)
                    w(c);
                else if (c < 2048)
                    w(192 | (c >> 6)), w(128 | (c & 63));
                else if (c > 55295 && c < 57344)
                    c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),
                        w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));
                else
                    w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));
            }
            return slc(ar, 0, ai);
        }
        /**
         * Converts a Uint8Array to a string
         * @param dat The data to decode to string
         * @param latin1 Whether or not to interpret the data as Latin-1. This should
         *               not need to be true unless encoding to binary string.
         * @returns The original UTF-8/Latin-1 string
         */
        function strFromU8(dat, latin1) {
            if (latin1) {
                var r = '';
                for (var i = 0; i < dat.length; i += 16384)
                    r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
                return r;
            }
            else if (td)
                return td.decode(dat);
            else {
                var _a = dutf8(dat), out = _a[0], ext = _a[1];
                if (ext.length)
                    err(8);
                return out;
            }
        }
        // skip local zip header
        var slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };
        // read zip header
        var zh = function (d, b, z) {
            var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
            var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];
            return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
        };
        // read zip64 extra field
        var z64e = function (d, b) {
            for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
                ;
            return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
        };
        // extra field length
        var exfl = function (ex) {
            var le = 0;
            if (ex) {
                for (var k in ex) {
                    var l = ex[k].length;
                    if (l > 65535)
                        err(9);
                    le += l + 4;
                }
            }
            return le;
        };
        // write zip header
        var wzh = function (d, b, f, fn, u, c, ce, co) {
            var fl = fn.length, ex = f.extra, col = co && co.length;
            var exl = exfl(ex);
            wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
            if (ce != null)
                d[b++] = 20, d[b++] = f.os;
            d[b] = 20, b += 2; // spec compliance? what's that?
            d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;
            d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
            var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
            if (y < 0 || y > 119)
                err(10);
            wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;
            if (c != -1) {
                wbytes(d, b, f.crc);
                wbytes(d, b + 4, c < 0 ? -c - 2 : c);
                wbytes(d, b + 8, f.size);
            }
            wbytes(d, b + 12, fl);
            wbytes(d, b + 14, exl), b += 16;
            if (ce != null) {
                wbytes(d, b, col);
                wbytes(d, b + 6, f.attrs);
                wbytes(d, b + 10, ce), b += 14;
            }
            d.set(fn, b);
            b += fl;
            if (exl) {
                for (var k in ex) {
                    var exf = ex[k], l = exf.length;
                    wbytes(d, b, +k);
                    wbytes(d, b + 2, l);
                    d.set(exf, b + 4), b += 4 + l;
                }
            }
            if (col)
                d.set(co, b), b += col;
            return b;
        };
        // write zip footer (end of central directory)
        var wzf = function (o, b, c, d, e) {
            wbytes(o, b, 0x6054B50); // skip disk
            wbytes(o, b + 8, c);
            wbytes(o, b + 10, c);
            wbytes(o, b + 12, d);
            wbytes(o, b + 16, e);
        };
        /**
         * Synchronously creates a ZIP file. Prefer using `zip` for better performance
         * with more than one file.
         * @param data The directory structure for the ZIP archive
         * @param opts The main options, merged with per-file options
         * @returns The generated ZIP archive
         */
        function zipSync(data, opts) {
            if (!opts)
                opts = {};
            var r = {};
            var files = [];
            fltn(data, '', r, opts);
            var o = 0;
            var tot = 0;
            for (var fn in r) {
                var _a = r[fn], file = _a[0], p = _a[1];
                var compression = p.level == 0 ? 0 : 8;
                var f = strToU8(fn), s = f.length;
                var com = p.comment, m = com && strToU8(com), ms = m && m.length;
                var exl = exfl(p.extra);
                if (s > 65535)
                    err(11);
                var d = compression ? deflateSync(file, p) : file, l = d.length;
                var c = crc();
                c.p(file);
                files.push(mrg(p, {
                    size: file.length,
                    crc: c.d(),
                    c: d,
                    f: f,
                    m: m,
                    u: s != fn.length || (m && (com.length != ms)),
                    o: o,
                    compression: compression
                }));
                o += 30 + s + exl + l;
                tot += 76 + 2 * (s + exl) + (ms || 0) + l;
            }
            var out = new u8(tot + 22), oe = o, cdl = tot - o;
            for (var i = 0; i < files.length; ++i) {
                var f = files[i];
                wzh(out, f.o, f, f.f, f.u, f.c.length);
                var badd = 30 + f.f.length + exfl(f.extra);
                out.set(f.c, f.o + badd);
                wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
            }
            wzf(out, o, files.length, cdl, oe);
            return out;
        }
        /**
         * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
         * performance with more than one file.
         * @param data The raw compressed ZIP file
         * @param opts The ZIP extraction options
         * @returns The decompressed files
         */
        function unzipSync(data, opts) {
            var files = {};
            var e = data.length - 22;
            for (; b4(data, e) != 0x6054B50; --e) {
                if (!e || data.length - e > 65558)
                    err(13);
            }
            var c = b2(data, e + 8);
            if (!c)
                return {};
            var o = b4(data, e + 16);
            var z = o == 4294967295 || c == 65535;
            if (z) {
                var ze = b4(data, e - 12);
                z = b4(data, ze) == 0x6064B50;
                if (z) {
                    c = b4(data, ze + 32);
                    o = b4(data, ze + 48);
                }
            }
            var fltr = opts && opts.filter;
            for (var i = 0; i < c; ++i) {
                var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
                o = no;
                if (!fltr || fltr({
                    name: fn,
                    size: sc,
                    originalSize: su,
                    compression: c_2
                })) {
                    if (!c_2)
                        files[fn] = slc(data, b, b + sc);
                    else if (c_2 == 8)
                        files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));
                    else
                        err(14, 'unknown compression type ' + c_2);
                }
            }
            return files;
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class ResourceSnapshot {
    
            static METADATA_JSON_NAME = 'snapshot.json';
            static LEGACY_METADATA_JSON_NAME = 'metadata.json';
    
            /**
             *
             * @param snapshot {Snapshot}
             * @returns Uint8Array
             */
            static createZip(snapshot) {
                const metadata = strToU8(JSON.stringify(snapshot.metadata, null, 2));
                const entities = strToU8(JSON.stringify(snapshot.serializedEntities, null, 2));
    
                let zipData = {
                    'snapshot.json': metadata,
                    'data-heads.bin': new Uint8Array(snapshot.dataHeads),
                    'data-tails.bin': new Uint8Array(snapshot.dataTails),
                    'data-entities.json': entities,
                };
                return zipSync(zipData, {level: 9});
            }
    
            /**
             *
             * @param zip {{[path: string]: Uint8Array}}
             * @returns Snapshot
             */
            static parse(zip) {
                function parseJson(fileName) {
                    return JSON.parse(strFromU8(zip[fileName]));
                }
    
                // load metadata
                let metadataJson;
                if (zip[ResourceSnapshot.METADATA_JSON_NAME]) {
                    // snapshot | legacy snapshot
                    metadataJson = parseJson(ResourceSnapshot.METADATA_JSON_NAME);
                } else if (zip[ResourceSnapshot.LEGACY_METADATA_JSON_NAME]) {
                    // legacy snapshot
                    metadataJson = parseJson(ResourceSnapshot.LEGACY_METADATA_JSON_NAME);
                } else {
                    throw 'Metadata not found';
                }
                let snapshot = new Snapshot();
                snapshot.metadata = Object.assign(new SnapshotMetadata(), metadataJson);
    
                if (typeof snapshot.metadata.width !== "number") {
                    throw 'Metadata property wrong format: width';
                }
                if (typeof snapshot.metadata.height !== "number") {
                    throw 'Metadata property wrong format: height';
                }
    
                // load element data
                if (snapshot.metadata.formatVersion < 3) {
                    // ensure backward compatibility
                    // legacy interleaving buffer (element head 1, element tail 1, element head 2, element tail 2, ...)
                    const dataRaw = zip['data.bin'];
                    if (dataRaw) {
                        if (dataRaw.byteLength % 8 !== 0) {
                            throw 'Buffer length is not divisible by 8';
                        }
                        const elements = dataRaw.byteLength / 8;
                        const dataHeads = new Uint8Array(new ArrayBuffer(elements * 4));
                        const dataTails = new Uint8Array(new ArrayBuffer(elements * 4));
                        for (let i = 0; i < elements; i++) {
                            for (let j = 0; j < 4; j++) {  // 4 bytes
                                dataHeads[(i * 4) + j] = dataRaw[(i * 8) + j];
                                dataTails[(i * 4) + j] = dataRaw[(i * 8) + j + 4];
                            }
                        }
                        snapshot.dataHeads = dataHeads.buffer;
                        snapshot.dataTails = dataTails.buffer;
                    } else {
                        throw 'data.bin not found';
                    }
                } else {
                    // one buffer for element heads and one for element tails
                    const dataRawHeads = zip['data-heads.bin'];
                    if (dataRawHeads) {
                        snapshot.dataHeads = dataRawHeads.buffer;
                    } else {
                        throw 'data-heads.bin not found';
                    }
                    const dataRawTails = zip['data-tails.bin'];
                    if (!dataRawTails) {
                        throw 'data-tails.bin not found';
                    }
                    snapshot.dataTails = dataRawTails.buffer;
                }
    
                // load entities
                if (snapshot.metadata.formatVersion > 6) {
                    snapshot.serializedEntities = parseJson('data-entities.json');
                    if (!Array.isArray(snapshot.serializedEntities)) {
                        throw 'Entities corrupted';
                    }
                } else {
                    snapshot.serializedEntities = [];
                }
    
                // ensure backward compatibility
                if (snapshot.metadata.formatVersion === 1) {
                    // after 23w32a first byte of element head was changed (powder elements reworked)
                    ResourceSnapshot.#convertToV2(snapshot);
                    snapshot.metadata.formatVersion = 2;
                }
                if (snapshot.metadata.formatVersion === 2) {
                    // interleaving buffer >> element head buffer & element tail buffer
                    snapshot.metadata.formatVersion = 3;
                }
                if (snapshot.metadata.formatVersion === 3) {
                    // temperature conducting, element type class changes
                    ResourceSnapshot.#convertToV4(snapshot);
                    snapshot.metadata.formatVersion = 4;
                }
                if (snapshot.metadata.formatVersion === 4) {
                    // new trees
                    ResourceSnapshot.#convertToV5(snapshot);
                    snapshot.metadata.formatVersion = 5;
                }
                if (snapshot.metadata.formatVersion === 5) {
                    // conductivity, flammability... >> heat mod index
                    ResourceSnapshot.#convertToV6(snapshot);
                    snapshot.metadata.formatVersion = 6;
                }
                if (snapshot.metadata.formatVersion === 6) {
                    // entities, fish head & fish body behaviour removed
                    ResourceSnapshot.#convertToV7(snapshot);
                    snapshot.metadata.formatVersion = 7;
                }
    
                return snapshot;
            }
    
            static #convertToV2(snapshot) {
                const elementArea = ElementArea.from(
                    snapshot.metadata.width, snapshot.metadata.height,
                    snapshot.dataHeads, snapshot.dataTails);
    
                for (let y = 0; y < snapshot.metadata.height; y++) {
                    for (let x = 0; x < snapshot.metadata.width; x++) {
    
                        // TODO: dry flag ignored
                        let elementHead = elementArea.getElementHead(x, y);
                        let oldType = elementHead & 0b111;  // type without dry flag
                        let oldWeight = (elementHead >> 4) & 0x0000000F;
    
                        if (oldType === 0x0 && oldWeight === 0x0) ; else if (oldType === 0x0) {
                            // static
                            elementArea.setElementHead(x, y, ElementHead.setType(elementHead, 0x7));
                        } else if (oldType === 0x1) {
                            // falling (grass only)
                            elementArea.setElementHead(x, y, ElementHead.setType(elementHead, 0x5));
                        } else if (oldType === 0x2) {
                            // sand 1 (soil, gravel)
                            elementArea.setElementHead(x, y, ElementHead.setType(elementHead, 0x5 | (4 << 5)));
                        } else if (oldType === 0x3) {
                            // sand 2 (sand)
                            elementArea.setElementHead(x, y, ElementHead.setType(elementHead, 0x5 | (6 << 5)));
                        } else if (oldType === 0x4 || oldType === 0x5) {
                            // fluid 1 (not used) or fluid 2 (water)
                            elementArea.setElementHead(x, y, ElementHead.setType(elementHead, 0x3));
                        }
                    }
                }
    
                snapshot.dataHeads = elementArea.getDataHeads();
                snapshot.dataTails = elementArea.getDataTails();
            }
    
            static #convertToV4(snapshot) {
                const elementArea = ElementArea.from(
                    snapshot.metadata.width, snapshot.metadata.height,
                    snapshot.dataHeads, snapshot.dataTails);
    
                for (let y = 0; y < snapshot.metadata.height; y++) {
                    for (let x = 0; x < snapshot.metadata.width; x++) {
                        let elementHead = elementArea.getElementHead(x, y);
                        let elementTail = elementArea.getElementTail(x, y);
    
                        let typeClass = elementHead & 0b111;
    
                        // element type class changes
                        if (typeClass > 0x1 && typeClass < 0x7) {
                            typeClass++;
                            elementHead = (elementHead & 0xFFFFFFF8) | typeClass;
                        }
    
                        // set at least some conductivity type and heat effect type
                        switch (typeClass) {
                            case 0x5: // powder element
                            case 0x6: // powder element wet
                            case 0x7: // static
                                elementHead = elementHead | 0x00400000;
                                elementTail = elementTail | 0x10000000;
                                break;
                        }
    
                        // set water behaviour
                        if (typeClass === 0x4) {
                            elementHead = (elementHead & 0xFFFFF0FF) | (0xC << 8);
                        }
    
                        elementArea.setElementHead(x, y, elementHead);
                        elementArea.setElementTail(x, y, elementTail);
                    }
                }
    
                snapshot.dataHeads = elementArea.getDataHeads();
                snapshot.dataTails = elementArea.getDataTails();
            }
    
            static #convertToV5(snapshot) {
                const elementArea = ElementArea.from(
                    snapshot.metadata.width, snapshot.metadata.height,
                    snapshot.dataHeads, snapshot.dataTails);
    
                for (let y = 0; y < snapshot.metadata.height; y++) {
                    for (let x = 0; x < snapshot.metadata.width; x++) {
                        let elementHead = elementArea.getElementHead(x, y);
    
                        // unset tree and leaf behaviour and special
                        let behaviour = (elementHead >> 8) & 0x0000000F;
                        if (behaviour === 0x5 || behaviour === 0x8) {
                            elementHead = (elementHead & 0xFFFF00FF);
                        }
    
                        elementArea.setElementHead(x, y, elementHead);
                    }
                }
    
                snapshot.dataHeads = elementArea.getDataHeads();
                snapshot.dataTails = elementArea.getDataTails();
            }
    
            static #convertToV6(snapshot) {
                const elementArea = ElementArea.from(
                    snapshot.metadata.width, snapshot.metadata.height,
                    snapshot.dataHeads, snapshot.dataTails);
    
                for (let y = 0; y < snapshot.metadata.height; y++) {
                    for (let x = 0; x < snapshot.metadata.width; x++) {
                        const elementHead = elementArea.getElementHead(x, y);
    
                        // map old 4 constants to heat mod index
    
                        const flammableType = (elementHead >> 16) & 0x00000003;
                        const flameHeatType = (elementHead >> 18) & 0x00000003;
                        const burnableType = (elementHead >> 20) & 0x00000003;
                        const conductivityType = (elementHead >> 22) & 0x00000003;
    
                        // [0.2, 0.25, 0.3, 0.45][conductivityType];  // small .. big    conductiveIndex
                        // [2500, 500, 20, 10][conductivityType];  // big .. small       heatLossChanceTo10000
                        // [0, 100, 4500, 10000][flammableType];  // never .. quickly    flammableChanceTo10000
                        // [0, 2, 3, 5][flammableType];  // never .. quickly             selfIgnitionChanceTo10000
                        // [0, 165, 220, 255][flameHeatType];  // none .. very hot       flameHeat
                        // [0, 2, 100, 1000][burnableType];  // none .. fast             burnDownChanceTo10000
    
                        // all used combinations
                        let heatModIndex = 0;  // default
                        if (flammableType === 0 && flameHeatType === 0 && burnableType === 0 && conductivityType === 0) {
                            heatModIndex = 0;
                        } else if (flammableType === 0 && flameHeatType === 0 && burnableType === 0 && conductivityType === 1) {
                            heatModIndex = 1;
                        } else if (flammableType === 0 && flameHeatType === 0 && burnableType === 0 && conductivityType === 2) {
                            heatModIndex = 2;
                        } else if (flammableType === 0 && flameHeatType === 0 && burnableType === 0 && conductivityType === 3) {
                            heatModIndex = 3;
                        } else if (flammableType === 2 && flameHeatType === 1 && burnableType === 3 && conductivityType === 0) {
                            heatModIndex = 4;
                        } else if (flammableType === 1 && flameHeatType === 1 && burnableType === 1 && conductivityType === 0) {
                            heatModIndex = 5;
                        } else if (flammableType === 2 && flameHeatType === 1 && burnableType === 2 && conductivityType === 0) {
                            heatModIndex = 6;
                        }
    
                        const newElementHead = (elementHead & 0xFF00FFFF) | (heatModIndex << 16);
                        elementArea.setElementHead(x, y, newElementHead);
                    }
                }
    
                snapshot.dataHeads = elementArea.getDataHeads();
                snapshot.dataTails = elementArea.getDataTails();
            }
    
            static #convertToV7(snapshot) {
                const elementArea = ElementArea.from(
                    snapshot.metadata.width, snapshot.metadata.height,
                    snapshot.dataHeads, snapshot.dataTails);
    
                for (let y = 0; y < snapshot.metadata.height; y++) {
                    for (let x = 0; x < snapshot.metadata.width; x++) {
                        let elementHead = elementArea.getElementHead(x, y);
    
                        // map fish elements to fish entity
                        let behaviour = (elementHead >> 8) & 0x0000000F;
                        if (behaviour === 0x3) {
                            snapshot.serializedEntities.push({ entity: 'fish', x: x, y: y });
                        }
    
                        // unset fish head & fish body behaviour and special
                        // set entity behaviour
                        if (behaviour === 0x3 || behaviour === 0x4) {
                            elementHead = (elementHead & 0xFFFF00FF) | (0xD << 8);
                        }
    
                        elementArea.setElementHead(x, y, elementHead);
                    }
                }
    
                snapshot.dataHeads = elementArea.getDataHeads();
                snapshot.dataTails = elementArea.getDataTails();
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * Create flipped scene using object composition.
         *
         * @author Patrik Harag
         * @version 2023-12-20
         */
        class SceneImplModFlip extends Scene {
    
            /**
             * @type Scene
             */
            #original;
    
            #flipHorizontally;
            #flipVertically;
    
            constructor(scene, flipHorizontally, flipVertically) {
                super();
                this.#original = scene;
                this.#flipHorizontally = flipHorizontally;
                this.#flipVertically = flipVertically;
            }
    
            countSize(prefWidth, prefHeight) {
                this.#original.countSize(prefWidth, prefHeight);
            }
    
            async createSandGame(prefWidth, prefHeight, defaults, context, rendererInitializer) {
                let elementArea = this.createElementArea(prefWidth, prefHeight, defaults.getDefaultElement());
                return new SandGame(elementArea, [], null, defaults, context, rendererInitializer);
                // TODO: sceneMetadata not set
                // TODO: entities support
            }
    
            createElementArea(prefWidth, prefHeight, defaultElement) {
                const elementArea = this.#original.createElementArea(prefWidth, prefHeight, defaultElement);
    
                const width = elementArea.getWidth();
                const height = elementArea.getHeight();
    
                if (this.#flipHorizontally) {
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < Math.trunc(width / 2); x++) {
                            elementArea.swap(x, y, width - 1 - x, y);
                        }
                    }
                }
    
                if (this.#flipVertically) {
                    for (let y = 0; y < Math.trunc(height / 2); y++) {
                        for (let x = 0; x < width; x++) {
                            elementArea.swap(x, y, x, height - 1 - y);
                        }
                    }
                }
    
                return elementArea;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-20
         */
        class SceneImplTemplate extends Scene {
    
            /**
             * @type ElementArea
             */
            #elementArea;
    
            /**
             *
             * @param elementArea {ElementArea}
             */
            constructor(elementArea) {
                super();
                this.#elementArea = elementArea;
            }
    
            countSize(prefWidth, prefHeight) {
                return [this.#elementArea.getWidth(), this.#elementArea.getHeight()];
            }
    
            async createSandGame(prefWidth, prefHeight, defaults, context, rendererInitializer) {
                let elementArea = this.createElementArea(prefWidth, prefHeight, defaults.getDefaultElement());
                return new SandGame(elementArea, [], null, defaults, context, rendererInitializer);
            }
    
            createElementArea(prefWidth, prefHeight, defaultElement) {
                return ElementArea.from(
                        this.#elementArea.getWidth(),
                        this.#elementArea.getHeight(),
                        this.#elementArea.getDataHeads(),
                        this.#elementArea.getDataTails());
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-09
         */
        class ResourceUtils {
    
            /**
             *
             * @param objectUrl
             * @param maxWidth
             * @param maxHeight
             * @returns {Promise<ImageData>}
             */
            static loadImageData(objectUrl, maxWidth, maxHeight) {
                // TODO: security - it will also fetch an external image
                return Assets.asImageData(objectUrl, maxWidth, maxHeight);
            }
    
            /**
             *
             * @param data {ArrayBuffer} ArrayBuffer
             * @param type {string} type
             * @returns {string}
             */
            static asObjectUrl(data, type='image/png') {
                // https://gist.github.com/candycode/f18ae1767b2b0aba568e
                const arrayBufferView = new Uint8Array(data);
                const blob = new Blob([ arrayBufferView ], { type: type });
                const urlCreator = window.URL || window.webkitURL;
                return urlCreator.createObjectURL(blob);
            }
    
            /**
             *
             * @param imageData {ImageData}
             * @param brush {Brush}
             * @param defaultElement {Element}
             * @param threshold {number} 0-255
             * @returns Scene
             */
            static createSceneFromImageTemplate(imageData, brush, defaultElement, threshold) {
                const width = imageData.width;
                const height = imageData.height;
    
                const elementArea = ElementArea.create(width, height, defaultElement);
    
                const random = new DeterministicRandom(0);
    
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4;
    
                        let red = imageData.data[index];
                        let green = imageData.data[index + 1];
                        let blue = imageData.data[index + 2];
                        const alpha = imageData.data[index + 3];
    
                        // perform alpha blending if needed
                        if (alpha !== 0xFF) {
                            red = Math.trunc((red * alpha) / 0xFF) + 0xFF - alpha;
                            green = Math.trunc((green * alpha) / 0xFF) + 0xFF - alpha;
                            blue = Math.trunc((blue * alpha) / 0xFF) + 0xFF - alpha;
                        }
    
                        // filter out background
                        if (red > 0xFF-threshold && green > 0xFF-threshold && blue > 0xFF-threshold) {
                            continue;  // white
                        }
    
                        const element = brush.apply(x, y, random);
                        const elementHead = element.elementHead;
                        const elementTail = ElementTail.setColor(element.elementTail, red, green, blue);
                        elementArea.setElementHeadAndTail(x, y, elementHead, elementTail);
                    }
                }
    
                return new SceneImplTemplate(elementArea);
            }
    
            static getImageTypeOrNull(filename) {
                filename = filename.toLowerCase();
                if (filename.endsWith('.png')) {
                    return 'image/png'
                }
                if (filename.endsWith('.jpg') || filename.endsWith('.jpeg')) {
                    return 'image/jpg'
                }
                if (filename.endsWith('.bmp')) {
                    return 'image/bmp'
                }
                if (filename.endsWith('.gif')) {
                    return 'image/gif'
                }
                return null;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-11
         */
        class ResourceTool {
    
            static METADATA_JSON_NAME = 'tool.json';
    
            /**
             *
             * @param metadataJson {any}
             * @param zip {{[path: string]: Uint8Array}|null}
             * @returns {Promise<Tool>}
             */
            static async parse(metadataJson, zip) {
                const info = metadataJson.info;
                const action = metadataJson.action;
    
                if (action === undefined) {
                    throw 'Tool definition: action not set';
                }
                const type = action.type;
    
                if (type === 'image-template') {
                    const scenes = await this.#parseImageTemplate(action, zip);
                    return Tools.insertScenesTool(scenes, undefined, info);
    
                } else if (type === 'random-template') {
                    const scenes = await this.#parseRandomTemplate(action, zip);
                    return Tools.insertScenesTool(scenes, undefined, info);
    
                } else {
                    throw 'Tool action not supported: ' + type;
                }
            }
    
            static async #parseRandomTemplate(json, zip) {
                const actions = json.actions;
                if (actions === undefined || actions.length === undefined || actions.length === 0) {
                    throw 'Image template: actions not set';
                }
    
                let scenes = [];
                for (let i = 0; i < actions.length; i++) {
                    const action = actions[i];
                    const type = action.type;
                    if (type === 'image-template') {
                        const items = await this.#parseImageTemplate(action, zip);
                        scenes.push(...items);
                    } else {
                        throw 'Tool action not supported: ' + type;
                    }
                }
                return scenes;
            }
    
            static async #parseImageTemplate(json, zip) {
                let imageData = await this.#parseImageData(json, zip);
    
                const thresholdPar = json.threshold;
                if (thresholdPar === undefined) {
                    throw 'Image template: threshold not set';
                }
                const threshold = parseInt(thresholdPar);
    
                const brushPar = json.brush;
                if (brushPar === undefined) {
                    throw 'Image template: brush not set';
                }
                let brush = null;
                if (typeof brushPar === 'string') {
                    brush = BrushDefs.byCodeName(brushPar);
                } else if (typeof brushPar === 'object' && brushPar instanceof Brush) {
                    brush = brushPar;
                }
                if (brush === null) {
                    throw 'Image template: brush not found: ' + brushPar;
                }
    
                const defaultElement = ElementArea.TRANSPARENT_ELEMENT;
                const scene = ResourceUtils.createSceneFromImageTemplate(imageData, brush, defaultElement, threshold);
                const scenes = [scene];
    
                const randomFlipHorizontally = json.randomFlipHorizontally;
                if (randomFlipHorizontally) {
                    scenes.push(new SceneImplModFlip(scene, true, false));
                }
    
                const randomFlipVertically = json.randomFlipVertically;
                if (randomFlipVertically) {
                    for (const s of [...scenes]) {
                        scenes.push(new SceneImplModFlip(s, false, true));
                    }
                }
    
                return scenes;
            }
    
            static async #parseImageData(json, zip) {
                const imageDataPar = json.imageData;
                if (imageDataPar !== undefined) {
                    return await ResourceUtils.loadImageData(imageDataPar, undefined, undefined);
                }
    
                const imageFilePar = json.imageFile;
                if (imageFilePar !== undefined && zip !== null && zip[imageFilePar]) {
                    const imageType = ResourceUtils.getImageTypeOrNull(imageFilePar);
                    if (imageType !== null) {
                        const objectUrl = ResourceUtils.asObjectUrl(zip[imageFilePar].buffer);
                        return ResourceUtils.loadImageData(objectUrl, undefined, undefined);
                    }
                }
                throw 'Image template: imageData/imageFile not set';
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-09
         */
        class Resources {
    
            static JSON_RESOURCE_TYPE_FIELD = 'resourceType';
    
            /**
             *
             * @param snapshot {Snapshot}
             * @returns Uint8Array
             */
            static createResourceFromSnapshot(snapshot) {
                return ResourceSnapshot.createZip(snapshot);
            }
    
            /**
             *
             * @param content {ArrayBuffer}
             * @returns Promise<Scene|Tool>
             */
            static async parseZipResource(content) {
                const zip = unzipSync(new Uint8Array(content));
    
                function parseJson(fileName) {
                    return JSON.parse(strFromU8(zip[fileName]));
                }
    
                if (zip[ResourceSnapshot.METADATA_JSON_NAME] || zip[ResourceSnapshot.LEGACY_METADATA_JSON_NAME]) {
                    // snapshot | legacy snapshot
                    const snapshot = ResourceSnapshot.parse(zip);
                    return new SceneImplSnapshot(snapshot);
                }
                if (zip[ResourceTool.METADATA_JSON_NAME]) {
                    // tool
                    const metadataJson = parseJson(ResourceTool.METADATA_JSON_NAME);
                    return await ResourceTool.parse(metadataJson, zip);
                }
                throw 'Wrong format';
            }
    
            /**
             *
             * @param content {ArrayBuffer}
             * @returns Promise<Tool>
             */
            static async parseJsonResource(content) {
                const text = strFromU8(new Uint8Array(content));
                const metadataJson = JSON.parse(text);
    
                const type = metadataJson[Resources.JSON_RESOURCE_TYPE_FIELD];
                if (type === 'tool') {
                    return await ResourceTool.parse(metadataJson, null);
                }
                throw 'Wrong json format';
            }
    
            /**
             *
             * @param json
             * @returns {Promise<Tool>}
             */
            static async parseToolDefinition(json) {
                return ResourceTool.parse(json, null);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2023-12-22
         */
        class Component {
    
            /**
             *
             * @param controller {Controller}
             * @return {HTMLElement}
             */
            createNode(controller) {
                throw 'Not implemented';
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * Creates template form and remembers last values.
         *
         * @author Patrik Harag
         * @version 2024-02-09
         */
        class ComponentFormTemplate extends Component {
    
            #thresholdValue = 50;
            #maxWidth = 300;
            #maxHeight = 200;
            #materialValue = 'sand';
            #materialBrush = BrushDefs.SAND;
    
            createNode() {
                return DomBuilder.element('form', null, [
                    DomBuilder.element('fieldset', {class: 'mb-3 row'}, [
                        DomBuilder.element('legend', {class: 'col-form-label col-sm-3 float-sm-left pt-0'}, 'Material'),
                        DomBuilder.div({class: 'col-sm-9', style: 'column-count: 2;'}, [
                            this.#creatMaterialFormGroup(BrushDefs.SAND, ToolDefs.SAND.getInfo()),
                            this.#creatMaterialFormGroup(BrushDefs.SOIL, ToolDefs.SOIL.getInfo()),
                            this.#creatMaterialFormGroup(BrushDefs.THERMITE, ToolDefs.THERMITE.getInfo()),
                            this.#creatMaterialFormGroup(BrushDefs.WALL, ToolDefs.WALL.getInfo()),
                            this.#creatMaterialFormGroup(BrushDefs.METAL, ToolDefs.METAL.getInfo()),
                            this.#creatMaterialFormGroup(BrushDefs.TREE_WOOD, ToolDefs.WOOD.getInfo()),
                        ])
                    ]),
                    DomBuilder.element('fieldset', {class: 'mb-3 row'}, [
                        DomBuilder.element('legend', {class: 'col-form-label col-sm-3 float-sm-left pt-0'}, 'Background threshold'),
                        DomBuilder.div({class: 'col-sm-9'}, [
                            this.#createThresholdSliderFormGroup(),
                        ])
                    ]),
                    DomBuilder.element('fieldset', {class: 'mb-3 row'}, [
                        DomBuilder.element('legend', {class: 'col-form-label col-sm-3 float-sm-left pt-0'}, 'Max size'),
                        DomBuilder.div({class: 'col-sm-9'}, [
                            this.#createMaxWidthFormGroup(),
                            this.#createMaxHeightFormGroup(),
                        ])
                    ])
                ]);
            }
    
            #createThresholdSliderFormGroup() {
                const id = 'image-template_threshold-slider';
    
                const label = DomBuilder.element('label', {'for': id}, 'Value: ' + this.#thresholdValue);
    
                const slider = DomBuilder.element('input', {
                    id: id,
                    class: 'form-range',
                    type: 'range',
                    min: 0, max: 255, value: this.#thresholdValue
                });
                slider.addEventListener('input', (e) => {
                    this.#thresholdValue = e.target.value;
                    label.textContent = 'Value: ' + this.#thresholdValue;
                });
    
                return DomBuilder.div({class: 'mb-3'}, [
                    slider,
                    DomBuilder.element('small', null, label)
                ]);
            }
    
            #createMaxWidthFormGroup() {
                const id = 'image-template_max-width';
    
                const label = DomBuilder.element('label', {'for': id}, 'Width: ' + this.#maxWidth);
    
                const slider = DomBuilder.element('input', {
                    id: id,
                    class: 'form-range',
                    type: 'range',
                    min: 25, max: 800, value: this.#maxWidth
                });
                slider.addEventListener('input', (e) => {
                    this.#maxWidth = e.target.value;
                    label.textContent = 'Width: ' + this.#maxWidth;
                });
    
                return DomBuilder.div({class: 'mb-3'}, [
                    slider,
                    DomBuilder.element('small', null, label)
                ]);
            }
    
            #createMaxHeightFormGroup() {
                const id = 'image-template_max-height';
    
                const label = DomBuilder.element('label', {'for': id}, 'Height: ' + this.#maxHeight);
    
                const slider = DomBuilder.element('input', {
                    id: id,
                    class: 'form-range',
                    type: 'range',
                    min: 25, max: 800, value: this.#maxHeight
                });
                slider.addEventListener('input', (e) => {
                    this.#maxHeight = e.target.value;
                    label.textContent = 'Height: ' + this.#maxHeight;
                });
    
                return DomBuilder.div({class: 'mb-3'}, [
                    slider,
                    DomBuilder.element('small', null, label)
                ]);
            }
    
            #creatMaterialFormGroup(brush, toolInfo) {
                const value = toolInfo.getCodeName();
    
                const checked = (this.#materialValue === value);
                const id = 'image-template_checkbox-material-' + value;
    
                const input = DomBuilder.element('input', {
                    class: 'form-check-input',
                    type: 'radio',
                    name: 'template-material',
                    id: id,
                    value: value,
                    checked: (checked) ? checked : null
                });
                input.addEventListener('click', () => {
                    this.#materialBrush = brush;
                    this.#materialValue = value;
                });
    
                const labelAttributes = {
                    class: 'form-check-label btn btn-secondary btn-sand-game-tool ' + value,
                    'for': id,
                    style: toolInfo.getBadgeStyle()
                };
                return DomBuilder.div({class: 'form-check'}, [
                    input,
                    DomBuilder.element('label', labelAttributes, toolInfo.getDisplayName())
                ]);
            }
    
            getThresholdValue() {
                return this.#thresholdValue;
            }
    
            getMaterialBrush() {
                return this.#materialBrush;
            }
    
            getMaxWidth() {
                return this.#maxWidth;
            }
    
            getMaxHeight() {
                return this.#maxHeight;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        // TODO: refactor
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-06
         */
        class ServiceIO {
    
            /** @type Controller */
            #controller;
    
            /** @type ComponentFormTemplate */
            #templateForm;
    
            constructor(controller) {
                this.#controller = controller;
                this.#templateForm = new ComponentFormTemplate();
            }
    
            initFileDragAndDrop(domNode) {
                ['dragenter', 'dragover'].forEach(eventName => {
                    domNode.addEventListener(eventName, e => {
                        e.preventDefault();
                        e.stopPropagation();
                        domNode.classList.add('drag-and-drop-highlight');
                    });
                });
    
                domNode.addEventListener('dragleave', e => {
                    e.preventDefault();
                    e.stopPropagation();
                    domNode.classList.remove('drag-and-drop-highlight');
                });
    
                domNode.addEventListener('drop', e => {
                    e.preventDefault();
                    e.stopPropagation();
                    domNode.classList.remove('drag-and-drop-highlight');
    
                    this.loadFromFiles(e.dataTransfer.files);
                });
            }
    
            loadFromFiles(files) {
                if (!files) {
                    return;
                }
                let file = files[0];
    
                let reader = new FileReader();
                reader.onload = (readerEvent) => {
                    let content = readerEvent.target.result;
                    this.loadFromArrayBuffer(content, file.name);
                };
                reader.readAsArrayBuffer(file);
            }
    
            /**
             *
             * @param content {ArrayBuffer}
             * @param filename {string}
             */
            loadFromArrayBuffer(content, filename) {
                try {
                    let imageTypeOrNull = ResourceUtils.getImageTypeOrNull(filename);
                    if (imageTypeOrNull !== null) {
                        this.#loadImageTemplate(content, imageTypeOrNull);
                    } else if (filename.endsWith(".json")) {
                        Resources.parseJsonResource(content)
                                .then(resource => this.#importResource(resource))
                                .catch(e => this.#handleError(e));
                    } else {
                        Resources.parseZipResource(content)
                                .then(resource => this.#importResource(resource))
                                .catch(e => this.#handleError(e));
                    }
                } catch (e) {
                    this.#handleError(e);
                }
            }
    
            #loadImageTemplate(content, imageType) {
                const handleImageTemplate = (brush, threshold, maxWidth, maxHeight) => {
                    const objectUrl = ResourceUtils.asObjectUrl(content, imageType);
                    const defaultElement = ElementArea.TRANSPARENT_ELEMENT;
                    ResourceUtils.loadImageData(objectUrl, maxWidth, maxHeight)
                        .then(imageData => {
                            try {
                                const scene = ResourceUtils.createSceneFromImageTemplate(imageData, brush, defaultElement, threshold);
                                this.#importImageTemplate(scene);
                            } catch (e) {
                                this.#handleError(e);
                            }
                        })
                        .catch(e => this.#handleError(e));
                };
    
                let dialog = DomBuilder.bootstrapDialogBuilder();
                dialog.setHeaderContent('Image template');
                dialog.setBodyContent(this.#templateForm.createNode());
                dialog.addSubmitButton('Place', () => {
                    let materialBrush = this.#templateForm.getMaterialBrush();
                    let thresholdValue = this.#templateForm.getThresholdValue();
                    let maxWidth = this.#templateForm.getMaxWidth();
                    let maxHeight = this.#templateForm.getMaxHeight();
                    handleImageTemplate(materialBrush, thresholdValue, maxWidth, maxHeight);
                });
                dialog.addCloseButton('Close');
                dialog.show(this.#controller.getDialogAnchor());
            }
    
            #importImageTemplate(scene) {
                this.#controller.pasteScene(scene);
                Analytics.triggerFeatureUsed(Analytics.FEATURE_IO_IMAGE_TEMPLATE);
            }
    
            #importResource(resource) {
                if (resource instanceof Scene) {
                    this.#importScene(resource);
    
                } else if (resource instanceof Tool) {
                    const tool = resource;
                    const toolManager = this.#controller.getToolManager();
                    if (tool instanceof InsertElementAreaTool || tool instanceof InsertRandomSceneTool) {
                        const revert = toolManager.createRevertAction();
                        toolManager.setPrimaryTool(tool);
                        toolManager.setSecondaryTool(Tools.actionTool(revert));
                    } else {
                        toolManager.setPrimaryTool(tool);
                    }
    
                } else {
                    this.#handleError('Unknown resource type');
                }
            }
    
            #importScene(scene) {
                try {
                    let dialog = DomBuilder.bootstrapDialogBuilder();
                    dialog.setHeaderContent('Import scene');
                    dialog.setBodyContent([
                        DomBuilder.par(null, "The imported scene can be opened or placed on the current scene.")
                    ]);
                    dialog.addSubmitButton('Open', () => {
                        Analytics.triggerFeatureUsed(Analytics.FEATURE_IO_IMPORT);
                        return this.#controller.openScene(scene);
                    });
                    dialog.addSubmitButton('Place', () => {
                        Analytics.triggerFeatureUsed(Analytics.FEATURE_IO_IMPORT);
                        return this.#controller.pasteScene(scene);
                    });
                    dialog.addCloseButton('Close');
                    dialog.show(this.#controller.getDialogAnchor());
                } catch (ex) {
                    this.#handleError(ex);
                }
            }
    
            #handleError(e) {
                let dialog = DomBuilder.bootstrapDialogBuilder();
                dialog.setHeaderContent('Error');
                dialog.setBodyContent([
                    DomBuilder.par(null, "Error while loading resource:"),
                    DomBuilder.element('code', null, '' + e)
                ]);
                dialog.addCloseButton('Close');
                dialog.show(this.#controller.getDialogAnchor());
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2024-04-12
         */
        class BrushCollection {
    
            /**
             *
             * @returns {Object.<string,Brush>}
             */
            getExtraBrushes() {
                throw 'Not implemented';
            }
    
            /**
             *
             * @param codeName {string}
             * @returns {Brush|null}
             */
            byCodeName(codeName) {
                throw 'Not implemented';
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-12
         */
        class BrushCollectionImpl extends BrushCollection {
    
            /**
             * @type {Object.<string,Brush>}
             */
            #extraBrushes;
    
            constructor(extraBrushes) {
                super();
                this.#extraBrushes = extraBrushes;
            }
    
            getExtraBrushes() {
                return { ...this.#extraBrushes };
            }
    
            byCodeName(codeName) {
                const brush = this.#extraBrushes[codeName];
                if (brush !== undefined) {
                    return brush;
                }
                return BrushDefs.byCodeName(codeName);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class GameDefaultsImpl extends GameDefaults {
    
            /** @type function(GameState):Extension[] */ #extensionsFactory;
    
            /** @type BrushCollection */ #brushCollection;
    
            /** @type Element */ #defaultElement;
    
            /** @type Brush */ #brushWater;
            /** @type Brush */ #brushSteam;
            /** @type Brush */ #brushGrass ;
            /** @type Brush */ #brushTree;
            /** @type Brush */ #brushTreeWood;
            /** @type Brush */ #brushTreeWoodDark;
            /** @type Brush */ #brushTreeLeaf;
            /** @type Brush */ #brushTreeLeafDark;
            /** @type Brush */ #brushTreeRoot;
            /** @type Brush */ #brushFire;
            /** @type Brush */ #brushAsh;
    
            /**
             *
             * @param extraBrushes {Object.<string, Brush>}
             * @param extensionsFactory {function(GameState):Extension[]}
             */
            constructor(extraBrushes = {}, extensionsFactory = () => []) {
                super();
    
                this.#extensionsFactory = extensionsFactory;
                this.#brushCollection = new BrushCollectionImpl(extraBrushes);
    
                function resolveBrush(codeName) {
                    const brush = extraBrushes[codeName];
                    if (brush === undefined || brush === null) {
                        const byCodeName = BrushDefs.byCodeName(codeName);
                        if (byCodeName === null) {
                            throw `Brush '${codeName}' not found`;
                        }
                        return byCodeName;
                    } else {
                        if (brush instanceof Brush) {
                            return brush;
                        }
                        throw `Provided brush '${codeName}' is not instance of Brush`;
                    }
                }
    
                this.#defaultElement = resolveBrush('air').apply(0, 0, undefined);
    
                this.#brushWater = resolveBrush('water');
                this.#brushSteam = resolveBrush('steam');
                this.#brushGrass = resolveBrush('grass');
                this.#brushTree = resolveBrush('tree');
                this.#brushTreeWood = resolveBrush('tree_wood');
                this.#brushTreeWoodDark = resolveBrush('tree_wood_dark');
                this.#brushTreeLeaf = resolveBrush('tree_leaf');
                this.#brushTreeLeafDark = resolveBrush('tree_leaf_dark');
                this.#brushTreeRoot = resolveBrush('tree_root');
                this.#brushFire = resolveBrush('fire');
                this.#brushAsh = resolveBrush('ash');
            }
    
            getExtensionsFactory() {
                return this.#extensionsFactory;
            }
    
            getBrushCollection() {
                return this.#brushCollection;
            }
    
            getDefaultElement() {
                return this.#defaultElement;
            }
    
            // brushes
    
            getBrushWater() {
                return this.#brushWater;
            }
    
            getBrushSteam() {
                return this.#brushSteam;
            }
    
            getBrushGrass() {
                return this.#brushGrass;
            }
    
            getBrushTree() {
                return this.#brushTree;
            }
    
            getBrushTreeLeaf() {
                return this.#brushTreeLeaf;
            }
    
            getBrushTreeLeafDark() {
                return this.#brushTreeLeafDark;
            }
    
            getBrushTreeWood() {
                return this.#brushTreeWood;
            }
    
            getBrushTreeWoodDark() {
                return this.#brushTreeWoodDark;
            }
    
            getBrushTreeRoot() {
                return this.#brushTreeRoot;
            }
    
            getBrushFire() {
                return this.#brushFire;
            }
    
            getBrushAsh() {
                return this.#brushAsh;
            }
    
            // structures
    
            getTreeTrunkTemplates() {
                return StructureDefs.TREE_TRUNK_TEMPLATES;
            }
    
            getTreeLeafClusterTemplates() {
                return StructureDefs.TREE_CLUSTER_TEMPLATES;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-08
         */
        class Controller {
    
            #init = {
                scale: 0.5,
                canvasWidthPx: 700,
                canvasHeightPx: 400,
                scene: 'empty'
            };
    
            /** @type number */
            #currentWidthPoints;
            /** @type number */
            #currentHeightPoints;
            /** @type number */
            #currentScale;
    
            /** @type SandGame */
            #sandGame = null;
            /** @type GameDefaults */
            #gameDefaults;
            /** @type string */
            #imageRendering = 'pixelated';
            /** @type function[] */
            #onImageRenderingStyleChanged = [];
            /** @type boolean */
            #simulationEnabled = false;
            /** @type boolean */
            #showActiveChunks = false;
            #rendererInitializer = RendererInitializer.canvasWebGL();
    
            /** @type Scene|null */
            #initialScene = null;
    
            /** @type ServiceToolManager */
            #serviceToolManager;
            /** @type ServiceIO */
            #serviceIO = new ServiceIO(this);
    
            /** @type HTMLElement */
            #dialogAnchor;
    
            /**
             * @typedef {Object} CanvasProvider
             * @property {function():HTMLElement} initialize
             * @property {function():HTMLElement} getCanvasNode
             */
            /** @type CanvasProvider|null */
            #canvasProvider = null;
    
            /**
             *
             * @param init
             * @param dialogAnchor
             * @param toolManager
             * @param gameDefaults {GameDefaults}
             */
            constructor(init, dialogAnchor, toolManager, gameDefaults) {
                if (init) {
                    this.#init = init;
                }
    
                this.#dialogAnchor = dialogAnchor;
                this.#serviceToolManager = toolManager;
                this.#gameDefaults = gameDefaults;
    
                this.#currentWidthPoints = Math.trunc(this.#init.canvasWidthPx * this.#init.scale);
                this.#currentHeightPoints = Math.trunc(this.#init.canvasHeightPx * this.#init.scale);
                this.#currentScale = this.#init.scale;
            }
    
            getVersion() {
                return this.#init.version;
            }
    
            /**
             *
             * @param canvasProvider {CanvasProvider}
             */
            registerCanvasProvider(canvasProvider) {
                this.#canvasProvider = canvasProvider;
            }
    
            /**
             * Returns initial scene definition - this is needed for restart etc.
             *
             * @returns {Scene|null}
             */
            getInitialScene() {
                return this.#initialScene;
            }
    
            setInitialScene(scene) {
                this.#initialScene = scene;
            }
    
            /**
             *
             * @param scene {Scene}
             */
            setup(scene) {
                this.setInitialScene(scene);
                this.#initialize(scene);
            }
    
            /**
             *
             * @param scene {Scene}
             */
            #initialize(scene) {
                if (this.#canvasProvider == null) {
                    throw 'Illegal state: canvas provider not registered!';
                }
                if (this.#dialogAnchor == null) {
                    throw 'Illegal state: dialog anchor not registered!';
                }
    
                const [w, h] = scene.countSize(this.#currentWidthPoints, this.#currentHeightPoints);
                if (w !== this.#currentWidthPoints || h !== this.#currentHeightPoints) {
                    this.#currentWidthPoints = w;
                    this.#currentHeightPoints = h;
                    this.#currentScale = +(w / this.#init.canvasWidthPx).toFixed(3);
                }
    
                // init game
                const context = this.#initializeContext();
                this.#sandGame = null;
                let promise;
                try {
                    promise = scene.createSandGame(w, h, this.#gameDefaults, context, this.#rendererInitializer);
                } catch (e) {
                    this.#reportSeriousFailure('Initialization failed', e);
                    return;
                }
    
                promise.then(sandGame => {
                    this.#sandGame = sandGame;
                    this.#sandGame.graphics().replace(ElementArea.TRANSPARENT_ELEMENT, this.#gameDefaults.getDefaultElement());
    
                    // call on opened
                    if (this.#initialScene !== null) {
                        this.#initialScene.executeOnOpened(this.#sandGame);
                    }
    
                    // handlers
                    this.#onInitialized.forEach(f => f(this.#sandGame));
    
                    // start rendering
                    this.#sandGame.addOnRenderingFailed((e) => {
                        this.#reportSeriousFailure('Rendering failure', e);
                    });
                    this.#sandGame.startRendering();
    
                    // start processing - if enabled
                    if (this.#simulationEnabled) {
                        this.#sandGame.startProcessing();
                        this.#onStarted.forEach(f => f());
                    }
                }).catch(e => {
                    if (e instanceof RenderingWebGLException) {
                        setTimeout(() => {
                            const cause = 'WebGL renderer initialization failed (' + e.getError() + '). '
                                    + 'Using fallback renderer; game performance and visuals will be affected!';
                            this.#restartAfterInitializationRendererFailure(cause, scene);
                        }, 100);
                    } else {
                        this.#reportSeriousFailure('Initialization failed', e);
                    }
                });
            }
    
            #initializeContext() {
                const canvas = this.#canvasProvider.initialize();
                let contextType = this.#rendererInitializer.getContextType();
                let context = this.#initializeContextAs(canvas, contextType);
                if ((contextType === 'webgl2') && (context === null || context === undefined)) {
                    // WebGL is not supported - unsupported at all / unsupported after recent failure
                    // - to test this, run Chrome with --disable-3d-apis
                    this.#reportFirstRenderingFailure("Unable to get WebGL context. Using fallback renderer; game performance and visual will be affected");
                    this.#rendererInitializer = RendererInitializer.canvas2d();
                    contextType = this.#rendererInitializer.getContextType();
                    context = this.#initializeContextAs(canvas, contextType);
                    Analytics.triggerFeatureUsed(Analytics.FEATURE_RENDERER_FALLBACK);
                }
                return context;
            }
    
            #initializeContextAs(canvasDomNode, contextId) {
                if (contextId === 'webgl2') {
                    // handle WebGL failures
    
                    let contextLossHandled = false;
                    canvasDomNode.addEventListener('webglcontextlost', (e) => {
                        // GPU memory leak, GPU failure, etc.
                        // - to test this move the texture definition into rendering loop to create a memory leak
    
                        if (this.#sandGame !== null) {
                            this.#sandGame.stopRendering();  // stop rendering immediately
                        }
    
                        if (!contextLossHandled) {
                            contextLossHandled = true;
                        } else {
                            return;  // already handled
                        }
    
                        const cause = 'WebGL context loss detected. Using fallback renderer; game performance and visuals will be affected';
                        e.preventDefault();
                        setTimeout(() => {
                            this.#restartAfterRenderingFailure(cause);
                        }, 2000);
                    }, false);
                }
                return canvasDomNode.getContext(contextId);
            }
    
            close() {
                if (this.#sandGame !== null) {
                    this.#sandGame.stopProcessing();
                    this.#sandGame.stopRendering();
                }
                for (let func of this.#onBeforeClosed) {
                    func();
                }
            }
    
            enableGlobalShortcuts() {
                document.onkeydown = (e) => {
                    // handle start stop
                    if (e.ctrlKey && !e.altKey && !e.shiftKey && e.key === 'Enter') {
                        e.preventDefault();
                        this.switchStartStop();
                    }
                    // handle next step
                    if (e.ctrlKey && !e.altKey && !e.shiftKey && e.key === ' ') {
                        e.preventDefault();
                        if (this.#sandGame !== null) {
                            this.#sandGame.doProcessing();
                        }
                    }
                    // handle fast execute
                    if (e.ctrlKey && !e.altKey && e.shiftKey && e.key === ' ') {
                        e.preventDefault();
                        if (this.#sandGame !== null) {
                            const input = prompt('Enter the number of iterations to run', '10000');
                            const iterations = Math.abs(parseInt(input));
                            const timeBefore = new Date();
                            for (let i = 0; i < iterations; i++) {
                                this.#sandGame.doProcessing();
                                if (i % 2500 === 0) {
                                    console.log(`Performed ${i} of ${iterations} iterations`);
                                }
                            }
                            const timeAfter = new Date();
                            const elapsedMs = timeAfter.getTime() - timeBefore.getTime();
                            console.log(`Performed ${iterations} iterations in ${elapsedMs} ms`);
                        }
                    }
                };
            }
    
            /**
             *
             * @returns {SandGame|null}
             */
            getSandGame() {
                return this.#sandGame;
            }
    
            /**
             *
             * @returns {HTMLElement|null}
             */
            getCanvas() {
                if (this.#canvasProvider !== null) {
                    return this.#canvasProvider.getCanvasNode();
                }
                return null;
            }
    
            // controller - simulation state
    
            /** @type function(SandGame)[] */
            #onInitialized = [];
            /** @type function(SandGame)[] */
            #onBeforeClosed = [];
            /** @type function(Scene)[] */
            #onBeforeNewSceneLoaded = [];
            /** @type function[] */
            #onStarted = [];
            /** @type function[] */
            #onStopped = [];
            /** @type function(type:string,message:string)[] */
            #onFailure = [];
    
            /**
             *
             * @param handler {function(SandGame)}
             * @returns void
             */
            addOnInitialized(handler) {
                this.#onInitialized.push(handler);
            }
    
            /**
             *
             * @param handler {function(Scene)}
             * @returns void
             */
            addOnBeforeNewSceneLoaded(handler) {
                this.#onBeforeNewSceneLoaded.push(handler);
            }
    
            /**
             *
             * @param handler {function}
             * @returns void
             */
            addOnBeforeClosed(handler) {
                this.#onBeforeClosed.push(handler);
            }
    
            /**
             *
             * @param handler {function}
             * @returns void
             */
            addOnStarted(handler) {
                this.#onStarted.push(handler);
            }
    
            /**
             *
             * @param handler {function}
             * @returns void
             */
            addOnStopped(handler) {
                this.#onStopped.push(handler);
            }
    
            /**
             *
             * @param handler {function(type:string,message:string)}
             * @returns void
             */
            addOnFailure(handler) {
                this.#onFailure.push(handler);
            }
    
            #restartAfterInitializationRendererFailure(cause, scene) {
                this.#reportFirstRenderingFailure(cause);
                this.#rendererInitializer = RendererInitializer.canvas2d();  // fallback to classic CPU renderer
                this.#initialize(scene);
                Analytics.triggerFeatureUsed(Analytics.FEATURE_RENDERER_FALLBACK);
            }
    
            #restartAfterRenderingFailure(cause) {
                this.#reportFirstRenderingFailure(cause);
                const snapshot = this.createSnapshot();
                this.#rendererInitializer = RendererInitializer.canvas2d();  // fallback to classic CPU renderer
                this.openScene(new SceneImplSnapshot(snapshot));
                Analytics.triggerFeatureUsed(Analytics.FEATURE_RENDERER_FALLBACK);
            }
    
            #reportFirstRenderingFailure(message) {
                console.warn(message);
                for (let handler of this.#onFailure) {
                    handler('rendering-warning', message);
                }
    
                let toast = DomBuilder.bootstrapToastBuilder();
                toast.setHeaderContent(DomBuilder.element('strong', { style: 'color: orange;' }, 'Warning'));
                toast.setBodyContent(DomBuilder.par(null, message));
                toast.setDelay(60000);
                toast.show(this.#dialogAnchor);
            }
    
            #reportSeriousFailure(message, e) {
                console.error(message, e);
    
                // normalize exception
                if (e instanceof RenderingWebGLException) {
                    e = e.getError();
                }
                if (typeof e === 'object') {
                    if (e.message !== undefined) {
                        e = '' + e.message;
                    } else {
                        e = JSON.stringify(e);
                    }
                }
    
                const fullMessage = message + ': ' + e;
                for (let handler of this.#onFailure) {
                    handler('serious', fullMessage);
                }
    
                let toast = DomBuilder.bootstrapToastBuilder();
                toast.setHeaderContent(DomBuilder.element('strong', { style: 'color: red;' }, 'Error'));
                toast.setBodyContent(DomBuilder.par(null, fullMessage));
                toast.show(this.#dialogAnchor);
            }
    
            start() {
                if (this.#sandGame !== null) {
                    if (!this.#simulationEnabled) {
                        this.#sandGame.startProcessing();
                        this.#onStarted.forEach(f => f());
                    }
                }
                this.#simulationEnabled = true;
            }
    
            switchStartStop() {
                this.#simulationEnabled = !this.#simulationEnabled;
                if (this.#sandGame !== null) {
                    if (this.#simulationEnabled) {
                        this.#simulationEnabled = true;
                        this.#sandGame.startProcessing();
                        this.#onStarted.forEach(f => f());
                    } else {
                        this.#sandGame.stopProcessing();
                        this.#onStopped.forEach(f => f());
                    }
                }
            }
    
            /**
             * @returns Snapshot
             */
            createSnapshot() {
                if (this.#sandGame !== null) {
                    let snapshot = this.#sandGame.createSnapshot();
                    snapshot.metadata.scale = this.getCurrentScale();
                    if (this.#init.version !== undefined) {
                        snapshot.metadata.appVersion = this.#init.version;
                    }
                    return snapshot;
                } else {
                    return null;
                }
            }
    
            openScene(scene) {
                for (let handler of this.#onBeforeNewSceneLoaded) {
                    handler(scene);
                }
                this.close();
    
                this.#initialize(scene);
            }
    
            pasteScene(scene) {
                const toolManager = this.getToolManager();
                const revert = toolManager.createRevertAction();
    
                toolManager.setPrimaryTool(Tools.insertScenesTool([ scene ], revert));
                toolManager.setSecondaryTool(Tools.actionTool(revert));
            }
    
            // controller / canvas size
    
            /**
             *
             * @returns {number}
             */
            getCurrentWidthPoints() {
                return this.#currentWidthPoints;
            }
    
            /**
             *
             * @returns {number}
             */
            getCurrentHeightPoints() {
                return this.#currentHeightPoints;
            }
    
            /**
             *
             * @returns {number}
             */
            getCurrentScale() {
                return this.#currentScale;
            }
    
            /**
             *
             * @param width
             * @param height
             * @param scale
             * @returns void
             */
            changeCanvasSize(width, height, scale) {
                if (typeof width !== 'number' || !(width > 0 && width < 2048)) {
                    throw 'Incorrect width';
                }
                if (typeof height !== 'number' || !(height > 0 && height < 2048)) {
                    throw 'Incorrect height';
                }
                if (typeof scale !== 'number' || !(scale > 0 && scale <= 1)) {
                    throw 'Incorrect scale';
                }
    
                this.close();
    
                this.#currentWidthPoints = width;
                this.#currentHeightPoints = height;
                this.#currentScale = scale;
    
                this.#initialize(new SceneImplTmpResize(this.#sandGame.createSnapshot()));
            }
    
            // controller / options
    
            /**
             *
             * @param show {boolean}
             * @returns void
             */
            setShowActiveChunks(show) {
                this.#showActiveChunks = show;
            }
    
            /**
             * @returns {boolean}
             */
            isShowActiveChunks() {
                return this.#showActiveChunks;
            }
    
            /**
             *
             * @param initializer {RendererInitializer}
             * @returns void
             */
            setRendererInitializer(initializer) {
                this.#rendererInitializer = initializer;
                if (this.#sandGame) {
                    this.close();
                    this.#initialize(new SceneImplSnapshot(this.#sandGame.createSnapshot()));
                }
            }
    
            /**
             * @returns {RendererInitializer}
             */
            getRendererInitializer() {
                return this.#rendererInitializer;
            }
    
            /**
             *
             * @param style {string}
             * @returns void
             */
            setCanvasImageRenderingStyle(style) {
                this.#imageRendering = style;
                for (let func of this.#onImageRenderingStyleChanged) {
                    func(style);
                }
            }
    
            /**
             * @returns {string}
             */
            getCanvasImageRenderingStyle() {
                return this.#imageRendering;
            }
    
            /**
             *
             * @param handler {function(string)}
             * @returns void
             */
            addOnImageRenderingStyleChanged(handler) {
                this.#onImageRenderingStyleChanged.push(handler);
            }
    
            // controller / services
    
            /**
             *
             * @returns {ServiceToolManager}
             */
            getToolManager() {
                return this.#serviceToolManager;
            }
    
            /**
             *
             * @returns {ServiceIO}
             */
            getIOManager() {
                return this.#serviceIO;
            }
    
            // controller / ui
    
            /**
             *
             * @returns {HTMLElement}
             */
            getDialogAnchor() {
                return this.#dialogAnchor;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-08
         */
        class SceneImplHardcoded extends Scene {
    
            name;
            description;
    
            /** @type function(SandGame):Promise<any>|any */
            #onCreated;
    
            /** @type function(SandGame) */
            #onOpened;
    
            constructor({name, description, onCreated, onOpened}) {
                super();
                this.#onCreated = onCreated;
                this.#onOpened = onOpened;
                this.name = name;
                this.description = description;
            }
    
            countSize(prefWidth, prefHeight) {
                return [prefWidth, prefHeight];
            }
    
            async createSandGame(prefWidth, prefHeight, defaults, context, rendererInitializer) {
                let elementArea = this.createElementArea(prefWidth, prefHeight, defaults.getDefaultElement());
                let sandGame = new SandGame(elementArea, [], null, defaults, context, rendererInitializer);
                await this.#onCreated(sandGame);
                return sandGame;
            }
    
            createElementArea(prefWidth, prefHeight, defaultElement) {
                return ElementArea.create(prefWidth, prefHeight, defaultElement);
            }
    
            executeOnOpened(sandGame) {
                if (this.#onOpened !== undefined) {
                    this.#onOpened(sandGame);
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-08
         */
        class Scenes {
    
            /**
             *
             * @param name {string}
             * @param onCreated {function(SandGame):Promise<any>|any}
             * @param onOpened {(function(SandGame):void)|undefined}
             */
            static custom(name, onCreated, onOpened = undefined) {
                return new SceneImplHardcoded({
                    name: name,
                    onCreated: onCreated,
                    onOpened: onOpened
                });
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-20
         */
        class SceneDefs {
    
            /** @type Scene */
            static SCENE_EMPTY = new SceneImplHardcoded({
                name: 'Empty',
                description: 'Boxed mode',
                onCreated: function (sandGame) {
                    sandGame.setBoxedMode();
                    // empty
                }
            });
    
            /** @type Scene */
            static SCENE_LANDSCAPE_1 = new SceneImplHardcoded({
                name: 'Landscape 1',
                description: 'Boxed mode',
                onCreated: async function (sandGame) {
                    sandGame.setBoxedMode();
    
                    const soil = sandGame.getBrushCollection().byCodeName('soil');
                    const sand = sandGame.getBrushCollection().byCodeName('sand');
                    const water = sandGame.getBrushCollection().byCodeName('water');
    
                    const m = 40;
                    let layeredPainter = sandGame.layeredTemplate()
                        .layerSpline([[0, 35], [60, 35], [40 + m, 40], [60 + m, 50], [80 + m, 40], [200 + m, 20], [400 + m, 20], [1000 + m, 20]],
                            true, Brushes.concat(soil, BrushDefs.EFFECT_NOISE_LG))
                        .layerSpline([[0, 0], [90 + m, 0], [110 + m, 10], [150 + m, 10], [250 + m, 0]],
                                true, sand, 2)
                        .tool(30, 17, await Resources.parseToolDefinition(TemplateDefs.CABIN))
                        .tool(120 + m, 5, await Resources.parseToolDefinition(TemplateDefs.SAND_CASTLE))
                        .tree(60 + m, 1, 200)
                        .tree(30 + m, 5)
                        .grass(20 + m, 40 + m)
                        .grass(50 + m, 70 + m);
    
                    if (sandGame.getWidth() / sandGame.getHeight() > 1.5) {
                        // wide screens only
                        sandGame.blockTemplate()
                            .withMaxHeight(120)
                            .withBlueprint([
                                '          ',
                                '        ww',
                                '          ',
                                '       1  ',
                                '     111111',
                                '          ',
                                '          ',
                                '          ',
                                '          ',
                            ])
                            .withBrushes({
                                w: Brushes.withIntensity(0.5, water),
                                1: sand
                            })
                            .paint();
                    } else {
                        layeredPainter
                            .layer(26, false, water)
                            .layer(27, false, Brushes.withIntensity(0.33, water));
                    }
    
                    layeredPainter.tool(65, 45, ToolDefs.BIRD);
                    layeredPainter.tool(70, 70, ToolDefs.BIRD);
                    layeredPainter.tool(71, 75, ToolDefs.BIRD);
                    layeredPainter.tool(125, 55, ToolDefs.BIRD);
                    layeredPainter.tool(130, 50, ToolDefs.BIRD);
                }
            });
    
            static SCENE_LANDSCAPE_2 = new SceneImplHardcoded({
                name: 'Landscape 2',
                description: 'Boxed mode',
                onCreated: function (sandGame) {
                    sandGame.setBoxedMode();
    
                    const water = sandGame.getBrushCollection().byCodeName('water');
                    const sand = sandGame.getBrushCollection().byCodeName('sand');
                    const soil = sandGame.getBrushCollection().byCodeName('soil');
                    const gravel = sandGame.getBrushCollection().byCodeName('gravel');
    
                    sandGame.layeredTemplate()
                        .layerSpline([[0, 20], [50, 15], [100, 10], [150, 10], [200, 10], [250, 10], [1250, 10]],
                            true, Brushes.concat(gravel, BrushDefs.EFFECT_NOISE_LG))
                        .layerSpline([[0, 30], [25, 31], [50, 27], [100, 15], [150, 0], [200, 5], [220, 15], [300, 35], [330, 37],
                                [370, 50], [400, 45], [500, 40], [1250, 40]],
                            true, Brushes.concat(soil, BrushDefs.EFFECT_NOISE_LG), 30)
                        .layerSpline([[0, 0], [50, 0], [100, 10], [150, 10], [200, 9], [275, 0], [1250, 0]],
                            true, sand, 5)
                        .layer(35, false, water)
                        .layer(36, false, Brushes.withIntensity(0.33, water))
                        .tool(150, -8, ToolDefs.FISH)
                        .tool(270, 20, ToolDefs.BUTTERFLY)
                        .tool(280, 15, ToolDefs.BUTTERFLY)
                        .grass()
                        .tree(16, 6)
                        .tree(28, 3, 70)
                        .tree(45, 5)
                        .tree(309, 1)
                        .tree(336, 4)
                        .tree(361, 0);
                }
            });
    
            /** @type Scene */
            static SCENE_FALLTHROUGH = new SceneImplHardcoded({
                name: 'Fall-through',
                description: 'Fall-through mode',
                onCreated: function (sandGame) {
                    sandGame.setFallThroughMode();
    
                    const wall = sandGame.getBrushCollection().byCodeName('wall');
                    const water = sandGame.getBrushCollection().byCodeName('water');
                    const sand = sandGame.getBrushCollection().byCodeName('sand');
    
                    const graphics = sandGame.graphics();
                    const xo = Math.trunc((sandGame.getWidth() - 150) / 2 - 15);
                    const yo = Math.trunc((sandGame.getHeight() - 150) / 2);
                    graphics.drawRectangle(40 + xo, 20 + yo, 60 + xo, 40 + yo, water);
                    graphics.drawLine(30 + xo, 30 + yo, 30 + xo, 50 + yo, 5, wall, true);
                    graphics.drawLine(30 + xo, 50 + yo, 70 + xo, 80 + yo, 5, wall, true);
                    graphics.drawLine(65 + xo, 90 + yo, 100 + xo, 100 + yo, 5, wall, true);
                    graphics.drawLine(55 + xo, 140 + yo, 125 + xo, 140 + yo, 10, wall, false);
                    graphics.drawLine(55 + xo, 130 + yo, 55 + xo, 140 + yo, 10, wall, false);
                    graphics.drawLine(70 + xo, 125 + yo, 90 + xo, 125 + yo, 10, sand, false);
                    graphics.draw(120 + xo, 130 + yo, sand);
                    graphics.drawLine(150 + xo, 10 + yo, 80 + xo, 35 + yo, 5, wall, true);
                    graphics.drawLine(80 + xo, 35 + yo, 80 + xo, 15 + yo, 5, wall, true);
                }
            });
    
            /** @type Scene */
            static SCENE_PLATFORM = new SceneImplHardcoded({
                name: 'Platform',
                description: 'Erasing mode',
                onCreated: function (sandGame) {
                    sandGame.setErasingMode();
    
                    const sand = sandGame.getBrushCollection().byCodeName('sand');
                    const wall = sandGame.getBrushCollection().byCodeName('wall');
    
                    sandGame.blockTemplate()
                        .withBlueprint([
                            '          ',
                            '          ',
                            '        w ',
                            '        w ',
                            '          ',
                            '          ',
                            ' ssssssss ',
                            '          ',
                            '          ',
                        ])
                        .withBrushes({
                            w: sand,
                            s: wall
                        })
                        .paint();
                }
            });
    
            static SCENES = {
                empty: SceneDefs.SCENE_EMPTY,
                landscape_1: SceneDefs.SCENE_LANDSCAPE_1,
                landscape_2: SceneDefs.SCENE_LANDSCAPE_2,
                fallthrough: SceneDefs.SCENE_FALLTHROUGH,
                platform: SceneDefs.SCENE_PLATFORM
            };
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class Entities {
    
            static bird(x = undefined, y = undefined) {
                return { entity: 'bird', x: x, y: y };
            }
    
            static butterfly(x = undefined, y = undefined) {
                return { entity: 'butterfly', x: x, y: y };
            }
    
            static fish(x = undefined, y = undefined) {
                return { entity: 'fish', x: x, y: y };
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2023-08-19
         */
        class Action {
    
            /**
             *
             * @param controller {Controller}
             * @returns void
             */
            performAction(controller) {
                throw 'Not implemented';
            }
    
            /**
             *
             * @param func {function(controller:Controller):void}
             * @returns {ActionAnonymous}
             */
            static create(func) {
                return new ActionAnonymous(func);
            }
    
            /**
             *
             * @param def {boolean}
             * @param func {function(controller:Controller,v:boolean):void}
             * @returns {ActionAnonymous}
             */
            static createToggle(def, func) {
                let state = def;
                return new ActionAnonymous(function (c) {
                    state = !state;
                    func(c, state);
                });
            }
        }
    
        class ActionAnonymous extends Action {
            #func;
    
            constructor(func) {
                super();
                this.#func = func;
            }
    
            performAction(controller) {
                this.#func(controller);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-08
         */
        class ComponentViewTemplateSelection extends Component {
    
            #templateDefinitions;
    
            constructor(templateDefinitions) {
                super();
                this.#templateDefinitions = templateDefinitions;
            }
    
            createNode(controller) {
                let buttons = [];
    
                for (const toolDefinition of this.#templateDefinitions) {
                    const name = toolDefinition.info.displayName;
                    let loadedTool = null;
    
                    let button = DomBuilder.button(name, { class: 'btn btn-light template-button', 'data-bs-dismiss': 'modal'}, () => {
                        if (loadedTool !== null) {
    
                            const toolManager = controller.getToolManager();
                            const revert = toolManager.createRevertAction();
    
                            toolManager.setPrimaryTool(loadedTool);
                            toolManager.setSecondaryTool(Tools.actionTool(revert));
    
                        }
                    });
                    if (toolDefinition.info.icon !== undefined) {
                        button.style.backgroundImage = `url(${ toolDefinition.info.icon.imageData })`;
                    }
    
                    buttons.push(button);
    
                    Resources.parseToolDefinition(toolDefinition).then(tool => {
                        loadedTool = tool;
                    }).catch(e => {
                        console.warn('Template loading failed: ' + e);
                    });
                }
    
                return DomBuilder.div({ class: 'sand-game-templates' }, buttons);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-08
         */
        class ActionDialogTemplateSelection extends Action {
    
            #templateDefinitions;
            #additionalInfo;
    
            constructor(templateDefinitions, additionalInfo = null) {
                super();
                this.#templateDefinitions = templateDefinitions;
                this.#additionalInfo = additionalInfo;
            }
    
            performAction(controller) {
                let templatesComponent = new ComponentViewTemplateSelection(this.#templateDefinitions);
    
                let dialog = DomBuilder.bootstrapDialogBuilder();
                dialog.setHeaderContent('Templates');
                dialog.setBodyContent(DomBuilder.div({ class: 'sand-game-component' }, [
                    DomBuilder.par(null, "Select a template"),
                    templatesComponent.createNode(controller),
                    this.#additionalInfo
                ]));
                dialog.addCloseButton('Close');
                dialog.show(controller.getDialogAnchor());
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-08
         */
        class ComponentViewTools extends Component {
    
            /** @type Tool[] */
            #tools;
            /** @type boolean */
            #importEnabled;
            /** @type boolean */
            #enableBigButtons;
    
            /**
             * @param tools {Tool[]}
             * @param importEnabled {boolean}
             * @param enableBigButtons {boolean}
             */
            constructor(tools, importEnabled = false, enableBigButtons = false) {
                super();
                this.#tools = tools;
                this.#importEnabled = importEnabled;
                this.#enableBigButtons = enableBigButtons;
            }
    
            createNode(controller) {
                let buttons = [];
    
                const buttonType = this.#enableBigButtons ? ' btn-sand-game-tool-big' : ' btn-sand-game-tool';
    
                const initButton = (button, tool) => {
                    button.addEventListener('click', () => {
                        this.#selectTool(tool, controller);
                    });
    
                    controller.getToolManager().addOnPrimaryToolChanged(newTool => {
                        if (newTool === tool) {
                            button.classList.add('selected');
                        } else {
                            button.classList.remove('selected');
                        }
                    });
    
                    // initial select
                    if (tool === controller.getToolManager().getPrimaryTool()) {
                        button.classList.add('selected');
                    }
    
                    controller.getToolManager().addOnInputDisabledChanged(disabled => {
                        button.disabled = disabled;
                    });
                };
    
                for (let tool of this.#tools) {
                    let codeName = tool.getInfo().getCodeName();
                    let displayName = tool.getInfo().getDisplayName();
                    let badgeStyle = tool.getInfo().getBadgeStyle();
    
                    if (tool instanceof SelectionFakeTool) {
    
                        const ulContent = [];
                        for (const innerTool of tool.getTools()) {
                            innerTool.getInfo().getCodeName();
                            let innerDisplayName = innerTool.getInfo().getDisplayName();
                            let innerBadgeStyle = innerTool.getInfo().getBadgeStyle();
    
                            const innerLabel = DomBuilder.span(innerDisplayName, {
                                class: 'btn btn-secondary' + buttonType + ' ' + codeName,
                                style: innerBadgeStyle,
                            });
                            const innerToolAttributes = {
                                class: 'dropdown-item',
                            };
                            const innerButton = DomBuilder.button(innerLabel, innerToolAttributes);
                            initButton(innerButton, innerTool);
                            ulContent.push(DomBuilder.element('li', null, innerButton));
                        }
    
                        const button = DomBuilder.div({ class: 'btn-group' }, [
                            DomBuilder.button(displayName, {
                                class: 'btn btn-secondary dropdown-toggle ' + buttonType + ' ' + codeName,
                                style: badgeStyle,
                                'data-bs-toggle': 'dropdown',
                                'aria-expanded': 'false'
                            }),
                            DomBuilder.element('ul', {
                                class: 'dropdown-menu'
                            }, ulContent)
                        ]);
    
                        buttons.push(button);
    
                    } else {
                        const attributes = {
                            class: 'btn btn-secondary ' + buttonType + ' ' + codeName,
                            style: badgeStyle
                        };
                        const button = DomBuilder.button(displayName, attributes);
                        initButton(button, tool);
                        buttons.push(button);
                    }
                }
    
                return DomBuilder.div({ class: 'sand-game-tools' }, buttons);
            }
    
            #selectTool(tool, controller) {
                if (tool instanceof TemplateSelectionFakeTool) {
                    let additionalInfo = null;
                    if (this.#importEnabled) {
                        additionalInfo = DomBuilder.div(null, [
                            DomBuilder.par(null, ""),
                            DomBuilder.par(null, "You can also create your own template using an image. See the Import button.")
                        ]);
                    }
                    const action = new ActionDialogTemplateSelection(tool.getTemplateDefinitions(), additionalInfo);
                    action.performAction(controller);
                } else if (tool instanceof GlobalActionTool) {
                    const handler = tool.getHandler();
                    const sandGame = controller.getSandGame();
                    if (sandGame !== null) {
                        handler(sandGame);
                    }
                } else {
                    controller.getToolManager().setPrimaryTool(tool);
                    controller.getToolManager().setSecondaryTool(ToolDefs.ERASE);
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-07
         */
        class ComponentViewCanvasOverlayDebug extends Component {
    
            /** @type Controller */
            #controller;
    
            #nodeOverlay;
    
            #nodeLabel = null;
            #nodeRectangles = null;
    
            #w;
            #h;
            #scale;
    
            constructor(w, h, scale, controller) {
                super();
                this.#w = w;
                this.#h = h;
                this.#scale = scale;
                const wPx = w / scale;
                const hPx = h / scale;
                this.#nodeOverlay = DomBuilder.div({
                    style: {
                        display: 'none',  // hidden by default
                        position: 'absolute',
                        left: '0',
                        top: '0',
                        width: `${wPx}px`,
                        height: `${hPx}px`
                    },
                    class: 'sand-game-canvas-overlay',
                    width: w + 'px',
                    height: h + 'px',
                });
                this.#controller = controller;
            }
    
            /**
             *
             * @param changedChunks {boolean[]}
             */
            highlightChunks(changedChunks) {
                if (changedChunks === null) {
                    if (this.#nodeRectangles !== null) {
                        // hide
                        this.#nodeOverlay.style.display = 'none';
                    }
                    return;
                }
    
                if (this.#nodeRectangles === null) {
                    this.#init();
                }
                this.#nodeOverlay.style.display = 'unset';
                this.#update(changedChunks);
            }
    
            #update(changedChunks) {
                const sandGame = this.#controller.getSandGame();
                const chunkSize = sandGame.getChunkSize();
                const horChunkCount = Math.ceil(sandGame.getWidth() / chunkSize);
                const verChunkCount = Math.ceil(sandGame.getHeight() / chunkSize);
    
                let highlighted = 0;
                for (let cy = 0; cy < verChunkCount; cy++) {
                    for (let cx = 0; cx < horChunkCount; cx++) {
                        const chunkIndex = cy * horChunkCount + cx;
                        const rect = this.#nodeRectangles[chunkIndex];
                        if (changedChunks[chunkIndex]) {
                            highlighted++;
                            rect.style.display = 'initial';
                        } else {
                            rect.style.display = 'none';
                        }
                    }
                }
    
                // show stats
                const total = horChunkCount * verChunkCount;
                const highlightedPercent = Math.trunc(highlighted / total * 100);
                this.#nodeLabel.textContent = `${highlighted}/${total} (${highlightedPercent}%)`;
            }
    
            #init() {
                const sandGame = this.#controller.getSandGame();
                const chunkSize = sandGame.getChunkSize();
                const horChunkCount = Math.ceil(sandGame.getWidth() / chunkSize);
                const verChunkCount = Math.ceil(sandGame.getHeight() / chunkSize);
    
                const rects = Array(verChunkCount * horChunkCount);
                for (let cy = 0; cy < verChunkCount; cy++) {
                    for (let cx = 0; cx < horChunkCount; cx++) {
                        const chunkIndex = cy * horChunkCount + cx;
                        rects[chunkIndex] = this.#createRectangle(cx, cy, chunkSize);
                    }
                }
    
                this.#nodeRectangles = rects;
                this.#nodeOverlay.append(...rects);
    
                this.#nodeLabel = this.#createLabel(0, 0);
                this.#nodeOverlay.append(this.#nodeLabel);
            }
    
            #createLabel(x, y) {
                const xPx = x / this.#scale;
                const yPx = y / this.#scale;
                return DomBuilder.span('', {
                    style: {
                        left: xPx + 'px',
                        top: yPx + 'px',
                        position: 'absolute',
                        color: 'rgb(0, 255, 0)'
                    }
                });
            }
    
            #createRectangle(cx, cy, chunkSize) {
                const wPx = this.#w / this.#scale;
                const hPx = this.#h / this.#scale;
                const xPx = cx * chunkSize / this.#scale;
                const yPx = cy * chunkSize / this.#scale;
                const cwPx = chunkSize / this.#scale;
                const chPx = chunkSize / this.#scale;
    
                const rectangle = DomBuilder.div({
                    style: {
                        left: xPx + 'px',
                        top: yPx + 'px',
                        width: cwPx + 'px',
                        height: chPx + 'px',
                        position: 'absolute',
                        outline: 'rgb(0, 255, 0) 1px solid'
                    }
                });
    
                if (xPx + cwPx >= wPx || yPx + chPx >= hPx) {
                    // clip
    
                    const UNSET = -1;  // expect border
                    const pxClipTop = UNSET;
                    const pxClipRight = xPx + cwPx >= wPx ? xPx + cwPx - wPx : UNSET;
                    const pxClipBottom = yPx + chunkSize >= hPx ? yPx + chPx - hPx : UNSET;
                    const pxClipLeft = UNSET;
    
                    rectangle.style.clipPath = `inset(${pxClipTop}px ${pxClipRight}px ${pxClipBottom}px ${pxClipLeft}px)`;
                }
    
                return rectangle;
            }
    
            createNode(controller) {
                return this.#nodeOverlay;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-17
         */
        class ComponentViewCanvasOverlayMarker extends Component {
    
            /** @type Controller */
            #controller;
    
            #nodeOverlay;
    
            #w;
            #h;
            #scale;
    
            constructor(w, h, scale, controller) {
                super();
                this.#w = w;
                this.#h = h;
                this.#scale = scale;
                const wPx = w / scale;
                const hPx = h / scale;
                this.#nodeOverlay = DomBuilder.div({
                    style: {
                        display: 'none',  // hidden by default
                        position: 'absolute',
                        left: '0',
                        top: '0',
                        width: `${wPx}px`,
                        height: `${hPx}px`
                    },
                    class: 'sand-game-canvas-overlay',
                    width: w + 'px',
                    height: h + 'px',
                });
                this.#controller = controller;
            }
    
            /**
             *
             * @param overlay {SandGameOverlay}
             */
            register(overlay) {
                const markers = overlay.getMarkers();
                if (markers.length > 0) {
                    for (const marker of markers) {
                        this.#nodeOverlay.append(this.#createMarkerNode(marker));
                    }
                    this.#nodeOverlay.style.display = 'initial';
                }
    
                // future markers
                overlay.addOnMarkerAdded((marker) => {
                    this.#nodeOverlay.append(this.#createMarkerNode(marker));
                    this.#nodeOverlay.style.display = 'initial';
                });
            }
    
            /**
             *
             * @param marker {Marker}
             * @returns {HTMLElement}
             */
            #createMarkerNode(marker) {
                const config = marker.getConfig();
    
                const [x1, y1, x2, y2] = marker.getPosition();
                const rectangle = this.#createRectangle(x1, y1, x2, y2, config.label);
                if (typeof config.style === 'object') {
                    for (const [key, value] of Object.entries(config.style)) {
                        rectangle.style[key] = value;
                    }
                }
                if (!marker.isVisible()) {
                    rectangle.style.display = 'none';
                }
                marker.addOnVisibleChanged((visible) => {
                    rectangle.style.display = visible ? 'initial' : 'none';
                });
                return rectangle;
            }
    
            #createRectangle(x1, y1, x2, y2, content = null) {
                const xPx = x1 / this.#scale;
                const yPx = y1 / this.#scale;
                const wPx = (x2 - x1) / this.#scale;
                const hPx = (y2 - y1) / this.#scale;
    
                const attributes = {
                    class: 'sand-game-marker',
                    style: {
                        left: xPx + 'px',
                        top: yPx + 'px',
                        width: wPx + 'px',
                        height: hPx + 'px',
                        position: 'absolute',
                    }
                };
    
                return DomBuilder.div(attributes, content);
            }
    
            createNode(controller) {
                return this.#nodeOverlay;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-07
         */
        class ComponentViewCanvasOverlayCursor extends Component {
    
            /** @type Controller */
            #controller;
    
            #nodeOverlay;
    
            /** @type {{node:any,width:number,height:number}|null} */
            #cursor = null;
    
            constructor(w, h, scale, controller) {
                super();
                const wPx = w / scale;
                const hPx = h / scale;
                this.#nodeOverlay = DomBuilder.div({
                    style: {
                        position: 'absolute',
                        left: '0',
                        top: '0',
                        width: `${wPx}px`,
                        height: `${hPx}px`
                    },
                    class: 'sand-game-canvas-overlay',
                    width: w + 'px',
                    height: h + 'px',
                });
                this.#controller = controller;
            }
    
            createNode(controller) {
                return this.#nodeOverlay;
            }
    
            hideCursors() {
                this.#nodeOverlay.innerHTML = '';
                this.#cursor = null;
            }
    
            repaintRectangleSelection(lastX, lastY, x, y, scale) {
                this.#nodeOverlay.innerHTML = '';
    
                let xPx = Math.min(lastX, x) / scale;
                let yPx = Math.min(lastY, y) / scale;
                let wPx = Math.abs(x - lastX) / scale;
                let hPx = Math.abs(y - lastY) / scale;
    
                const selection = DomBuilder.div({
                    style: {
                        left: xPx + 'px',
                        top: yPx + 'px',
                        width: wPx + 'px',
                        height: hPx + 'px',
                        position: 'absolute',
                        outline: 'black 1px solid',
                        pointerEvents: 'none'
                    }
                });
                this.#nodeOverlay.append(selection);
            }
    
            repaintLineSelection(lastX, lastY, x, y, scale) {
                this.#nodeOverlay.innerHTML = '';
    
                const w = this.#controller.getCurrentWidthPoints();
                const h = this.#controller.getCurrentHeightPoints();
    
                const line = DomBuilder.create(`
                <svg viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">
                  <line x1="${lastX}" y1="${lastY}" x2="${x}" y2="${y}" stroke="black" />
                </svg>
            `);
                line.style.pointerEvents = 'none';
                this.#nodeOverlay.append(line);
            }
    
            showCursor(x, y, scale, cursorDefinition) {
                if (cursorDefinition instanceof CursorDefinitionElementArea) {
                    const wPx = Math.trunc(cursorDefinition.getWidth() / scale);
                    const hPx = Math.trunc(cursorDefinition.getHeight() / scale);
    
                    const node = DomBuilder.element('canvas', {
                        width: cursorDefinition.getWidth() + 'px',
                        height: cursorDefinition.getHeight() + 'px',
                        style: {
                            width: `${wPx}px`,
                            height: `${hPx}px`,
                            outline: 'black 1px solid'
                        }
                    });
    
                    // render preview
                    node.style.imageRendering = 'pixelated';
                    Renderer2D.renderPreview(cursorDefinition.getElementArea(), node.getContext('2d'), 0xBB);
    
                    this.#cursor = {
                        width: wPx,
                        height: hPx,
                        node: node
                    };
                } else {
                    return;
                }
    
                this.#cursor.node.style.position = 'absolute';
                this.#cursor.node.style.pointerEvents = 'none';
    
                this.moveCursor(x, y, scale);
            }
    
            hasCursor() {
                return this.#cursor !== null;
            }
    
            moveCursor(x, y, scale) {
                const cursor = this.#cursor;
    
                const pxW = this.#controller.getCurrentWidthPoints() / scale;
                const pxH = this.#controller.getCurrentHeightPoints() / scale;
    
                const pxTop = y / scale - Math.trunc(cursor.height / 2);
                const pxLeft = x / scale - Math.trunc(cursor.width / 2);
    
                const UNSET = -1;  // expect border
                const pxClipTop = pxTop < 0 ? -pxTop : UNSET;
                const pxClipRight = pxLeft + cursor.width >= pxW ? pxLeft + cursor.width - pxW : UNSET;
                const pxClipBottom = pxTop + cursor.height >= pxH ? pxTop + cursor.height - pxH : UNSET;
                const pxClipLeft = pxLeft < 0 ? -pxLeft : UNSET;
    
                cursor.node.style.top = pxTop + 'px';
                cursor.node.style.left = pxLeft + 'px';
                cursor.node.style.clipPath = `inset(${pxClipTop}px ${pxClipRight}px ${pxClipBottom}px ${pxClipLeft}px)`;
    
                this.#nodeOverlay.innerHTML = '';
                this.#nodeOverlay.append(cursor.node);
            }
        }
    
        var _ASSET_ICON_SQUARE = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-square\" viewBox=\"0 0 16 16\">\n    <path d=\"M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2z\"/>\n</svg>";
    
        var _ASSET_ICON_SQUARE_CHECK = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-check-square-fill\" viewBox=\"0 0 16 16\">\n    <path d=\"M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm10.03 4.97a.75.75 0 0 1 .011 1.05l-3.992 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.75.75 0 0 1 1.08-.022z\"/>\n</svg>";
    
        var _ASSET_ICON_SQUARE_DOTTED = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-square-dotted\" viewBox=\"0 0 16 16\">\n    <path d=\"m2.5 0q-.25 0-.487.048l.194.98a1.5 1.5 0 01.293-.028h.458v-1zm2.292 0h-.917v1h.917zm1.833 0h-.917v1h.917zm1.833 0h-.916v1h.916zm1.834 0h-.917v1h.917zm1.833 0h-.917v1h.917zm1.375 0h-.458v1h.458q.151 0 .293.029l.194-.981a2.5 2.5 0 00-.487-.048m2.079 1.11a2.5 2.5 0 00-.69-.689l-.556.831q.248.167.415.415l.83-.556zm-14.469-.689a2.5 2.5 0 00-.689.69l.831.556c.11-.164.251-.305.415-.415zm14.89 2.079q0-.25-.048-.487l-.98.194q.027.141.028.293v.458h1zm-15.952-.487a2.5 2.5 0 00-.048.487v.458h1v-.458q0-.151.029-.293zm-.048 1.862v.917h1v-.917zm16 .917v-.917h-1v.917zm-16 .916v.917h1v-.917zm16 .917v-.917h-1v.917zm-16 .917v.916h1v-.916zm15 .916h1v-.916h-1zm-15 .917v.917h1v-.917zm16 .917v-.917h-1v.917zm-16 .916v.917h1v-.917zm16 .917v-.917h-1v.917zm-16 .917v.458q0 .25.048.487l.98-.194a1.5 1.5 0 01-.028-.293v-.458zm16 .458v-.458h-1v.458q0 .151-.029.293l.981.194q.048-.237.048-.487m-15.579 1.39c.183.272.417.506.69.689l.556-.831a1.5 1.5 0 01-.415-.415zm14.469.689c.272-.183.506-.417.689-.69l-.831-.556c-.11.164-.251.305-.415.415l.556.83zm-12.877.373q.237.048.487.048h.458v-1h-.458q-.151 0-.293-.029zm11.487.048q.25 0 .487-.048l-.194-.98a1.5 1.5 0 01-.293.028h-.458v1zm-9.625 0h.917v-1h-.917zm1.833 0h.917v-1h-.917zm1.834 0h.916v-1h-.916zm1.833 0h.917v-1h-.917zm1.833 0h.917v-1h-.917z\"/>\n</svg>";
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-19
         */
        class ComponentViewCanvasOverlayScenario extends Component {
    
            /** @type Controller */
            #controller;
    
            #nodeOverlay;
    
            #w;
            #h;
            #scale;
    
            constructor(w, h, scale, controller) {
                super();
                this.#w = w;
                this.#h = h;
                this.#scale = scale;
                const wPx = w / scale;
                const hPx = h / scale;
                this.#nodeOverlay = DomBuilder.div({
                    style: {
                        display: 'none',  // hidden by default
                        position: 'absolute',
                        left: '0',
                        top: '0',
                        width: `${wPx}px`,
                        height: `${hPx}px`,
                        pointerEvents: 'none'
                    },
                    class: 'sand-game-canvas-overlay',
                    width: w + 'px',
                    height: h + 'px',
                });
                this.#controller = controller;
            }
    
            /**
             *
             * @param overlay {SandGameScenario}
             */
            register(overlay) {
                let visible = false;
                const addNode = (node) => {
                    this.#nodeOverlay.append(node);
                    if (!visible) {
                        visible = true;
                        this.#nodeOverlay.style.display = null;
                    }
                };
    
                // handles splashes
                for (const splash of overlay.getSplashes()) {
                    addNode(this.#createSplashNode(splash));
                }
                overlay.addOnSplashAdded((splash) => {
                    addNode(this.#createSplashNode(splash));
                });
    
                // handle objectives
                let objectiveParent = null;
                let visibleNodes = 0;
                const addObjective = (objective) => {
                    const node = this.#createObjectiveNode(objective);
                    if (objectiveParent === null) {
                        if (objective.isVisible()) {
                            visibleNodes++;
                        }
                        objectiveParent = this.#createObjectivesListNode();
                        objectiveParent.style.display = (visibleNodes > 0) ? null : 'none';
                        addNode(objectiveParent);
                    }
                    objectiveParent.append(node);
                    objective.addOnVisibleChanged(visible => {
                        visibleNodes += (visible) ? 1 : -1;
                        objectiveParent.style.display = (visibleNodes > 0) ? null : 'none';
                    });
                };
                for (const objective of overlay.getObjectives()) {
                    addObjective(objective);
                }
                overlay.addOnObjectiveAdded((objective) => {
                    addObjective(objective);
                });
            }
    
            /**
             *
             * @param splash {Splash}
             * @returns {HTMLElement}
             */
            #createSplashNode(splash) {
                let config = splash.getConfig();
    
                let splashAttributes = {
                    class: 'sand-game-splash',
                    style: {
                        display: splash.isVisible() ? null : 'none'
                    }
                };
                Object.assign(splashAttributes.style, config.style);
    
                let contentAttributes = {
                    class: 'sand-game-splash-content'
                };
    
                let footerAttributes = {
                    class: 'sand-game-splash-footer'
                };
    
                let splashNode = DomBuilder.div(splashAttributes, [
                    DomBuilder.div(contentAttributes, config.content),
                    DomBuilder.div(footerAttributes, config.buttons.filter(button => button !== null).map(button => {
                        let buttonNode;
                        if (typeof button.action === 'string') {
                            buttonNode = DomBuilder.element('a', {
                                href: button.action,
                                class: button.class
                            }, button.title);
                        } else if (typeof button.action === 'function') {
                            buttonNode = DomBuilder.button(button.title, {
                                class: button.class,
                            }, () => button.action(splash));
                        } else {
                            throw 'Button action type not supported: ' + (typeof button.action);
                        }
    
                        if (button.focus) {
                            setTimeout(() => {
                                buttonNode.focus({
                                    preventScroll: true
                                });
                            }, 0);
                        }
                        return buttonNode;
                    }))
                ]);
    
                splash.addOnVisibleChanged((visible) => {
                     splashNode.style.display = visible ? null : 'none';
                });
    
                return splashNode;
            }
    
            #createObjectivesListNode() {
                return DomBuilder.div({ class: 'sand-game-objectives-list' }, null);
            }
    
            /**
             *
             * @param objective {Objective}
             * @returns {HTMLElement}
             */
            #createObjectiveNode(objective) {
                const iconNode = DomBuilder.span(null, { class: 'sand-game-objective-icon' });
                if (objective.isVisible()) {
                    DomBuilder.setContent(iconNode, this.#createObjectiveIcon(objective));
                }
    
                const attributes = {
                    style: {
                        display: objective.isVisible() ? null : 'none'
                    }
                };
                const objectiveNode = DomBuilder.div(attributes, [
                    iconNode,
                    objective.getConfig().name
                ]);
    
                objective.addOnVisibleChanged((visible) => {
                    objectiveNode.style.display = visible ? null : 'none';
                    if (visible) {
                        DomBuilder.setContent(iconNode, this.#createObjectiveIcon(objective));
                    }
                });
    
                objective.addOnActiveChanged((active) => {
                    if (objective.isVisible()) {
                        DomBuilder.setContent(iconNode, this.#createObjectiveIcon(objective));
                    }
                });
    
                objective.addOnCompleted(() => {
                    if (objective.isVisible()) {
                        DomBuilder.setContent(iconNode, this.#createObjectiveIcon(objective));
                    }
                });
    
                return objectiveNode;
            }
    
            #createObjectiveIcon(objective) {
                if (objective.isCompleted()) {
                    return DomBuilder.create(_ASSET_ICON_SQUARE_CHECK);
                }
                if (objective.isActive()) {
                    return DomBuilder.create(_ASSET_ICON_SQUARE);
                }
                return DomBuilder.create(_ASSET_ICON_SQUARE_DOTTED);
            }
    
            createNode(controller) {
                return this.#nodeOverlay;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         *
         * @author Patrik Harag
         * @version 2024-01-15
         */
        class ComponentViewCanvasInner extends Component {
    
            /** @type Controller */
            #controller;
    
            #nodeCanvas;
    
            /** @type ComponentViewCanvasOverlayDebug */
            #debugOverlayComponent;
            #nodeDebugOverlay;
    
            /** @type ComponentViewCanvasOverlayMarker */
            #markerOverlayComponent;
            #nodeMarkerOverlay;
    
            /** @type ComponentViewCanvasOverlayCursor */
            #cursorOverlayComponent;
            #nodeCursorOverlay;
    
            /** @type ComponentViewCanvasOverlayScenario */
            #scenarioOverlayComponent;
            #nodeScenarioOverlay;
    
            /**
             * @param controller {Controller}
             */
            constructor(controller) {
                super();
                this.#controller = controller;
    
                const w = this.#controller.getCurrentWidthPoints();
                const h = this.#controller.getCurrentHeightPoints();
                const scale = this.#controller.getCurrentScale();
                this.#nodeCanvas = this.#createCanvas(w, h, scale);
    
                this.#debugOverlayComponent = new ComponentViewCanvasOverlayDebug(w, h, scale, controller);
                this.#nodeDebugOverlay = this.#debugOverlayComponent.createNode();
    
                this.#markerOverlayComponent = new ComponentViewCanvasOverlayMarker(w, h, scale, controller);
                this.#nodeMarkerOverlay = this.#markerOverlayComponent.createNode();
    
                this.#cursorOverlayComponent = new ComponentViewCanvasOverlayCursor(w, h, scale, controller);
                this.#nodeCursorOverlay = this.#cursorOverlayComponent.createNode();
    
                this.#scenarioOverlayComponent = new ComponentViewCanvasOverlayScenario(w, h, scale, controller);
                this.#nodeScenarioOverlay = this.#scenarioOverlayComponent.createNode();
            }
    
            #createCanvas(w, h, scale) {
                const wPx = w / scale;
                const hPx = h / scale;
                const canvas = DomBuilder.element('canvas', {
                    style: `position: relative; width: ${wPx}px; height: ${hPx}px;`,
                    class: 'sand-game-canvas',
                    width: w + 'px',
                    height: h + 'px'
                });
    
                // rendering style
                canvas.style.imageRendering = this.#controller.getCanvasImageRenderingStyle();
    
                return canvas;
            }
    
            createNode(controller) {
                return DomBuilder.div({
                    style: 'position: relative;',
                    class: 'sand-game-canvas-component'
                }, [
                    this.#nodeCanvas,
                    this.#nodeDebugOverlay,
                    this.#nodeMarkerOverlay,
                    this.#nodeCursorOverlay,
                    this.#nodeScenarioOverlay,
                ]);
            }
    
            /**
             *
             * @param sandGame {SandGame}
             */
            register(sandGame) {
                this.#markerOverlayComponent.register(sandGame.overlay());
                this.#scenarioOverlayComponent.register(sandGame.scenario());
    
                // chunk highlighting
                sandGame.addOnRendered((changedChunks) => {
                    if (this.#controller.isShowActiveChunks()) {
                        this.#debugOverlayComponent.highlightChunks(changedChunks);
                    } else {
                        this.#debugOverlayComponent.highlightChunks(null);
                    }
                });
    
                this.#initMouseHandling(sandGame);
            }
    
            #initMouseHandling(sandGame) {
                const domNode = this.#nodeCursorOverlay;
                const scale = this.#controller.getCurrentScale();
    
                const toolManager = this.#controller.getToolManager();
    
                let getActualMousePosition = (e) => {
                    const rect = domNode.getBoundingClientRect();
                    const x = Math.max(0, Math.trunc((e.clientX - rect.left) * scale));
                    const y = Math.max(0, Math.trunc((e.clientY - rect.top) * scale));
                    return [x, y];
                };
    
                let lastX, lastY;
                let lastTool = null;  // drawing is not active if null
                let drag = false;
                let ctrlPressed = false;
                let shiftPressed = false;
    
                let repeatingInterval = null;
                const startRepeatingIfEnabled = (x, y, altKey) => {
                    if (lastTool.isRepeatingEnabled()) {
                        repeatingInterval = setInterval(() => {
                            lastTool.applyPoint(x, y, sandGame.graphics(), altKey);
                        }, 80);
                    }
                };
                const cancelRepeatingIfNeeded = () => {
                    if (repeatingInterval !== null) {
                        clearInterval(repeatingInterval);
                        repeatingInterval = null;
                    }
                };
    
                // disable context menu
                this.#nodeCursorOverlay.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    return false;
                });
    
                domNode.addEventListener('mousedown', (e) => {
                    if (toolManager.isInputDisabled()) {
                        return;
                    }
    
                    const [x, y] = getActualMousePosition(e);
                    lastX = x;
                    lastY = y;
                    lastTool = null;
                    drag = false;
                    ctrlPressed = false;
                    shiftPressed = false;
    
                    if (e.buttons === 1) {
                        // primary button
                        lastTool = toolManager.getPrimaryTool();
                        Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_PRIMARY);
    
                    } else if (e.buttons === 2) {
                        // secondary button
                        let primaryTool = toolManager.getPrimaryTool();
                        if (primaryTool.isSecondaryActionEnabled()) {
                            // special secondary action
    
                            primaryTool.applySecondaryAction(x, y, sandGame.graphics(), e.altKey);
    
                            // hide cursors
                            this.#cursorOverlayComponent.hideCursors();
    
                            cancelRepeatingIfNeeded();
    
                            return;
                        } else {
                            lastTool = toolManager.getSecondaryTool();
                            Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_SECONDARY);
                        }
                    } else if (e.buttons === 4) {
                        // middle button
                        e.preventDefault();
    
                        if (!e.altKey && !e.ctrlKey && !e.shiftKey) {
                            const tool = toolManager.getTertiaryTool();
                            tool.applyPoint(x, y, sandGame.graphics(), false);
                            Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_TERTIARY);
                            Analytics.triggerToolUsed(tool);
                        } else if (e.altKey && e.ctrlKey && e.shiftKey) {
                            console.log('' + x + 'x' + y + ': ' + sandGame.debugElementAt(x, y));
                        }
                        return;
                    } else {
                        // mouse wheel, other combinations, etc.
                        return;
                    }
    
                    if (!e.ctrlKey && !e.shiftKey) {
                        lastTool.applyPoint(x, y, sandGame.graphics(), e.altKey);
                        Analytics.triggerToolUsed(lastTool);
    
                        // repeating when holding mouse down on a position
                        startRepeatingIfEnabled(x, y, e.altKey);
    
                        // show/recreate cursor
                        this.#cursorOverlayComponent.hideCursors();
                        const cursorDefinition = toolManager.getPrimaryTool().createCursor();
                        if (cursorDefinition !== null) {
                            this.#cursorOverlayComponent.showCursor(x, y, scale, cursorDefinition);
                        }
    
                    } else if (e.ctrlKey && e.shiftKey) {
                        lastTool.applySpecial(x, y, sandGame.graphics(), e.altKey);
                        Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_FLOOD);
                        Analytics.triggerToolUsed(lastTool);
                        lastTool = null;
                    } else {
                        if (e.ctrlKey && lastTool.isAreaModeEnabled()) {
                            ctrlPressed = e.ctrlKey;
                        }
                        if (e.shiftKey && lastTool.isLineModeEnabled()) {
                            shiftPressed = e.shiftKey;
                        }
                    }
                });
                domNode.addEventListener('mousemove', (e) => {
                    // cancel repeating
                    cancelRepeatingIfNeeded();
    
                    if (toolManager.isInputDisabled()) {
                        lastTool = null;
                        this.#cursorOverlayComponent.hideCursors();
                        return;
                    }
    
                    if (!ctrlPressed && !shiftPressed) {
                        // drawing while dragging...
    
                        // show / move cursor
                        if (this.#cursorOverlayComponent.hasCursor()) {
                            const [x, y] = getActualMousePosition(e);
                            this.#cursorOverlayComponent.moveCursor(x, y, scale);
                        } else {
                            const cursorDefinition = toolManager.getPrimaryTool().createCursor();
                            if (cursorDefinition !== null) {
                                const [x, y] = getActualMousePosition(e);
                                this.#cursorOverlayComponent.showCursor(x, y, scale, cursorDefinition);
                            }
                        }
    
                        if (lastTool === null) {
                            return;
                        }
    
                        const [x, y] = getActualMousePosition(e);
    
                        // drag action
                        if (!drag) {
                            lastTool.onDragStart(lastX, lastY, sandGame.graphics(), e.altKey);
                            drag = true;
                        }
    
                        // stroke action
                        lastTool.applyStroke(lastX, lastY, x, y, sandGame.graphics(), e.altKey);
                        Analytics.triggerToolUsed(lastTool);
    
                        // repeating when holding mouse down on a position
                        startRepeatingIfEnabled(x, y, e.altKey);
    
                        lastX = x;
                        lastY = y;
    
                        return;
                    }
    
                    if (lastTool === null) {
                        return;
                    }
                    if (ctrlPressed && shiftPressed) {
                        return;
                    }
                    if (ctrlPressed) {
                        const [x, y] = getActualMousePosition(e);
                        this.#cursorOverlayComponent.repaintRectangleSelection(lastX, lastY, x, y, scale);
                        return;
                    }
                    if (shiftPressed) {
                        const [x, y] = getActualMousePosition(e);
                        this.#cursorOverlayComponent.repaintLineSelection(lastX, lastY, x, y, scale);
                        return;
                    }
                });
                domNode.addEventListener('mouseup', (e) => {
                    // cancel repeating
                    cancelRepeatingIfNeeded();
    
                    if (toolManager.isInputDisabled()) {
                        return;
                    }
    
                    if (lastTool !== null) {
                        // click, dragging, rectangle or line
                        if (drag) {
                            lastTool.onDragEnd(lastX, lastY, sandGame.graphics(), e.altKey);
                            drag = false;
                            if (!lastTool.hasCursor()) {
                                this.#cursorOverlayComponent.hideCursors();
                            }
    
                        } else if (ctrlPressed) {
                            // rectangle
                            const [x, y] = getActualMousePosition(e);
                            let minX = Math.min(lastX, x);
                            let minY = Math.min(lastY, y);
                            let maxX = Math.max(lastX, x);
                            let maxY = Math.max(lastY, y);
                            lastTool.applyArea(minX, minY, maxX, maxY, sandGame.graphics(), e.altKey);
                            this.#cursorOverlayComponent.hideCursors();
    
                            Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_RECT);
                            Analytics.triggerToolUsed(lastTool);
    
                        } else if (shiftPressed) {
                            // line
                            const [x, y] = getActualMousePosition(e);
                            lastTool.applyStroke(lastX, lastY, x, y, sandGame.graphics(), e.altKey);
                            this.#cursorOverlayComponent.hideCursors();
    
                            Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_LINE);
                            Analytics.triggerToolUsed(lastTool);
                        }
                        lastTool = null;
                        ctrlPressed = false;
                        shiftPressed = false;
                    }
                });
                domNode.addEventListener('mouseout', (e) => {
                    // disable drag
                    // lastTool = null;
    
                    // cancel repeating
                    cancelRepeatingIfNeeded();
    
                    // hide cursors
                    this.#cursorOverlayComponent.hideCursors();
                });
                domNode.addEventListener('mouseenter', (e) => {
                    if (lastTool !== null && e.buttons === 0) {
                        // mouse released outside...
                        lastTool = null;
                        this.#cursorOverlayComponent.hideCursors();
                        e.preventDefault();
                    }
                });
    
                // touch support
    
                let getActualTouchPosition = (e) => {
                    let touch = e.touches[0];
                    return getActualMousePosition(touch);
                };
                domNode.addEventListener('touchstart', (e) => {
                    if (toolManager.isInputDisabled()) {
                        return;
                    }
    
                    const [x, y] = getActualTouchPosition(e);
                    lastX = x;
                    lastY = y;
                    lastTool = toolManager.getPrimaryTool();
                    lastTool.applyPoint(x, y, sandGame.graphics(), false);
                    Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_PRIMARY);
                    Analytics.triggerToolUsed(lastTool);
    
                    e.preventDefault();
                });
                domNode.addEventListener('touchmove', (e) => {
                    if (toolManager.isInputDisabled()) {
                        lastTool = null;
                        return;
                    }
    
                    if (lastTool === null) {
                        return;
                    }
                    const [x, y] = getActualTouchPosition(e);
                    lastTool.applyStroke(lastX, lastY, x, y, sandGame.graphics(), false);
                    Analytics.triggerToolUsed(lastTool);
                    lastX = x;
                    lastY = y;
    
                    e.preventDefault();
                });
                domNode.addEventListener('touchend', (e) => {
                    lastTool = null;
    
                    e.preventDefault();
                });
            }
    
            getCanvasNode() {
                return this.#nodeCanvas;
            }
    
            setImageRenderingStyle(style) {
                this.#nodeCanvas.style.imageRendering = style;
            }
    
            onInputDisabledChanged(disabled) {
                this.#nodeCursorOverlay.style.cursor = disabled ? 'not-allowed' : null;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-15
         */
        class ComponentViewCanvas extends Component {
    
            /** @type {HTMLElement} */
            #canvasHolderNode = DomBuilder.div({ class: 'sand-game-canvas-holder' });
            /** @type {ComponentViewCanvasInner} */
            #currentCanvas = null;
    
            createNode(controller) {
                controller.registerCanvasProvider({
                    initialize: () => {
                        this.#canvasHolderNode.innerHTML = '';
    
                        this.#currentCanvas = new ComponentViewCanvasInner(controller);
                        this.#canvasHolderNode.append(this.#currentCanvas.createNode(controller));
                        return this.#currentCanvas.getCanvasNode();
                    },
                    getCanvasNode: () => {
                        if (this.#currentCanvas !== null) {
                            return this.#currentCanvas.getCanvasNode();
                        }
                        return null;
                    }
                });
    
                controller.addOnImageRenderingStyleChanged((imageRenderingStyle) => {
                    if (this.#currentCanvas !== null) {
                        this.#currentCanvas.setImageRenderingStyle(imageRenderingStyle);
                    }
                });
    
                controller.addOnInitialized((sandGame) => {
                    if (this.#currentCanvas === null) {
                        throw 'Illegal state: canvas is not initialized';
                    }
    
                    // register mouse handling and overlays
                    this.#currentCanvas.register(sandGame);
                });
    
                controller.addOnBeforeClosed(() => {
                    this.#currentCanvas = null;
                    this.#canvasHolderNode.innerHTML = '';
                });
    
                controller.getToolManager().addOnInputDisabledChanged(disabled => {
                    if (this.#currentCanvas !== null) {
                        this.#currentCanvas.onInputDisabledChanged(disabled);
                    }
                });
    
                return this.#canvasHolderNode;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-08-19
         */
        class ActionDialogChangeCanvasSize extends Action {
    
            performAction(controller) {
                let formBuilder = DomBuilder.bootstrapSimpleFormBuilder();
                formBuilder.addInput('Width', 'width', '' + controller.getCurrentWidthPoints());
                formBuilder.addInput('Height', 'height', '' + controller.getCurrentHeightPoints());
                formBuilder.addInput('Scale', 'scale', '' + controller.getCurrentScale());
    
                let dialog = DomBuilder.bootstrapDialogBuilder();
                dialog.setHeaderContent('Change canvas size manually');
                dialog.setBodyContent(formBuilder.createNode());
                dialog.addSubmitButton('Submit', () => {
                    let data = formBuilder.getData();
                    let w = Number.parseInt(data['width']);
                    let h = Number.parseInt(data['height']);
                    let s = Number.parseFloat(data['scale']);
                    controller.changeCanvasSize(w, h, s);
                    Analytics.triggerFeatureUsed(Analytics.FEATURE_CANVAS_SIZE_CHANGE);
                });
                dialog.addCloseButton('Close');
                dialog.show(controller.getDialogAnchor());
            }
        }
    
        var img$3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAABQCAYAAADSm7GJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACHUlEQVR4Xu3WQW6EMBBEUSJx3jkMF55s4ogQG2zTxeDi/10ijdxTb5HME1k3b39BXgFsHsDmAWwewOYBbB7A5gFsHsDmAWwewOYBbB7A5gFsHsDmAWwewOYBbB7A5gFsHsCrlmV5r39+vV5f659HDOCftrjpd6MjAzzlcVOjIz8eeA83NTLyo4FrcFOjIj8WuAU3NSLyI4F7cFOjIT8O+AxuaiTkRwFH4KZGQX4McCRuagTkjwGvB1ePpMBN3R35I8DbwZUjbd9SpLz/bJcDlwZXjFR6S5Hi/oguBT4aPHKko7cURd4f1WXAtYNHjFT7lqKI+yO7BLh18DMjtb6l6Mz90cmBewfvGan3LUU99yuSAp8dvGWks28parlflQw4avCakaLeUlRzvzIJcPTgeyNFv6Vo73514cCqwXMjqd5SlLu/1Pp71X6mVCiwevD1SOq3FNUgb79XzWf2CgPeHqbqqndU7YGVvtveZ44KAS4dRvlyYEcb5j5T02ngo8MoX8+fmx7kU8C1h1G+nv1akbuBe46jmFqQu4DB/Xy1yM3A4N6nGuQmYHDv1xFyNTC4920PuQoY3PtXQj4EBneccsi7wOCO1xa5CAzuuK2Rs8Dgjl9C/gcMrk/Lsrz/AIPr1y8wuJ7N0wSuczO43v37J4u8Atg8gM0D2DyAzQPYPIDNA9g8gM0D2DyAzQPYPIDNA9g8gM0D2DyAzQPYvG9K/XJS29iPWwAAAABJRU5ErkJggg==";
    
        var img$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAABQCAYAAADSm7GJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABSElEQVR4Xu3WQQ6EIBAFUUw8L4fxwjN78xedQBDLeksiYbAysc8mtPO+IBYDwxkYzsBwBoYzMJyB4QwMZ2A4A8MZGM7AcAaGMzCcgeEMDGdgOAPDGRjOwK2167p+97Wk937c13ZnYDgDwxkYzsBwnwtcHaiStHf3wetzgb/GwHAGhjMw3JLAaThJZg8s1XNHpDNm32PEksB6joHhDAxnYLjpgdPQUZX2VgeWtPcp6bdU7zHb9MDai4HhDAxnYLihwGmYmG3FGSuke6TBq/pc1VBg7c/AcAaGMzBcOXD6+GtM9Z2m56qDVzmw3snAcAaGMzBcDJw+6tpLapQGrxhYHAaGMzCcgeHO9LHWO6WW/oPhDAxnYDgDwxkYzsBwBoYzMJyB4QwMZ2A4A8MZGM7AcAaGMzCcgeEMDGdgOAPDGRjOwHAGhjMw3B/1T0cI5HMokgAAAABJRU5ErkJggg==";
    
        var img$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAABQCAYAAADSm7GJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABGklEQVR4Xu3YMU7EMBQAUZBy3hwmF4Y+BforGcNO3itdOFZGLvyPD9KO+wItAscJHCdwnMBxAscJHCdwnMBxAscJHCdwnMBxAscJHCdwnMBxjw58XdfXfe3uPM/P+9o7eXTgJxA4TuA4geMEjhM4TuA4geO2Bt45WJh8a2Kyz6oz/4atgdlP4DiB4wSOEzhO4DiB4wSOWxZ4MhCYWLXPTpMz/9UwZFlg/ieB4wSOEzhO4DiB4wSOEzhuFHjykOdnq/7hqwOTUWDel8BxAscJHCdwnMBxAscJHHeseoCzx6u93OA4geMEjhM4TuA4geMEjhM4TuA4geMEjhM4TuA4geMEjhM4TuA4geMEjhM4TuA4geMEjhM4TuC4b6YQJX8pLssnAAAAAElFTkSuQmCC";
    
        var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAABQCAYAAADSm7GJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA+ElEQVR4Xu3ZsQ3DMAwAwRjwvBpGCye9KgMq7LzvSnbiQxXPD2nnOqBF4DiB4wSOEzhO4DiB4wSOEzhO4DiB4wSOEzhO4LjXBZ5zftfZVWOMY5093esCv43AcQLHCRwncJzAcQLHCRwncJzAcQLHCRwncJzAcVuBd05v/2jnvXedGrcC83wCxwkcJ3CcwHECxwkcJ3CcwHECxwkcJ3CcwHECx507JzCuu2vPfnCcwHECxwkcJ3CcwHECxwkcJ3CcwHECxwkcJ3CcwHECxwkcJ3CcwHECxwkcJ3CcwHECxwkcJ3CcwHECxwkcJ3CcwHECxwkcJ3CcwHE/D68RYAgtpF0AAAAASUVORK5CYII=";
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-22
         */
        class ComponentViewElementSizeSelection extends Component {
    
            static CLASS_SELECTED = 'selected-size';
    
            static SIZES = [
                { scale: 0.75,  image: img$3, description: 'Very small elements' },
                { scale: 0.5,   image: img$2, description: 'Small elements' },
                { scale: 0.375, image: img$1, description: 'Medium elements' },
                { scale: 0.25,  image: img, description: 'Big elements' },
            ];
    
    
            #nodes = [];
    
            #selected = null;
            #selectedScale = null;
    
            createNode(controller) {
                for (let sizeDef of ComponentViewElementSizeSelection.SIZES) {
                    let node = this.#createSizeCard(sizeDef.scale, sizeDef.image, sizeDef.description);
    
                    // initial scale
                    if (sizeDef.scale === controller.getCurrentScale()) {
                        this.#mark(node, sizeDef.scale);
                    }
    
                    node.addEventListener('click', e => {
                        this.#select(node, sizeDef.scale, controller);
                    });
    
                    this.#nodes.push(node);
                }
    
                return DomBuilder.div(null, [
                    DomBuilder.par(null, "Increasing the size of the elements will result in the top and right" +
                        " parts of the canvas being clipped."),
                    DomBuilder.par(null, "Reducing the size of the elements will result in an expansion of" +
                        " the canvas in the upper and right parts."),
                    DomBuilder.par(null, "Only the scale of the current scene and the initial setting for new" +
                        " scenes will be changed. Scene can be regenerated by clicking on the scene card."),
    
                    DomBuilder.div({ class: 'element-size-options' }, this.#nodes)
                ]);
            }
    
            #select(node, newScale, controller) {
                if (this.#selectedScale === newScale) {
                    return;  // already selected
                }
    
                // mark selected
                if (this.#selected) {
                    this.#selected.classList.remove(ComponentViewElementSizeSelection.CLASS_SELECTED);
                }
                this.#mark(node, newScale);
    
                // change scale
                let w = Math.trunc(controller.getCurrentWidthPoints() / controller.getCurrentScale() * newScale);
                let h = Math.trunc(controller.getCurrentHeightPoints() / controller.getCurrentScale() * newScale);
                controller.changeCanvasSize(w, h, newScale);
    
                Analytics.triggerFeatureUsed(Analytics.FEATURE_SWITCH_SCALE);
            }
    
            #mark(node, scale) {
                node.classList.add(ComponentViewElementSizeSelection.CLASS_SELECTED);
                this.#selected = node;
                this.#selectedScale = scale;
            }
    
            /**
             *
             * @param scale {number}
             * @param image {string}
             * @param description {string}
             */
            #createSizeCard(scale, image, description) {
                return DomBuilder.div({ class: 'card' }, [
                    DomBuilder.element('img', { src: image, alt: description })
                ]);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-08-19
         */
        class ActionDialogChangeElementSize extends Action {
    
            performAction(controller) {
                let elementSizeComponent = new ComponentViewElementSizeSelection();
    
                let dialog = DomBuilder.bootstrapDialogBuilder();
                dialog.setHeaderContent('Adjust Scale');
                dialog.setBodyContent(DomBuilder.div({ class: 'sand-game-component' }, [
                    elementSizeComponent.createNode(controller)
                ]));
                dialog.addSubmitButton("Set size manually", () => {
                    new ActionDialogChangeCanvasSize().performAction(controller);
                });
                dialog.addCloseButton('Close');
                dialog.show(controller.getDialogAnchor());
            }
        }
    
        var _ASSET_SVG_ADJUST_SCALE = "<!-- @author Patrik Harag -->\n<svg width=\"64\" height=\"64\" viewBox=\"0 0 64 64\" xmlns=\"http://www.w3.org/2000/svg\">\n <g>\n  <rect stroke=\"#505050\" stroke-width=\"4\" id=\"svg_1\" height=\"24\" width=\"24\" y=\"35.5\" x=\"4.5\" fill=\"none\"/>\n  <rect stroke=\"#505050\" stroke-width=\"2\" stroke-dasharray=\"3,5\" id=\"svg_2\" height=\"54\" width=\"54\" y=\"4.5\" x=\"4.5\" fill=\"none\"/>\n  <line stroke=\"#505050\" id=\"svg_3\" y2=\"10.65089\" x2=\"51.9999\" y1=\"27.9524\" x1=\"34.38094\" stroke-width=\"4\" fill=\"none\"/>\n  <line stroke=\"#505050\" id=\"svg_4\" y2=\"11.28581\" x2=\"50.73007\" y1=\"13.98421\" x1=\"37.87298\" stroke-width=\"4\" fill=\"none\"/>\n  <line stroke=\"#505050\" id=\"svg_5\" y2=\"11.762\" x2=\"51.36499\" y1=\"23.82543\" x1=\"48.82531\" stroke-width=\"4\" fill=\"none\"/>\n </g>\n</svg>";
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-08-19
         */
        class ComponentButtonAdjustScale extends Component {
    
            createNode(controller) {
                return DomBuilder.button(DomBuilder.create(_ASSET_SVG_ADJUST_SCALE), {
                    class: 'btn btn-outline-secondary adjust-scale',
                    'aria-label': 'Adjust scale'
                }, () => {
                    new ActionDialogChangeElementSize().performAction(controller);
                });
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        // TODO: support external restart
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-08
         */
        class ComponentViewSceneSelection extends Component {
    
            static CLASS_SELECTED = 'selected-scene';
            static CLASS_VISITED = 'visited-scene';
    
    
            /** @type Controller */
            #controller;
    
            #ignoreOnBeforeNewSceneLoaded = false;
    
            #scenes;
            #initialSceneId;
    
            #selected = null;
            #selectedSceneId = null;
    
            #closedScenes = new Map();
    
            /**
             * @param controller {Controller}
             * @param scenes {Object<string,Scene>}}
             * @param initialSceneId
             */
            constructor(controller, scenes, initialSceneId) {
                super();
                this.#controller = controller;
                this.#scenes = scenes;
                this.#initialSceneId = initialSceneId;
    
                this.#controller.addOnBeforeNewSceneLoaded(() => {
                    if (!this.#ignoreOnBeforeNewSceneLoaded) {
                        this.#store();
                        this.#unselect();
                    }
                });
            }
    
            createNode(controller) {
                let content = DomBuilder.div({ class: 'scenes' }, []);
    
                for (const [id, scene] of Object.entries(this.#scenes)) {
                    let label = DomBuilder.element('span', { class: 'scene-title' }, scene.name);
                    let node = DomBuilder.button(label, { class: 'btn btn-outline-secondary scene' }, () => {
                        this.#onSelect(id, node, scene);
                    });
    
                    // mark initial scene
                    if (id === this.#initialSceneId) {
                        this.#selected = node;
                        this.#selectedSceneId = id;
                        node.classList.add(ComponentViewSceneSelection.CLASS_SELECTED);
                        node.classList.add(ComponentViewSceneSelection.CLASS_VISITED);
                    }
    
                    content.append(node);
                }
    
                return content;
            }
    
            #onSelect(id, node, scene) {
                if (this.#selected) {
                    if (this.#selectedSceneId === id) {
                        // already opened - rebuild scene
                        this.#rebuildConfirm(() => {
                            this.#select(node, id, scene);
                            Analytics.triggerFeatureUsed(Analytics.FEATURE_RESTART_SCENE);
                        });
                    } else {
                        // store snapshot of the old scene and open...
                        this.#store();
                        this.#select(node, id, scene);
                        Analytics.triggerFeatureUsed(Analytics.FEATURE_SWITCH_SCENE);
                    }
                } else {
                    // open
                    this.#select(node, id, scene);
                    Analytics.triggerFeatureUsed(Analytics.FEATURE_SWITCH_SCENE);
                }
            }
    
            #rebuildConfirm(onConfirm) {
                let dialog = DomBuilder.bootstrapDialogBuilder();
                dialog.setHeaderContent('Restart scene');
                dialog.setBodyContent([
                    DomBuilder.par(null, "Do you want to restart the scene?")
                ]);
                dialog.addSubmitButton('Confirm', onConfirm);
                dialog.addCloseButton('Close');
                dialog.show(this.#controller.getDialogAnchor());
            }
    
            #select(node, id, scene) {
                this.#unselect();
    
                this.#selected = node;
                this.#selectedSceneId = id;
                node.classList.add(ComponentViewSceneSelection.CLASS_SELECTED);
                node.classList.add(ComponentViewSceneSelection.CLASS_VISITED);
    
                // restore or build scene
                let snapshot = this.#closedScenes.get(id);
                if (snapshot) {
                    this.#closedScenes.delete(id);
    
                    this.#ignoreOnBeforeNewSceneLoaded = true;
                    this.#controller.setInitialScene(scene);
                    this.#controller.openScene(new SceneImplSnapshot(snapshot));
                    this.#ignoreOnBeforeNewSceneLoaded = false;
                } else {
                    this.#ignoreOnBeforeNewSceneLoaded = true;
                    this.#controller.setInitialScene(scene);
                    this.#controller.openScene(scene);
                    this.#ignoreOnBeforeNewSceneLoaded = false;
                }
            }
    
            #unselect() {
                if (this.#selected) {
                    this.#selected.classList.remove(ComponentViewSceneSelection.CLASS_SELECTED);
                }
                this.#selected = null;
                this.#selectedSceneId = null;
            }
    
            #store() {
                if (this.#selected) {
                    this.#closedScenes.set(this.#selectedSceneId, this.#controller.createSnapshot());
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-19
         */
        class ActionsTest {
    
            static ALL_MATERIALS = function (controller) {
                let sandGame = controller.getSandGame();
                if (sandGame === null) {
                    return;
                }
    
                const brushes = [
                    'ash',
                    'sand',
                    'soil',
                    'gravel',
                    'wall',
                    'rock',
                    'metal',
                    'wood',
                    'water'
                ];
    
                let segment = Math.ceil(sandGame.getWidth() / brushes.length);
                for (let i = 0; i < brushes.length; i++) {
                    const brush = BrushDefs.byCodeName(brushes[i]);
                    sandGame.graphics().drawRectangle(i * segment, 0, (i + 1) * segment, -1, brush, true);
                }
            }
    
            static TREE_SPAWN_TEST = function (controller) {
                let sandGame = controller.getSandGame();
                if (sandGame === null) {
                    return;
                }
    
                sandGame.graphics().fill(BrushDefs.AIR);
    
                sandGame.layeredTemplate()
                        .layer(Math.trunc(sandGame.getHeight() / 2), false, BrushDefs.AIR)
                        .layer(1, true, BrushDefs.WALL)
                        .layer(10, true, BrushDefs.SOIL)
                        .grass();
    
                sandGame.layeredTemplate()
                        .layer(1, true, BrushDefs.WALL)
                        .layer(10, true, BrushDefs.SOIL)
                        .grass();
            }
    
            static treeGrowTest(level = -1) {
                return function (controller) {
                    let sandGame = controller.getSandGame();
                    if (sandGame === null) {
                        return;
                    }
    
                    sandGame.graphics().fill(BrushDefs.AIR);
    
                    let count = StructureDefs.TREE_TRUNK_TEMPLATES.length;
                    let segment = Math.trunc(sandGame.getWidth() / 8);
    
                    const template1 = sandGame.layeredTemplate();
                    template1.layer(Math.trunc(sandGame.getHeight() / 2), false, BrushDefs.AIR);
                    template1.layer(1, true, BrushDefs.WALL);
                    template1.layer(10, true, BrushDefs.SOIL);
                    for (let i = 0; i < 8; i++) {
                        template1.tree(Math.trunc((i + 0.5) * segment), i % count, level);
                    }
                    template1.grass();
    
                    const template2 = sandGame.layeredTemplate();
                    template2.layer(1, true, BrushDefs.WALL);
                    template2.layer(10, true, BrushDefs.SOIL);
                    for (let i = 0; i < 8; i++) {
                        template2.tree(Math.trunc((i + 0.5) * segment), (i + 8) % count, level);
                    }
                    template2.grass();
                }
            }
        }
    
        var FileSaver_minExports = {};
        var FileSaver_min = {
          get exports(){ return FileSaver_minExports; },
          set exports(v){ FileSaver_minExports = v; },
        };
    
        (function (module, exports) {
            (function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return "undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error("could not download file");},d.send();}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send();}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"));}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof commonjsGlobal&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else {var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else {var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});
    
            
        } (FileSaver_min));
    
        var FileSaver = FileSaver_minExports;
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-04
         */
        class ActionBenchmark extends Action {
    
            performAction(controller) {
                let benchmarkProvider = new BenchmarkProvider(controller, results => {
                    let dialog = DomBuilder.bootstrapDialogBuilder();
                    dialog.setHeaderContent('Benchmark results');
                    dialog.setBodyContent([
                        DomBuilder.par(null, 'IPS AVG: ' + results.ipsAvg.toFixed(2)),
                        DomBuilder.par(null, 'IPS MIN: ' + results.ipsMin)
                    ]);
                    dialog.addCloseButton('Close');
                    dialog.addButton(
                        DomBuilder.button('Download results', { type: 'button', class: 'btn btn-primary' }, e => {
                            const data = JSON.stringify(results, null, '  ');
                            const blob = new Blob([data], { type: 'application/json;charset=utf-8' });
                            const date = this.#formatDate(new Date());
                            FileSaver.saveAs(blob, `${date}.benchmark.json`);
                        })
                    );
                    dialog.show(controller.getDialogAnchor());
                });
                benchmarkProvider.start();
            }
    
            #formatDate(date) {
                let dd = String(date.getDate()).padStart(2, '0');
                let MM = String(date.getMonth() + 1).padStart(2, '0');  // January is 0!
                let yyyy = date.getFullYear();
    
                let hh = String(date.getHours()).padStart(2, '0');
                let mm = String(date.getMinutes()).padStart(2, '0');
    
                return `${yyyy}-${MM}-${dd}_${hh}-${mm}`;
            }
        }
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-04-29
         */
        class BenchmarkProvider {
    
            static WAITING_GAP = 300;
    
            /** @type Controller */
            #controller;
    
            /** @type function */
            #onFinish;
    
            /**
             *
             * @param controller {Controller}
             * @param onFinish {function({ipsAvg,ipsMin,benchmarks:{name,ipsAvg,ipsMin}[]})}
             */
            constructor(controller, onFinish) {
                this.#controller = controller;
                this.#onFinish = onFinish;
            }
    
            start() {
                let scene = new SceneImplHardcoded({
                    onCreated: (sandGame) => this.#benchmarkScene(sandGame)
                });
    
                this.#controller.openScene(scene);
                this.#controller.start();
            }
    
            #benchmarkScene(sandGame) {
                const benchmarkResults = [];
                const benchmarkQueue = [...BenchmarkProvider.BENCHMARKS];
                let i = 0;
                let waiting = BenchmarkProvider.WAITING_GAP;
                let ipsSum = 0;
                let ipsMin = Number.MAX_SAFE_INTEGER;
                sandGame.addOnProcessed(() => {
                    if (waiting > 0) {
                        waiting--;
                        return;
                    }
                    if (benchmarkQueue.length === 0) {
                        return;
                    }
    
                    const benchmark = benchmarkQueue[0];
                    if (i === 0) {
                        console.log('Running benchmark: ' + benchmark.name);
                    }
                    benchmark.nextIteration(sandGame, i);
                    i++;
                    const ips = sandGame.getIterationsPerSecond();
                    ipsSum = ipsSum + ips;
                    ipsMin = Math.min(ipsMin, ips);
    
                    if (benchmark.iterations === i) {
                        const ipsAvg = ipsSum / benchmark.iterations;
                        benchmarkResults.push({
                            name: benchmark.name,
                            ipsAvg: ipsAvg,
                            ipsMin: ipsMin
                        });
    
                        benchmarkQueue.shift();
                        i = 0;
                        ipsSum = 0;
                        ipsMin = Number.MAX_SAFE_INTEGER;
                        waiting = BenchmarkProvider.WAITING_GAP;
    
                        sandGame.graphics().fill(BrushDefs.AIR);
    
                        if (benchmarkQueue.length === 0) {
                            this.#onFinish(this.#finalizeResults(sandGame, benchmarkResults));
                        }
                    }
                });
            }
    
            #finalizeResults(sandGame, benchmarkResults) {
                const ipsSum = benchmarkResults.map(r => r.ipsAvg).reduce((a, b) => a + b, 0);
                const ipsAvg = ipsSum / benchmarkResults.length;
                const ipsMin = benchmarkResults.map(r => r.ipsMin).reduce((a, b) => Math.min(a, b), Number.MAX_SAFE_INTEGER);
                return {
                    version: 1,
                    date: new Date().toString(),
                    ipsAvg: ipsAvg,
                    ipsMin: ipsMin,
                    benchmarks: benchmarkResults,
                    scene: {
                        width: sandGame.getWidth(),
                        height: sandGame.getHeight()
                    }
                }
            }
    
    
            static #createBenchmark(name, iterations, nextIteration) {
                if (iterations <= 0) {
                    throw 'Number of iterations must be a positive number';
                }
                return {
                    name: name,
                    iterations: iterations,
                    nextIteration: nextIteration
                };
            }
    
            static BENCHMARKS = [
                BenchmarkProvider.#createBenchmark('sand-fall-q', 500, function (sandGame, j) {
                    sandGame.graphics().drawRectangle(0, 0, -1, 1, BrushDefs.SAND, true);
                }),
                BenchmarkProvider.#createBenchmark('sand-fall-s', 2000, function (sandGame, j) {
                    if (j % 10 === 0) {
                        sandGame.graphics().drawRectangle(0, 0, -1, 1, BrushDefs.SAND, true);
                    }
                }),
                BenchmarkProvider.#createBenchmark('sand-fill', 1000, function (sandGame, j) {
                    if (j === 0) {
                        sandGame.graphics().drawRectangle(0, 0, -1, -1, BrushDefs.SAND, true);
                    }
                }),
                BenchmarkProvider.#createBenchmark('soil-fall-q', 500, function (sandGame, j) {
                    sandGame.graphics().drawRectangle(0, 0, -1, 1, BrushDefs.SOIL, true);
                }),
                BenchmarkProvider.#createBenchmark('soil-fall-s', 2000, function (sandGame, j) {
                    if (j % 10 === 0) {
                        sandGame.graphics().drawRectangle(0, 0, -1, 1, BrushDefs.SOIL, true);
                    }
                }),
                BenchmarkProvider.#createBenchmark('soil-fill', 1000, function (sandGame, j) {
                    if (j === 0) {
                        sandGame.graphics().drawRectangle(0, 0, -1, -1, BrushDefs.SOIL, true);
                    }
                }),
                BenchmarkProvider.#createBenchmark('water-fall-q', 500, function (sandGame, j) {
                    sandGame.graphics().drawRectangle(0, 0, -1, 1, BrushDefs.WATER, true);
                }),
                BenchmarkProvider.#createBenchmark('water-fall-s', 2000, function (sandGame, j) {
                    if (j % 10 === 0) {
                        sandGame.graphics().drawRectangle(0, 0, -1, 1, BrushDefs.WATER, true);
                    }
                }),
                BenchmarkProvider.#createBenchmark('water-fill', 1000, function (sandGame, j) {
                    if (j === 0) {
                        sandGame.graphics().drawRectangle(0, 0, -1, -1, BrushDefs.WATER, true);
                    }
                }),
                BenchmarkProvider.#createBenchmark('sand-into-water', 1000, function (sandGame, j) {
                    if (j === 0) {
                        sandGame.graphics().drawRectangle(0, 0, -1, 31, BrushDefs.SAND, true);
                        sandGame.graphics().drawRectangle(0, 60, -1, -1, BrushDefs.WATER, true);
                    }
                }),
                BenchmarkProvider.#createBenchmark('soil-into-water', 1000, function (sandGame, j) {
                    if (j === 0) {
                        sandGame.graphics().drawRectangle(0, 0, -1, 31, BrushDefs.SOIL, true);
                        sandGame.graphics().drawRectangle(0, 60, -1, -1, BrushDefs.WATER, true);
                    }
                }),
            ];
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-05
         */
        class ComponentButton extends Component {
    
            static CLASS_PRIMARY = 'btn-primary';
            static CLASS_SECONDARY = 'btn-secondary';
            static CLASS_INFO = 'btn-info';
            static CLASS_SUCCESS = 'btn-success';
            static CLASS_WARNING = 'btn-warning';
            static CLASS_LIGHT = 'btn-light';
    
            static CLASS_OUTLINE_PRIMARY = 'btn-outline-primary';
            static CLASS_OUTLINE_SECONDARY = 'btn-outline-secondary';
            static CLASS_OUTLINE_INFO = 'btn-outline-info';
            static CLASS_OUTLINE_SUCCESS = 'btn-outline-success';
            static CLASS_OUTLINE_WARNING = 'btn-outline-warning';
            static CLASS_OUTLINE_LIGHT = 'btn-outline-light';
    
    
            #label;
            #action;
            #cssClass;
    
            /**
             *
             * @param label {string|HTMLElement|HTMLElement[]}
             * @param cssClass {string|null}
             * @param action {Action|function}
             */
            constructor(label, cssClass, action) {
                super();
                this.#label = label;
                this.#action = (typeof action === "function" ? Action.create(action) : action);
                this.#cssClass = (cssClass == null ? ComponentButton.CLASS_PRIMARY : cssClass);
            }
    
            createNode(controller) {
                return DomBuilder.button(this.#label, { class: 'btn ' + this.#cssClass }, e => {
                    this.#action.performAction(controller);
                });
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-11-20
         */
        class ActionScreenshot extends Action {
    
            performAction(controller) {
                const canvas = controller.getCanvas();
                if (canvas !== null) {
                    canvas.toBlob((blob) => {
                        FileSaver.saveAs(blob, this.#formatDate(new Date()) + '.png');
                    });
                }
            }
    
            #formatDate(date) {
                let dd = String(date.getDate()).padStart(2, '0');
                let MM = String(date.getMonth() + 1).padStart(2, '0');  // January is 0!
                let yyyy = date.getFullYear();
    
                let hh = String(date.getHours()).padStart(2, '0');
                let mm = String(date.getMinutes()).padStart(2, '0');
    
                return `${yyyy}-${MM}-${dd}_${hh}-${mm}`;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-02
         */
        class ActionRecord extends Action {
    
            #controllerHandlersRegistered = false;
            #sandGameHandlersRegistered = false;
    
            #zipData = null;
    
            performAction(controller) {
                if (!this.#controllerHandlersRegistered) {
                    controller.addOnBeforeClosed(() => {
                        if (this.#zipData !== null) {
                            this.#stopRecording();
                        }
                    });
                    controller.addOnInitialized(sandGame => {
                        this.#sandGameHandlersRegistered = false;
                    });
                    this.#controllerHandlersRegistered = true;
                }
    
                if (this.#zipData === null) {
                    // start recording
                    this.#zipData = {};
    
                    if (!this.#sandGameHandlersRegistered) {
                        let processed = false;
                        let lastIteration = 0;
                        let frameInProgress = false;
                        controller.getSandGame().addOnProcessed((iteration) => {
                            processed = true;
                            lastIteration = iteration;
                        });
                        controller.getSandGame().addOnRendered(() => {
                            if (this.#zipData !== null && processed && !frameInProgress) {
                                frameInProgress = true;
                                this.#addFrame(controller, lastIteration, () => frameInProgress = false);
                                processed = false;
                            }
                        });
                        this.#sandGameHandlersRegistered = true;
                    }
                } else {
                    this.#stopRecording();
                }
            }
    
            #addFrame(controller, iteration, completed) {
                const canvas = controller.getCanvas();
                if (canvas !== null) {
                    canvas.toBlob((blob) => {
                        blob.arrayBuffer().then(arrayBuffer => {
                            const array = new Uint8Array(arrayBuffer);
                            if (this.#zipData !== null) {
                                this.#zipData[`iteration_${String(iteration).padStart(6, '0')}.png`] = array;
                            }
                        }).finally(() => {
                            completed();
                        });
                    });
                }
            }
    
            #stopRecording() {
                this.#download(this.#zipData, 'frames.zip');
                this.#zipData = null;
            }
    
            #download(zipData, filename) {
                const bytes = zipSync(zipData, { level: 0 });
                FileSaver.saveAs(new Blob([bytes]), filename);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-12-05
         */
        class ActionFill extends Action {
    
            performAction(controller) {
                const sandGame = controller.getSandGame();
                if (sandGame === null) {
                    return;
                }
                const primaryTool = controller.getToolManager().getPrimaryTool();
                if (!primaryTool.isAreaModeEnabled()) {
                    return;
                }
                primaryTool.applyArea(0, 0, sandGame.getWidth(), sandGame.getHeight(), sandGame.graphics(), false);
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-02
         */
        class ComponentViewTestTools extends Component {
    
            static #BTN_SCENE = ComponentButton.CLASS_OUTLINE_SECONDARY;
            static #BTN_RENDERING = ComponentButton.CLASS_OUTLINE_INFO;
            static #BTN_TOOL = ComponentButton.CLASS_OUTLINE_PRIMARY;
            static #BTN_BRUSH = ComponentButton.CLASS_OUTLINE_SUCCESS;
    
            static COMPONENTS = [
                new ComponentButton("All materials", ComponentViewTestTools.#BTN_SCENE, ActionsTest.ALL_MATERIALS),
                new ComponentButton("Tree spawn", ComponentViewTestTools.#BTN_SCENE, ActionsTest.TREE_SPAWN_TEST),
                new ComponentButton("Tree grow", ComponentViewTestTools.#BTN_SCENE, ActionsTest.treeGrowTest(0)),
                new ComponentButton("Tree grown", ComponentViewTestTools.#BTN_SCENE, ActionsTest.treeGrowTest(-1)),
                new ComponentButton("Fill", ComponentViewTestTools.#BTN_SCENE, new ActionFill()),
    
                new ComponentButton("Benchmark", ComponentViewTestTools.#BTN_TOOL, new ActionBenchmark()),
                new ComponentButton("Screenshot", ComponentViewTestTools.#BTN_TOOL, new ActionScreenshot()),
                new ComponentButton("Record (start/stop)", ComponentViewTestTools.#BTN_TOOL, new ActionRecord()),
    
                new ComponentButton("Chunks", ComponentViewTestTools.#BTN_RENDERING,
                        Action.createToggle(false, (c, v) => c.setShowActiveChunks(v))),
                new ComponentButton("M/webgl", ComponentViewTestTools.#BTN_RENDERING,
                        Action.create(c => c.setRendererInitializer(RendererInitializer.canvasWebGL()))),
                new ComponentButton("M/classic", ComponentViewTestTools.#BTN_RENDERING,
                        Action.create(c => c.setRendererInitializer(RendererInitializer.canvas2d()))),
                new ComponentButton("M/heatmap", ComponentViewTestTools.#BTN_RENDERING,
                        Action.create(c => c.setRendererInitializer(RendererInitializer.canvas2dHeatmap()))),
                new ComponentButton("M/type", ComponentViewTestTools.#BTN_RENDERING,
                        Action.create(c => c.setRendererInitializer(RendererInitializer.canvas2dElementType()))),
                new ComponentButton("M/null", ComponentViewTestTools.#BTN_RENDERING,
                        Action.create(c => c.setRendererInitializer(RendererInitializer.nullRenderer()))),
                new ComponentButton("Pixelated", ComponentViewTestTools.#BTN_RENDERING,
                        Action.createToggle(true, (c, v) => c.setCanvasImageRenderingStyle(v ? 'pixelated' : 'auto'))),
            ];
    
    
            createNode(controller) {
                let content = DomBuilder.div({ class: 'test-tools' }, []);
    
                let components = [...ComponentViewTestTools.COMPONENTS];
                for (let tool of ToolDefs.TEST_TOOLS) {
                    let action = Action.create(c => c.getToolManager().setPrimaryTool(tool));
                    components.push(new ComponentButton(tool.getInfo().getDisplayName(), ComponentViewTestTools.#BTN_BRUSH, action));
                }
    
                for (let component of components) {
                    content.append(component.createNode(controller));
                }
                return content;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-04
         */
        class ComponentContainer extends Component {
    
            #cssClass;
            #components;
    
            /**
             *
             * @param cssClass {string|null}
             * @param components {Component[]}
             */
            constructor(cssClass, components) {
                super();
                this.#cssClass = cssClass;
                this.#components = components;
            }
    
            createNode(controller) {
                const content = DomBuilder.div({ class: this.#cssClass }, []);
                for (let component of this.#components) {
                    if (component !== null) {
                        content.append(component.createNode(controller));
                    }
                }
                return content;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-04
         */
        class ComponentSimple extends Component {
    
            #node;
    
            /**
             *
             * @param node {HTMLElement}
             */
            constructor(node) {
                super();
                this.#node = node;
            }
    
            createNode(controller) {
                return this.#node;
            }
        }
    
        var _ASSET_SVG_PAUSE = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-pause-fill\" viewBox=\"0 0 16 16\">\n    <path d=\"M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z\"/>\n</svg>";
    
        var _ASSET_SVG_PLAY = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-play-fill\" viewBox=\"0 0 16 16\">\n    <path d=\"m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z\"/>\n</svg>";
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-10
         */
        class ComponentButtonStartStop extends ComponentButton {
    
            constructor(cssClass) {
                super('', cssClass, Action.create(controller => {
                    controller.switchStartStop();
                    Analytics.triggerFeatureUsed(Analytics.FEATURE_PAUSE);
                }));
            }
    
            createNode(controller) {
                const btn = super.createNode(controller);
                DomBuilder.setContent(btn, [DomBuilder.create(_ASSET_SVG_PLAY), 'Start']);
    
                controller.addOnStarted(() => {
                    DomBuilder.setContent(btn, [DomBuilder.create(_ASSET_SVG_PAUSE), 'Pause']);
                });
                controller.addOnStopped(() => {
                    DomBuilder.setContent(btn, [DomBuilder.create(_ASSET_SVG_PLAY), 'Start']);
                });
    
                return btn;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-03-23
         */
        class ComponentStatusIndicator extends Component {
    
            #additionalInfo;
    
            constructor(additionalInfo = null) {
                super();
                this.#additionalInfo = additionalInfo;
            }
    
            createNode(controller) {
                let currenStatus = '';
    
                const nodeStatusLabel = DomBuilder.span('');
                const nodeLabel = [
                    DomBuilder.span('Performance: ', { class: 'visible-on-big-screen-only' }),
                    nodeStatusLabel
                ];
    
                const node = DomBuilder.div({ class: 'btn-group' }, [
                    DomBuilder.element('button', {
                        type: 'button',
                        class: 'btn btn-link dropdown-toggle',
                        'data-bs-toggle': 'dropdown',
                        'aria-expanded': 'false'
                    }, nodeLabel),
                    DomBuilder.element('form', { class: 'dropdown-menu p-2' }, this.#createStatusContent(controller))
                ]);
                node.addEventListener('show.bs.dropdown', function () {
                    Analytics.triggerFeatureUsed(Analytics.FEATURE_STATUS_DISPLAYED);
                });
    
                let updateStatus = (node, status) => {
                    if (status !== currenStatus) {
                        nodeStatusLabel.textContent = (status.toUpperCase());
                        nodeStatusLabel.classList.remove('status-' + currenStatus);
                        nodeStatusLabel.classList.add('status-' + status);
                        currenStatus = status;
                    }
                };
    
                controller.addOnStopped(() => updateStatus(node, 'stopped'));
                controller.addOnStarted(() => updateStatus(node, 'started'));
                controller.addOnInitialized(sandGame => {
                    sandGame.addOnRendered(() => {
                        const ips = controller.getSandGame().getIterationsPerSecond();
                        if (ips === 0) {
                            updateStatus(node, 'stopped');
                            return;
                        }
                        if (ips > 105) {
                            updateStatus(node, 'best');
                            return;
                        }
                        if (ips > 80) {
                            updateStatus(node, 'good');
                            return;
                        }
                        if (ips > 50) {
                            updateStatus(node, 'medium');
                            return;
                        }
                        if (ips > 40) {
                            updateStatus(node, 'low');
                            return;
                        }
                        updateStatus(node, 'poor');
                    });
                });
    
                return node;
            }
    
            #createStatusContent(controller) {
                const labelCPS = DomBuilder.span();
                const labelFPS = DomBuilder.span();
                controller.addOnInitialized(sandGame => {
                    sandGame.addOnRendered(() => {
                        const fps = controller.getSandGame().getFramesPerSecond();
                        const ips = controller.getSandGame().getIterationsPerSecond();
                        labelFPS.textContent = ' = ' + fps;
                        labelCPS.textContent = ' = ' + ips;
                    });
                });
    
                const labelCanvasSize = DomBuilder.span();
                const updateCanvasSize = () => {
                    const w = controller.getCurrentWidthPoints();
                    const h = controller.getCurrentHeightPoints();
                    labelCanvasSize.textContent = ` = ${w.toLocaleString()}\u00D7${h.toLocaleString()} = ${(w * h).toLocaleString()}`;
                };
                controller.addOnInitialized(() => {
                    updateCanvasSize();
                });
                updateCanvasSize();
    
                return [
                    DomBuilder.span('Sand Game JS ' + controller.getVersion(), { style: 'font-weight: bold;' }),
                    DomBuilder.element('br'),
    
                    DomBuilder.span('Simulated elements'),
                    labelCanvasSize,
                    DomBuilder.element('br'),
    
                    DomBuilder.span('Simulation iterations /s'),
                    labelCPS,
                    DomBuilder.span(' (target: ' + Processor.OPT_CYCLES_PER_SECOND + ')', { style: 'color: lightgray;' }),
                    DomBuilder.element('br'),
    
                    DomBuilder.span('Rendered frames /s'),
                    labelFPS,
                    DomBuilder.span(' (target: ' + Processor.OPT_FRAMES_PER_SECOND + ')', { style: 'color: lightgray;' }),
                    DomBuilder.element('br'),
    
                    this.#additionalInfo
                ];
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-17
         */
        class ActionRestart extends Action {
    
            performAction(controller) {
                let dialog = DomBuilder.bootstrapDialogBuilder();
                dialog.setHeaderContent('Restart');
                dialog.setBodyContent([
                    DomBuilder.par(null, "Are you sure?")
                ]);
                dialog.addSubmitButton('Restart', () => {
                    const scene = controller.getInitialScene();
                    controller.openScene(scene);
                    Analytics.triggerFeatureUsed(Analytics.FEATURE_RESTART_SCENE);
                });
                dialog.addCloseButton('Close');
                dialog.show(controller.getDialogAnchor());
            }
        }
    
        var _ASSET_SVG_RESTART = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-arrow-clockwise\" viewBox=\"0 0 16 16\">\n    <path fill-rule=\"evenodd\" d=\"M8 3.5a4.5 4.5 0 104.546 2.914.5.5 0 011.454-.414A6 6 0 118 2z\"/>\n    <path d=\"M8 6V0l5 3L8 6\"/>\n</svg>";
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-01-17
         */
        class ComponentButtonRestart extends ComponentButton {
    
            constructor(cssClass) {
                super('', cssClass, new ActionRestart());
            }
    
            createNode(controller) {
                const btn = super.createNode(controller);
                DomBuilder.setContent(btn, [DomBuilder.create(_ASSET_SVG_RESTART), 'Restart']);
                return btn;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-08-19
         */
        class ActionIOImport extends Action {
    
            performAction(controller) {
                let input = document.createElement('input');
                input.type = 'file';
                input.onchange = e => {
                    controller.getIOManager().loadFromFiles(e.target.files);
                };
                input.click();
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2023-08-19
         */
        class ActionIOExport extends Action {
    
            performAction(controller) {
                const snapshot = controller.createSnapshot();
                const bytes = Resources.createResourceFromSnapshot(snapshot);
                FileSaver.saveAs(new Blob([bytes]), this.#createFilename());
                Analytics.triggerFeatureUsed(Analytics.FEATURE_IO_EXPORT);
            }
    
            #createFilename() {
                let date = new Date().toISOString().slice(0, 10);
                return `sand-game-js_${date}.sgjs`;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-02-04
         */
        class ActionReportProblem extends Action {
    
            /** @type function(type:string,message:string,controller:Controller) */
            #handler;
    
            constructor(handler) {
                super();
                this.#handler = handler;
            }
    
            performAction(controller) {
                let formBuilder = DomBuilder.bootstrapSimpleFormBuilder();
                formBuilder.addTextArea('Message', 'message');
    
                let dialog = DomBuilder.bootstrapDialogBuilder();
                dialog.setHeaderContent('Report a problem');
                dialog.setBodyContent(formBuilder.createNode());
                dialog.addSubmitButton('Submit', () => {
                    let data = formBuilder.getData();
                    let message = data['message'];
                    if (message.trim() !== '') {
                        this.#handler("user", message, controller);
                    }
                });
                dialog.addCloseButton('Close');
                dialog.show(controller.getDialogAnchor());
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-03-23
         */
        class ComponentButtonReport extends ComponentButton {
    
            constructor(cssClass, errorReporter) {
                const label = [
                    'Report',
                    DomBuilder.span(' a\xa0problem', { class: 'visible-on-big-screen-only' })
                ];
                super(label, cssClass, new ActionReportProblem(errorReporter));
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         * @interface
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class Extension {
    
            run() {
                throw 'Not implemented'
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class ExtensionSpawnGrass extends Extension {
    
            /** @type ElementArea */
            #elementArea;
            /** @type DeterministicRandom */
            #random;
            /** @type ProcessorContext */
            #processorContext;
    
            /**
             *
             * @param gameState {GameState}
             */
            constructor(gameState) {
                super();
                this.#elementArea = gameState.elementArea;
                this.#random = gameState.random;
                this.#processorContext = gameState.processorContext;
            }
    
            run() {
                if (this.#processorContext.getIteration() % 3 === 0) {
    
                    const x = this.#random.nextInt(this.#elementArea.getWidth());
                    const y = this.#random.nextInt(this.#elementArea.getHeight() - 3) + 2;
    
                    if (ProcessorModuleGrass.canGrowUpHere(this.#elementArea, x, y)) {
                        const brush = this.#processorContext.getDefaults().getBrushGrass();
                        this.#elementArea.setElement(x, y, brush.apply(x, y, this.#random));
                        this.#processorContext.trigger(x, y);
                    }
                }
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-05
         */
        class ExtensionSpawnFish extends Extension {
    
            /** @type ElementArea */
            #elementArea;
            /** @type DeterministicRandom */
            #random;
            /** @type ProcessorContext */
            #processorContext;
            /** @type EntityManager */
            #entityManager;
    
            /**
             *
             * @param gameState {GameState}
             */
            constructor(gameState) {
                super();
                this.#elementArea = gameState.elementArea;
                this.#random = gameState.random;
                this.#processorContext = gameState.processorContext;
                this.#entityManager = gameState.entityManager;
            }
    
            run() {
                if ((this.#processorContext.getIteration() + 200) % 1000 === 0) {
                    const fishCount = this.#entityManager.countEntities('fish');
    
                    if (fishCount >= 8) {
                        return;
                    }
    
                    const x = this.#random.nextInt(this.#elementArea.getWidth() - 20) + 10;
                    const y = this.#findSpawnY(this.#elementArea, x);
                    if (y !== null) {
                        this.#entityManager.addSerializedEntity(Entities.fish(x, y));
                        this.#processorContext.trigger(x, y);
                    }
                }
            }
    
            #findSpawnY(elementArea, x) {
                let waterCount = 0;
    
                for (let y = 0; y < elementArea.getHeight(); y++) {
                    const elementHead = elementArea.getElementHead(x, y);
                    const typeClass = ElementHead.getTypeClass(elementHead);
                    if (typeClass === ElementHead.TYPE_AIR) {
                        waterCount = 0;
                    } else if (typeClass === ElementHead.TYPE_FLUID) {
                        waterCount++;
                    } else if (typeClass === ElementHead.TYPE_POWDER || typeClass === ElementHead.TYPE_POWDER_WET) {
                        if (waterCount > 7 && this.#isSpaceAround(x, y - 1)) {
                            return y - 1;
                        }
                        break;
                    }
                }
    
                return null;
            }
    
            #isSpaceAround(x, y) {
                for (let dy = 0; dy < 6; dy++) {
                    for (let dx = -(dy + 1); dx < dy + 1; dx++) {
                        const ex = x + dx;
                        const ey = y - dy;
                        const elementHead = this.#elementArea.getElementHeadOrNull(ex, ey);
                        if (elementHead === null) {
                            return false;
                        }
                        if (ElementHead.getTypeClass(elementHead) !== ElementHead.TYPE_FLUID) {
                            return false;
                        }
                        if (ElementHead.getTemperature(elementHead) > 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-04-27
         */
        class ExtensionSpawnTrees extends Extension {
    
            /** @type ElementArea */
            #elementArea;
            /** @type DeterministicRandom */
            #random;
            /** @type ProcessorContext */
            #processorContext;
    
            /**
             *
             * @param gameState {GameState}
             */
            constructor(gameState) {
                super();
                this.#elementArea = gameState.elementArea;
                this.#random = gameState.random;
                this.#processorContext = gameState.processorContext;
            }
    
            run() {
                const iteration = this.#processorContext.getIteration();
                if (iteration > 1000 && iteration % 4 === 0) {
    
                    const x = this.#random.nextInt(this.#elementArea.getWidth() - 12) + 6;
                    const y = this.#random.nextInt(this.#elementArea.getHeight() - 16) + 15;
    
                    if (ExtensionSpawnTrees.couldGrowUpHere(this.#elementArea, x, y)) {
                        const brush = this.#processorContext.getDefaults().getBrushTree();
                        this.#elementArea.setElement(x, y, brush.apply(x, y, this.#random));
                        this.#processorContext.trigger(x, y);
                    }
                }
            }
    
            static couldGrowUpHere(elementArea, x, y) {
                if (x < 0 || y < 12) {
                    return false;
                }
                if (x > elementArea.getWidth() - 5 || y > elementArea.getHeight() - 2) {
                    return false;
                }
                let e1 = elementArea.getElementHead(x, y);
                if (ElementHead.getBehaviour(e1) !== ElementHead.BEHAVIOUR_GRASS) {
                    return false;
                }
                if (ElementHead.getTemperature(e1) > 0) {
                    return false;
                }
                let e2 = elementArea.getElementHead(x, y + 1);
                if (ElementHead.getBehaviour(e2) !== ElementHead.BEHAVIOUR_SOIL) {
                    return false;
                }
                if (ElementHead.getTemperature(e2) > 0) {
                    return false;
                }
    
                // check space directly above
                for (let dy = 1; dy < 18; dy++) {
                    if (!ExtensionSpawnTrees.#isSpaceHere(elementArea, x, y - dy)) {
                        return false;
                    }
                }
    
                // check trees around
                for (let dx = -15; dx < 15; dx++) {
                    if (ExtensionSpawnTrees.#isOtherThreeThere(elementArea, x + dx, y - 4)) {
                        return false;
                    }
                }
    
                // check space above - left & right
                for (let dy = 10; dy < 15; dy++) {
                    if (!ExtensionSpawnTrees.#isSpaceHere(elementArea, x - 8, y - dy)) {
                        return false;
                    }
                    if (!ExtensionSpawnTrees.#isSpaceHere(elementArea, x + 8, y - dy)) {
                        return false;
                    }
                }
    
                return true;
            }
    
            static #isSpaceHere(elementArea, tx, ty) {
                let targetElementHead = elementArea.getElementHead(tx, ty);
                if (ElementHead.getTypeClass(targetElementHead) === ElementHead.TYPE_AIR) {
                    return true;
                }
                if (ElementHead.getBehaviour(targetElementHead) === ElementHead.BEHAVIOUR_GRASS) {
                    return true;
                }
                return false;
            }
    
            static #isOtherThreeThere(elementArea, tx, ty) {
                let targetElementHead = elementArea.getElementHead(tx, ty);
                let behaviour = ElementHead.getBehaviour(targetElementHead);
                if (behaviour === ElementHead.BEHAVIOUR_TREE_TRUNK || behaviour === ElementHead.BEHAVIOUR_TREE) {
                    return true;
                }
                return false;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-05
         */
        class ExtensionSpawnButterflies extends Extension {
    
            /** @type ElementArea */
            #elementArea;
            /** @type DeterministicRandom */
            #random;
            /** @type ProcessorContext */
            #processorContext;
            /** @type EntityManager */
            #entityManager;
    
            /**
             *
             * @param gameState {GameState}
             */
            constructor(gameState) {
                super();
                this.#elementArea = gameState.elementArea;
                this.#random = gameState.random;
                this.#processorContext = gameState.processorContext;
                this.#entityManager = gameState.entityManager;
            }
    
            run() {
                if ((this.#processorContext.getIteration() + 500) % 1000 === 0) {
                    const butterflyCount = this.#entityManager.countEntities('butterfly');
    
                    if (butterflyCount > 3) {
                        return;
                    }
    
                    const x = this.#random.nextInt(this.#elementArea.getWidth() - 20) + 10;
                    const y = this.#findSpawnY(this.#elementArea, x);
                    if (y !== null) {
                        this.#entityManager.addSerializedEntity(Entities.butterfly(x, y));
                        this.#processorContext.trigger(x, y);
                    }
                }
            }
    
            #findSpawnY(elementArea, x) {
                let airCount = 0;
    
                for (let y = 0; y < elementArea.getHeight(); y++) {
                    const elementHead = elementArea.getElementHead(x, y);
                    if (ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_AIR) {
                        airCount++;
                    } else if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_GRASS) {
                        if (airCount >= 15 && this.#isSpaceAround(x, y - 4)) {
                            return y - 4;
                        }
                        break;
                    } else {
                        airCount = 0;
                    }
                }
    
                return null;
            }
    
            #isSpaceAround(x, y) {
                for (let dy = -5; dy <= 2; dy++) {
                    for (let dx = -5; dx <= 5; dx++) {
                        const ex = x + dx;
                        const ey = y + dy;
                        const elementHead = this.#elementArea.getElementHeadOrNull(ex, ey);
                        if (elementHead === null) {
                            return false;
                        }
                        if (ElementHead.getTypeClass(elementHead) !== ElementHead.TYPE_AIR) {
                            return false;
                        }
                        if (ElementHead.getTemperature(elementHead) > 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-05
         */
        class ExtensionSpawnBirds extends Extension {
    
            /** @type ElementArea */
            #elementArea;
            /** @type DeterministicRandom */
            #random;
            /** @type ProcessorContext */
            #processorContext;
            /** @type EntityManager */
            #entityManager;
    
            /**
             *
             * @param gameState {GameState}
             */
            constructor(gameState) {
                super();
                this.#elementArea = gameState.elementArea;
                this.#random = gameState.random;
                this.#processorContext = gameState.processorContext;
                this.#entityManager = gameState.entityManager;
            }
    
            run() {
                if ((this.#processorContext.getIteration() + 700) % 1000 === 0) {
                    const birdCount = this.#entityManager.countEntities('bird');
    
                    if (birdCount > 4) {
                        return;
                    }
    
                    const x = this.#random.nextInt(this.#elementArea.getWidth() - 20) + 10;
                    const y = this.#findSpawnY(this.#elementArea, x);
                    if (y !== null) {
                        this.#entityManager.addSerializedEntity(Entities.bird(x, y));
                        this.#processorContext.trigger(x, y);
                    }
                }
            }
    
            #findSpawnY(elementArea, x) {
                let airCount = 0;
    
                for (let y = 0; y < elementArea.getHeight(); y++) {
                    const elementHead = elementArea.getElementHead(x, y);
                    if (ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_AIR) {
                        airCount++;
                    } else if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_TREE_LEAF) {
                        if (airCount >= 15 && this.#isSpaceAround(x, y - 5)) {
                            return y - 5;
                        }
                        break;
                    } else {
                        airCount = 0;
                    }
                }
    
                return null;
            }
    
            #isSpaceAround(x, y) {
                for (let dy = -6; dy <= 2; dy++) {
                    for (let dx = -5; dx <= 5; dx++) {
                        const ex = x + dx;
                        const ey = y + dy;
                        const elementHead = this.#elementArea.getElementHeadOrNull(ex, ey);
                        if (elementHead === null) {
                            return false;
                        }
                        if (ElementHead.getTypeClass(elementHead) !== ElementHead.TYPE_AIR) {
                            return false;
                        }
                        if (ElementHead.getTemperature(elementHead) > 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        /**
         *
         * @author Patrik Harag
         * @version 2024-05-08
         */
        class ExtensionGenWaypoints extends Extension {
    
            /** @type GameState */
            #gameState;
    
            /**
             *
             * @param gameState {GameState}
             */
            constructor(gameState) {
                super();
                this.#gameState = gameState;
            }
    
            run() {
                if ((this.#gameState.processorContext.getIteration() + 700) % 1000 === 0) {
                    this.#generateWaypoint('fish', 20, 5, 2);
                }
                if ((this.#gameState.processorContext.getIteration() + 800) % 1000 === 0) {
                    this.#generateWaypoint('butterfly', 20, 5, 4);
                }
                if ((this.#gameState.processorContext.getIteration() + 900) % 1000 === 0) {
                    this.#generateWaypoint('bird', 100, 50, 8);
                }
            }
    
            #generateWaypoint(entityType, maxHorDiff, maxVerDiff, maxVar) {
                const entities = this.#gameState.entityManager.getEntities().filter(e => e.getType() === entityType);
                if (entities.length > 0) {
                    const random = this.#gameState.random;
    
                    let groups;
                    if (entities.length === 1) {
                        groups = [[entities[0].getX(), entities[0].getY(), entities]];
                    } else {
                        let k = entities.length === 2 ? 1 : 2;
                        if (random.next() < 0.2) {
                            // break groups sometimes...
                            k++;
                        }
                        groups = this.#kMeans(entities, k);
                    }
    
                    for (const [cx, cy, list] of groups) {
                        let wx = cx + random.nextInt(2 * maxHorDiff) - maxHorDiff;
                        let wy = cy + random.nextInt(2 * maxVerDiff) - maxVerDiff;
    
                        const maxWidth = this.#gameState.elementArea.getWidth();
                        wx = Math.abs(wx);
                        if (wx >= maxWidth) {
                            wx = maxWidth - (wx - maxWidth);
                        }
    
                        const maxHeight = this.#gameState.elementArea.getHeight();
                        wy = Math.abs(wy);
                        if (wy >= maxHeight) {
                            wy = maxHeight - (wy - maxHeight);
                        }
    
                        for (let entity of list) {
                            if (typeof entity.assignWaypoint === 'function') {
                                const wyy = wy + random.nextInt(2 * maxVar) - maxVar;
                                const wxx = wx + random.nextInt(2 * maxVar) - maxVar;
                                entity.assignWaypoint(wxx, wyy);
                            }
                        }
                    }
                }
            }
    
            #kMeans(entities, k) {
                // Initialize centroids randomly
                let centroids = entities.slice(0, k);
    
                let assignment = new Array(entities.length);
                let clusters = new Array(k);
    
                while (true) {
                    // Assign each entity to the closest centroid
                    for (let i = 0; i < entities.length; i++) {
                        let minDistance = Infinity;
                        for (let j = 0; j < k; j++) {
                            let dx = entities[i].getX() - centroids[j].getX();
                            let dy = entities[i].getY() - centroids[j].getY();
                            let distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < minDistance) {
                                minDistance = distance;
                                assignment[i] = j;
                            }
                        }
                    }
    
                    // Calculate new centroids
                    let newCentroids = new Array(k);
                    for (let i = 0; i < k; i++) {
                        clusters[i] = [];
                        let sumX = 0, sumY = 0, count = 0;
                        for (let j = 0; j < entities.length; j++) {
                            if (assignment[j] === i) {
                                sumX += entities[j].getX();
                                sumY += entities[j].getY();
                                count++;
                                clusters[i].push(entities[j]);
                            }
                        }
                        const cx = Math.round(sumX / count);
                        const cy = Math.round(sumY / count);
                        newCentroids[i] = { getX: () => cx, getY: () => cy };
                    }
    
                    // Check for convergence
                    let converged = true;
                    for (let i = 0; i < k; i++) {
                        if (centroids[i].getX() !== newCentroids[i].getX() || centroids[i].getY() !== newCentroids[i].getY()) {
                            converged = false;
                            break;
                        }
                    }
    
                    if (converged) {
                        break;
                    }
    
                    centroids = newCentroids;
                }
    
                // Return the result
                let result = [];
                for (let i = 0; i < k; i++) {
                    result.push([centroids[i].getX(), centroids[i].getY(), clusters[i]]);
                }
                return result;
            }
        }
    
        // Sand Game JS; Patrik Harag, https://harag.cz; all rights reserved
    
        const brushes = BrushDefs._LIST;
        const tools = ToolDefs._LIST;
    
        /**
         * Initialize Sand Game JS.
         *
         * @param root {HTMLElement}
         * @param config {{
         *     version: undefined|string,
         *     debug: undefined|boolean,
         *     canvas: undefined|{
         *         scale: undefined|number,
         *         maxWidthPx: undefined|number,
         *         maxHeightPx: undefined|number
         *     },
         *     autoStart: undefined|boolean,
         *     scene: undefined|string|{init:(function(SandGame, Controller):Promise<any>|any)},
         *     scenes: undefined|Scene[]|Object.<string,Scene>,
         *     extensions: undefined|Object.<string,boolean>,
         *     brushes: undefined|Object.<string,Brush>,
         *     tools: undefined|(string|Tool)[],
         *     primaryTool: undefined|string|Tool,
         *     secondaryTool: undefined|string|Tool,
         *     tertiaryTool: undefined|string|Tool,
         *     disableBigButtons: undefined|boolean,
         *     disableRestart: undefined|boolean,
         *     disableStartStop: undefined|boolean,
         *     disableImport: undefined|boolean,
         *     disableExport: undefined|boolean,
         *     disableSizeChange: undefined|boolean,
         *     disableSceneSelection: undefined|boolean,
         *     disableGlobalShortcuts: undefined|boolean,
         *     errorReporter: undefined|function(type:string,message:string,controller:Controller),
         * }}
         * @returns {Controller}
         *
         * @author Patrik Harag
         * @version 2024-05-08
         */
        function init(root, config) {
            if (config === undefined) {
                config = {};
            }
    
            let controller;
    
            const {width, height, scale} = SizeUtils.determineOptimalSizes(root, config.canvas);
    
            const init = {
                scale: scale,
                canvasWidthPx: width,
                canvasHeightPx: height,
                version: config.version
            };
    
            const enableDebug = config.debug === true;
            const enableAutoStart = config.autoStart === undefined || config.autoStart === true;
            const enableRestart = !(config.disableRestart === true);
            const enableStartStop = !(config.disableStartStop === true);
            const enableImport = !(config.disableImport === true);
            const enableExport = !(config.disableExport === true);
            const enableSizeChange = !(config.disableSizeChange === true);
            const enableSceneSelection = !(config.disableSceneSelection === true);
            const enableGlobalShortcuts = !(config.disableGlobalShortcuts === true);
            const enableUserErrorReporting = config.errorReporter !== undefined;
            const enableBigButtons = config.disableBigButtons !== undefined && config.disableBigButtons === false;
    
            const errorReporter = config.errorReporter;
    
            // resolve processor defaults - brushes & extensions
    
            let brushes;
            if (typeof config.brushes === 'object') {
                brushes = config.brushes;
            } else if (config.brushes === undefined) {
                brushes = undefined;
            } else {
                throw "config.brushes - wrong type, expected object";
            }
    
            let extensions;
            if (typeof config.extensions === 'object') {
                extensions = config.extensions;
            } else if (config.extensions === undefined) {
                extensions = {
                    spawnFish: true,
                    spawnGrass: true,
                    spawnTrees: true,
                    spawnButterflies: true,
                    spawnBirds: true,
                    generateWaypoints: true,
                };
            } else {
                throw "config.extensions - wrong type, expected object";
            }
    
            const extensionsFactory = (gameState) => {
                const array = [];
                if (extensions.spawnFish === true) {
                    array.push(new ExtensionSpawnFish(gameState));
                }
                if (extensions.spawnGrass === true) {
                    array.push(new ExtensionSpawnGrass(gameState));
                }
                if (extensions.spawnTrees === true) {
                    array.push(new ExtensionSpawnTrees(gameState));
                }
                if (extensions.spawnButterflies === true) {
                    array.push(new ExtensionSpawnButterflies(gameState));
                }
                if (extensions.spawnBirds === true) {
                    array.push(new ExtensionSpawnBirds(gameState));
                }
                if (extensions.generateWaypoints === true) {
                    array.push(new ExtensionGenWaypoints(gameState));
                }
                return array;
            };
    
            const defaults = new GameDefaultsImpl(brushes, extensionsFactory);
    
            // resolve scene list
    
            let scenes;
            let customScenes;
            if (Array.isArray(config.scenes)) {
                scenes = {};
                for (let i = 0; i < config.scenes.length; i++) {
                    scenes['scene_' + i] = config.scenes[i];
                }
                customScenes = true;
            } else if (typeof config.scenes === "object") {
                scenes = config.scenes;
                customScenes = true;
            } else {
                // build-in scenes
                scenes = SceneDefs.SCENES;
                customScenes = false;
            }
    
            // resolve current scene
    
            let scene;
            let sceneName;
            if (typeof config.scene === 'string') {
                // from scene list
                sceneName = config.scene;
                scene = scenes[sceneName];
                if (scene === undefined) {
                    throw 'Scene not found: ' + sceneName;
                }
            } else if (typeof config.scene === 'object') {
                // custom scene
                sceneName = 'n/a';
                const sceneFunc = (typeof config.scene.init === 'function')
                    ? (sandGame) => config.scene.init(sandGame, controller)
                    : () => {};
                scene = Scenes.custom('n/a', sceneFunc);
            } else {
                // default scene
                if (customScenes) {
                    // select first
                    sceneName = Object.keys(scenes)[0];
                    scene = Object.values(scenes)[0];
                } else {
                    if (enableDebug) {
                        sceneName = 'landscape_1';  // always the same
                    } else {
                        sceneName = (Math.random() > 0.1) ? 'landscape_1' : 'landscape_2';
                    }
                    scene = scenes[sceneName];
                }
            }
    
            // resolve tools
    
            function resolveTool(t, defaultTool = null) {
                if (typeof t === 'string') {
                    let tool = ToolDefs.byCodeName(t);
                    if (tool !== null) {
                        return tool;
                    } else if (enableDebug) {
                        throw 'Tool not found: ' + t;
                    }
                    return defaultTool;
                } else if (typeof t === 'object' && t instanceof Tool) {
                    return t;
                } else {
                    if (enableDebug) {
                        throw 'Unexpected tool type';
                    }
                    return defaultTool;
                }
            }
    
            let tools;
            if (Array.isArray(config.tools)) {
                tools = [];
                for (let t of config.tools) {
                    let tool = resolveTool(t, null);
                    if (tool !== null) {
                        tools.push(tool);
                    }
                }
            } else {
                tools = ToolDefs.DEFAULT_TOOLS;
            }
            // tools = Tools.grouping(ToolDefs.DEFAULT_TOOLS, ToolDefs.DEFAULT_CATEGORY_DEFINITIONS);
    
            let primaryTool;
            if (config.primaryTool === undefined || (primaryTool = resolveTool(config.primaryTool)) === null) {
                primaryTool = ToolDefs.SAND;
            }
    
            let secondaryTool;
            if (config.secondaryTool === undefined || (secondaryTool = resolveTool(config.secondaryTool)) === null) {
                secondaryTool = ToolDefs.ERASE;
            }
    
            let tertiaryTool;
            if (config.tertiaryTool === undefined || (tertiaryTool = resolveTool(config.tertiaryTool)) === null) {
                tertiaryTool = ToolDefs.METEOR;
            }
    
            // init controller
    
            const dialogAnchorNode = DomBuilder.div({ class: 'sand-game-dialog-anchor sand-game-component' });
            document.body.prepend(dialogAnchorNode);
            const toolManager = new ServiceToolManager(primaryTool, secondaryTool, tertiaryTool);
            controller = new Controller(init, dialogAnchorNode, toolManager, defaults);
    
            // init error reporting
    
            if (errorReporter !== undefined) {
                controller.addOnFailure((type, message) => errorReporter(type, message, controller));
            }
    
            // init components
    
            const mainComponent = new ComponentContainer('sand-game-component', [
                new ComponentViewTools(tools, enableImport, enableBigButtons),
                new ComponentViewCanvas(),
                new ComponentContainer('sand-game-options', [
                    new ComponentContainer('sand-game-options-left', [
                        (enableImport) ? new ComponentButton('Import', ComponentButton.CLASS_LIGHT, new ActionIOImport()) : null,
                        (enableExport) ? new ComponentButton('Export', ComponentButton.CLASS_LIGHT, new ActionIOExport()) : null,
                        (enableRestart && !enableSceneSelection) ? new ComponentButtonRestart(ComponentButton.CLASS_LIGHT) : null,
                        (enableStartStop) ? new ComponentButtonStartStop(ComponentButton.CLASS_LIGHT) : null,
                        new ComponentStatusIndicator((enableSizeChange)
                                ? DomBuilder.element('span', null, [DomBuilder.element('br'), 'Tip: adjust scale if needed'])
                                : null),
                    ]),
                    new ComponentContainer('sand-game-options-right', [
                        (enableUserErrorReporting) ? new ComponentButtonReport(ComponentButton.CLASS_LIGHT, errorReporter) : null,
                    ]),
                ]),
                new ComponentContainer('sand-game-views', [
                    (enableSizeChange || enableSceneSelection) ? new ComponentContainer(null, [
                        (enableSizeChange) ? new ComponentButtonAdjustScale() : null,
                        (enableSceneSelection) ? new ComponentSimple(DomBuilder.span('Scenes', { class: 'scenes-label' })) : null,
                        (enableSceneSelection) ? new ComponentViewSceneSelection(controller, scenes, sceneName) : null,
                    ]) : null,
                    (enableDebug) ? new ComponentViewTestTools() : null,
                ])
            ]);
    
            // build HTML nodes and start
    
            const node = mainComponent.createNode(controller);
            root.innerHTML = '';
            root.append(node);
    
            controller.setup(scene);
            if (enableImport) {
                controller.getIOManager().initFileDragAndDrop(node);
            }
            if (enableGlobalShortcuts) {
                controller.enableGlobalShortcuts();
            }
            if (enableAutoStart) {
                controller.start();
            }
    
            Analytics.triggerFeatureUsed(Analytics.FEATURE_APP_INITIALIZED);
    
            return controller;
        }
    
        exports.BrushDefs = BrushDefs;
        exports.Brushes = Brushes;
        exports.Entities = Entities;
        exports.PredicateDefs = PredicateDefs;
        exports.Resources = Resources;
        exports.SceneDefs = SceneDefs;
        exports.Scenes = Scenes;
        exports.ToolDefs = ToolDefs;
        exports.Tools = Tools;
        exports.brushes = brushes;
        exports.init = init;
        exports.tools = tools;
    
        Object.defineProperty(exports, '__esModule', { value: true });
    
    }));
    //# sourceMappingURL=sand-game-js.umd.js.map
    </script>
  <script defer>/* Cheese Game; Mecanix Creations, all rights reserved */
  /* Sand Saga; Patrik Harag, https://harag.cz; all rights reserved */
  ! function(A, e) {
      "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((A = "undefined" != typeof globalThis ? globalThis : A || self).SandSaga = {})
  }(this, (function(A) {
      "use strict";
      class e {
          static #A = "/api/user/";
          static sendCompleted(A, a, g, o) {
              const t = new FormData;
              t.append("scenario", A);
              const r = e.#e(a);
              if (t.append("metadata", JSON.stringify(r)), !0 === o) {
                  const A = e.#a(a);
                  null !== A && t.append("data", A)
              }
              const i = fetch(e.#A + "scenario-completed", {
                  method: "POST",
                  body: t,
                  headers: {
                      Accept: "application/json"
                  }
              });
              void 0 !== g && i.then((A => A.json())).then((A => {
                  "number" == typeof A.id && g(A.id)
              }))
          }
          static #g = 0;
          static #o = 3;
          static #t = 0;
          static #r = 3;
          static sendErrorReport(A, a, g, o, t) {
              if ("rendering-warning" === g) return;
              if ("user" === g) {
                  if (!(e.#g < e.#o)) return;
                  e.#g++
              } else {
                  if (!(e.#t < e.#r)) return;
                  e.#t++
              }
              const r = new FormData;
              r.append("scenario", A), r.append("location", g), r.append("message", o);
              const i = e.#e(a);
              if (r.append("metadata", JSON.stringify(i)), !0 === t) {
                  const A = e.#a(a);
                  null !== A && r.append("data", A)
              }
              fetch(e.#A + "report", {
                  method: "POST",
                  body: r
              })
          }
          static sendUpdate(A, a) {
              const g = new FormData;
              g.append("scenario", A), fetch(e.#A + "update", {
                  method: "POST",
                  body: g
              })
          }
          static #e(A) {
              const e = A.getSandGame();
              return {
                  width: null !== e ? e.getWidth() : null,
                  height: null !== e ? e.getHeight() : null,
                  userAgent: navigator.userAgent
              }
          }
          static #a(A) {
              try {
                  const e = A.createSnapshot();
                  if (null === e) return null;
                  const a = window.SandGameJS.Resources.createResourceFromSnapshot(e);
                  return new Blob([a])
              } catch (A) {
                  return console.warn(A), null
              }
          }
      }
      class a {
          static init(A, a, g) {
              let o = {};
              Object.assign(o, a), Object.assign(o, g), o.errorReporter = (A, g, o) => {
                  try {
                      e.sendErrorReport(a.scenario, o, A, g, !0)
                  } catch (A) {}
              };
              const t = window.SandGameJS.init(A, o);
              let r = 0;
              const i = A => {
                      A.scenario().addOnStatusCompleted((() => {
                          if (void 0 !== a.onCompleted) try {
                              a.onCompleted()
                          } catch (A) {}
                          try {
                              e.sendCompleted(a.scenario, t, a.onAccepted, a.includeSnapshot)
                          } catch (A) {}
                      })), A.addOnProcessed((() => {
                          r++, 1e4 === r && A.scenario().setCompleted()
                      }))
                  },
                  l = t.getSandGame();
              return null !== l && i(l), t.addOnInitialized(i), setInterval((() => e.sendUpdate(a.scenario, t)), 6e4), t
          }
      }
      const g = window.SandGameJS.Brushes,
          o = window.SandGameJS.BrushDefs,
          t = window.SandGameJS.Tools,
          r = window.SandGameJS.ToolDefs,
          i = window.SandGameJS.Scenes,
          l = window.SandGameJS.SceneDefs,
          E = window.SandGameJS.PredicateDefs,
          eQ = window.SandGameJS.TemplateDefs,
          tU = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAALtJREFUKFNjvHz++P+vn98zfPzwjgEE+AWEwDQ3ryDDs8d3GRi35qb8Bwk8evWawTA7neH81JkMcmKiDL9+/WJgY2NjYJwe7v+fk4sbrEsy0Ivh4pI1DGLcXAz8bCxgMcausID/vIxgQxjkwrwZHq3ayvD5PyNY0fdvXxkYCboBpODRvLlgE0D2gsCLDx8ZQNaCTThxaNv/G/OXgO28/f4T2OhXX7+BFYKsBltxpKMDrAMkARIEuQFEg8QA9mBbK1rMQigAAAAASUVORK5CYIIA",
          n = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAALhJREFUWEdj/LPQ5j/DAAJGsAM+PSLohD8fnzKwyFoyEKMWZBgx6kFqRh0wGgLgEPjz+DjBREiOAlCiJWQ2JAoGEDD+mSyH4QBishDMzcSoxadm1AGMP1qYsaYBYhIQLBqIUYtLzSBIhETWBcSW76QmTqJLwlEHDO8QIFReI5fUxGQ5UrLnIMiGo3XBiA+B0cqI2I4JcllAaSsIucIiqTIitaYj1JMiqWc0GgI0DQFSKiNSKhpiKi4AJC3G9LKZja0AAAAASUVORK5CYIIA",
          B = "data:image/png;base64,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",
          s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAAAXNSR0IArs4c6QAAEUlJREFUGBnVwU3Pp+dZ3/Hv7zjO67ptRwQqFgWPZ8aGTZG6TeKnOKXQvgU2QAIVCOxMnF0LJJGIQiJ15WRIVFFUMFCp4jW0oCS2UxbdVZW6gBnf8xBKE9tjx5mZ6zqP49dJHySU5jlzz/2fz0ecsnrxfZ4uYiRZjWmkQC5s6DCqFWcRAQ1oL2asREGEyQ98QRw4ccrm587YrNhFNNAQLrab/4N4+EmWN64wYyM0cEwoERYtQSdWsd/4Mg99dBcHLDhF28VH7R7kBjETAliEFwENFFs26cRluhIcuE2SYDMGjJ70Z8+ZAxacktufO+thk2pqaZyNWhjRbdKwWIwWSkM2CwUKnMlkx+ukyszFiGa+cMYcqOAe2z61ePvj93lBlEwziH2SLiIMteMIyoPpZo6dLoEDZ0IZojCBSCARYpumEHXxEXOAxD1y65MyCijQo4/jS69QDbGIYbFZZJqiWfakl6JqYdWkIlAJe5IShXA0srGCqEGosBqz4C4UwdHv7OJAiHtg/6P3GXY6AAURJmbi3BGiOjGQYXJvjPAi2AuvQCWOhjbuIJaku0gZK2GabhNrUzNhwOim2ywf+JI4AIMTdvtzj1hvHtOjALGqaQfaTSfgYL9xhaPHnkBfPWYnCBoCUMHbIC20i/2NL/Pyn/8MxgTiZ3/9TcBIJjrZv3aF5dzTxOt/gxyY5lAEJyx3sHcgCKC2wexC2UQA0SSQE+ZIyCYTnE3VSjYQEBIMY0EgWuY//cE7CTWykHZGNdRkRlM2DHEoBicsw+wMvO9ErqR2IgwIGv7i3/4o8KOo3wB+hBb83G++gQ3rstEzqX0nFrHwf7QgLBA0g+pixEr14KiEtZA0VUFdfMR54ao4ZYMTVH/2jG//9UuQSckogtk7HUG66V7AP4YwHUKADPX6VWxxCxNu3ElJaAFZiKYFMvj1q0jBLcMANsx87Qp7gTKIFodgcIJ6h3HuSTqD4YkJlmomg3WBfQf8Bg1IYBth8icfJ0fQBjro0WgXjODn/yX8x3/9GtGAIM89iXpHhswVFfDI09ANWVABvMRpEydku/iIs4KJWULsKlYGt29cYz37JPvrxywUleYv/+DHsAPJGPjnv/YWeHL7ravE2WfINy/jhJpCMiFTPaB3YoX9K9c5eud5lAaJZoICdpOL0XNXxCkbnJBFwTYanMhijaCqiAj2gjWLCnAlEKDmG37+12+wYSIDaUFpWo17kG56QBWEQQq0wQihsdNAIGwIC6fYtXMIBidkm0kMcJpp4wljabqLhUmVaAQyP/ubrxMVtE1lAhNVE7XTDrIMAY4mWvzXf/8wtjDmH7//KupgWkSLPbgjEeAEe+UQDE5IrI0KRFMEGQFlWsYCZAKIbmYsyBP3wDaSgaS0sLghQSr+4t/8A1oGfx1hsBALM5qlhQ1LNT1Ee8K2MnJyCAYn5cYxc4cYAW2MuJWgGcQymG9dgUpuJoSSnkVlkipKYMwiURb9xt/x+T//GWQjC3FHCHPH/7xOJGxfu87A3DaoBcN0Q6k4BIMTMs48RRsyYBaoxYMx2SyqmnjkCVrJSLFsgbKYNGKADTKRQc3J5//DPwIaArCwjVoI04+9G1QsDujggVEUIiqpmiy/+oo4AIMTcvvVlzk69xTbW6/CLhSGGKwY5o49sMQX/vCdWMYGCQz83L/4GshMmRAQ74QOjJGFw/yTX3sdOtBrrxMjCQW3v3Kd8dOPw+uXmVVIK4dicFJyUDSqYEQzK6kqGE14oZL/zTKyMI1aSOYv//BHMHfYSCDuUIPFP/1X74Q3XyUq6EXEFuwGeUIW2wYZ4EzWZy+JAxGckAd+e1e1WRC7RGgnsogIOmG0iBa2aYyADgNBc4eMxB0Cc4d45hf+G1FJVSInUWIusBqig6iEIb7h6NljcUCCE7TEoKuJKhwBrDAbChw7I4qf+40bPP0L/x0hBDRGNLKxwRgh/tmv34CCpsiauJvCWI2jaUOHkWA8dywOjLgH+o+fccUECyoRhgySYgpwElnYRdZCtXGCsmAPIkAZFBP2hFFQgxw7drI3ZAbjF78gDtTgHui3LyESWswb1zh6+N3srx/Ty4Y7SUS0wI0zyWpqNGWIHswfPwevXyJChJt2gxfKggBuXGN8ZBMHLLgHxnNX1J6kN4KNziaGyX1lyBQFMqxFR7GnELA0KHbGDg4QpkPASnvSWYiNaXPogntk/eBVlcQsiAbcNNAlkoGjmXMQLYJGnUwLZVBLMaroEmFTNEuCopgsvOOjuzhwwT00LlyV1mRzIAFpxihMYRlFAQKEVCiBDXprnAtKYYnVBgVUcnThsrgPBPfYg79VWhbAgRDNimvgfQDG1VBQFQioFTJF1yS7USU4qYLlwrG4T4hTtH9icRkcDYYkqJhkDYhmlogU4/yT7MevkAaHccMDvzPFfWRwiuLMu2iJlYFzo5xkgzoZuREdeIj0pH7iPeSSVBfQwCvcT8Qpu/3CI15zUAaHEBsRg5uvvcqDZ59Abx7TBbEkO8Y9GNHkc6+K+8jglGUO2g02HYFaeJ9kDiZBpMgEt7CbJZt9F/eb4JS5oQKIgaoJQy8LvU+M0Uy2LdgJRCAHK8383KOuTz9q7hPBKYvYySiCIhAmSJslkiSwzJpNRBEkcy9qBNomocn89GPmPiBO2e2PL65opMTecQTrbpwCkr0gBjQ7qxe2bhYbhugyhVDAQx+Z4oANTtHtP3nGaZMdZEJ54gxgMmowHSy5wQwWN83gAYyi8TAxV1ZNTABf5JCJU3L7s+csQwB94zpx7l3w1SuQoDSeCxHNXkAEKzs3X/s7Hvyp9+A3r+IuVE0pURShhfjgZXGggtMyzTKDMPQsqIQlSC3ks9dkNXsXimaNHUjGWlQ3vYsO2NfENlRSVdz6FOZABffYdvGst4vnnEtgdjqDJGkFCNob3xCdKJPBHfvCFqYdjPe/oqIJhDpRCBJkwb6w/8mT5gAN7qH9d8PbjSsIiFxhm4imGQzE9pWrPPSxFnfU29dgL2YUlUF0As03zK9dJzxRBN1BRLMFrAEC3v64/I6PWRwQcY/UnzzlDtFdyOBKlgEtEQ2zm/VXXhb/13zxGTtM1MQJOGmb9f0vizu2P3vG0Tt4QAMxsZOOZKXYZdZfelkcCHHC/Jmz3jHLSKpNv3YdnX8P+carNMaI5fmr4pv4hTO+efNvWX/y3eTXr7HbLB3owqvi7+mLZ3zrjb/lwR99mKmgWyyj2IFRpkeyPPuqOGXBCbp98bytYDjYW5STPYQSKkwsyfL8VfEtzEiiRYykHOSebCm+WVy4poc+WqqRRJiMpmcjQaUZNLd+d5hTFpyQ/YUzzgZHozBL7UTsgGFvlIEcfDsaibuhoWqn10azmBcfMd+CZiEBAjlha7KD2gYkpy44IWMBLU1N0w52gWuwKlAmno2euyy+jXYTbvYIBknvkIi0+Vamxb41OcGZ5BooBxGFJPrFp8wpGpyQW1/9W1oibWaKYdNtMoSnWT50TXwH+2vH5JIc7Ts337qKOynvZAy+laPnj3XzU8N7QVdQy866D2otpMYdnCZxAvzHT5tO5tL0bDKBHtgbreToAy+J70H/6TP2BFJM70QlnXD0/i+Kb2P70/eZ3hkOWiKymD3Ak/X9r4hTMrjL/OlHzJvH3H7jmHH+SfT2VWKKPU1mc/TsVfE96tcuUxGAWCluvnad9ex7+I4m5FvXmT0RAVmMXKBhu/io1wuXxSkI7qLtM4+5FDiMgULIhhWygvHsVfH9WGBVgwtHEhmg4DtZf+XzKhXOBSiaFddOh3GZ+cI5cwqCu8hjh1EQoiNYHKiSuYnx4cvi+7UHm0Gj8OSOCVl8N+uFK1qZdECyI0HarAIyOA3iLtl/F3ckkYISE7OeeRd1/T+zfsTiB/D2J1cvMpqiRuOtODr/OPvxf+HoY5v4Lm79npy1sNss2nGsdE28mgd/y+IeGtwt558huukoFq10Fw6jR54CXuIH8dCZx9myWboBYQtVE4++C3iZ7+bo3JNsakYttJslA3lnrwX4AveSuEv2i4+6EXHjGJ15At+8zNhBz18VP4T9c+fNAw/jt79MlomlqBbjwhXxPbj96cfcX79E/sTTxJvHaEny2UviHgvukuXCZa1qpoNeRNro+avih1aEkoyCEVQHGcH36uj5S8oSSwoF5LOXxCkY3EX64Ku69YnV0Saeuybugu5AAVFJhVGZ2Xxf1o9Y8EVO0+Aue+Ajm+Al7poAAqQdGJCgLO43wQHbPvuYcxPZQcXKcPANta/cb8SB2j4hO8QEjs68l/3aS/Q0WgQ27sE7PrKJ+8TgQMXDz8AwSeHeWc49gfcmMugwbAZe4X4hDlBdPOfbrx2z/vT74CuXaQWLN4okR7PPQTABMT58RdwHggPkbIIB01TAkqa4Y02qg1iEV1Gr2T533twHggOkEiLo3JGgZXINCoOSpBk7sJlocz8IDlC0iFF4DhyB2mxlxjTVDYaZgyWTcnH798IcuMEBuv3GNXJpuPpXWHCzN9YlqILpQFHMCpxmlkDNoRscGP+797rWIHtSNG2xYroXRHOURbMwPIlceIhmVgGvcMgGB2b/2t8QsbBjQiZ2MyWsoF6/yvpTjzPeusJeO9mBoxgZHLrgwISgoogIPAtiQMDRhy4rBWlwTZZKiMCd1MbBEwdk+2QaNx1BE3gzawbuYv1YiTvmi0+5rnwJK5CNMWkzMQ9+FHGgBgckzjxFa2cRuBJIFE3+8hfF/xNmnH0ctwiJliHFWgZe5lANDki8fYXcd/YwqqTeusLR2Sf5++qrV1kXU3uyLyZo/NXrLD92ltuffcxHz10SByg4EPtnz7iq2UbgWiGhYlBh/r6jDx+rW/QQuRtV0CFQE3tzqIID0J951GOKQAiItRnA2gIt/H9cJJNcG8tECneS2dSnz5sDFByAPQxaqGwsGBOoZFcjim+WH7qmrqT2QVfRPRGTbtNMDlFwyvzCY1aJ1o52GBNo6Chkk7/0kvgWHE1jxiJCgRMyoZdkfva8OTCDU3b75iWyFvZuHKILIiFSDCVQfCvrhWPtn0hvEYw22xtXqYIg0BCHZnDK1n/4BMpgeICLHsXsRE6GNuBLfDt65ElGBsMbcrAIXIMcBbzEIRmcsvnmVfT2l9H5p/CNYzyL9IoD9KFL4juot6/AnGxDRCW337zOcvYJ9NYV5mfOeHzomjgQwSmq3z9vITYZ9o2YsGTi3Fg+dEl8F0fPXdY6gnUHLDIhuMOme3BIglPiFx6x3IxMRptUUhF4giv5Xm0yvYqhHVUDxVSSIzgk4hTc+ngaFxkrmxrZrGffw7z6VxDNA79t8X34+icXhxpcrA8/za3rXyJU5AyWj7Y4AOIeqxeftgkaMaJRieqGFWJL4lc/L75P/eLTLjdJMFUstVA0JmBtll98SZyywT22X/sSy8PvZrnxZbZoFkO42C3Gh6+KH8DN4y/x0I+fYVogqBLdkxwDv9UcguAeqhfOGxI7QZNFwg6KhYzBD+odHy3VhC6xTENOwiJmY8OtT6Q5ZYN7ZP7+OVume1KZpAOV6RFEQ164JH4I2aIXUQjKsAZFIy/Y4rQF90gEUJAtFjXbMLhJT/LCJfFDcpqYO7ToSKqNdpA3pGD/o/eaUxTcA/3Co57c0UEMU3ux7sKCCu6KuHCsJoEidlhnUwHyAuw4zWkSJ6hffMZOoW2igKKpXohoFEnYxPu/IO4y/9l7PatwLTg3Rg8sQ4vxq18Up0CckLp41tg4ARs5CYL55jHj/NPsb/w16weviRNSnz5nZaG5ML9+HT38LuKty6gTPX8s7rHgxDShQAyslYigmEyLrcX6wWviBOXzx1LBvk6KOyy6BpWciuCEGNEquiDbzBbR0JEc/fLnxT1QubI4sTcywBmEk9PwvwBpeTC+DhZftAAAAABJRU5ErkJggg==",
          d = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAECAYAAABsgwTvAAAAAXNSR0IArs4c6QAAADNJREFUKFNj/LNO7j8DFLAEPWKkhM94q48ZbhjMUHJpxh+LIIZxxP1lxGYITJ4YNVQ1DADtlSpufcvnMwAAAABJRU5ErkJgggAA",
          C = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAXNSR0IArs4c6QAAAPBJREFUOE+llD0OwjAMhZupDFRsrcQF2LgFp+YWbFwAqd1QGegUZEuvejWOFUGGKo3jL/55SWoqR845L69Jdy/zuHph3p8uSRb1E433PGbYGWTB8i/QDVCc233fIJJdNyRZsyAPtgFyFGIQqDo5KZZgyCJN92tuu2HNmueRsxe11tACS/WUg7xm2P1VQI46aozsU6DWjdKOomSbl7Z2GVB0qnQIDoUSLFAjLEVjoQxjBaBxYheZhcJmqDiwRm3qVUCUQ2FUY6921UCGRlf0cDzX3WVAno9b8U7jYVBhx0/D1spqgCK+hP0LkCP6C1hz+AcUIZOsgsl82wAAAABJRU5ErkJgggAA",
          h = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAKFJREFUOE9jvHG06T+fmB7Dz28vGUDg55eXDCj8ry8Z+EQR8l/f32UQkraCq2fEZgBIwdePdyEGUmoAuo0EXQBSIKbgBncBugZ0F2F4AZsByAYSNAAUiMhhgG4gUQYgxwLVDSAYiOjpgORYIMsAlISDJSUKSSESFlYvoIc6clIFhTqyAVhjAa8BaNFKsQEEYwEj6RLInViTMnoYIGdndC8AAKMLhKB4CiI3AAAAAElFTkSuQmCC",
          c = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJ5JREFUSEtjZGBgYDhvbv4fRIMAm6QkmP71/DlMiGa04cmTjIwgy2GWwmxCt/z1t29Uc4QoFxfcoyB7wA5AN52aFuJyOcwhYAfQw0JsDgE5YtQBAxoCz3/9GtgoGBwOWKiu/l+SjY1q+ZwUg8AhMOqAQRECoHijdzoAxT8IMHYoKoLrAnQHUNtBMAthiRTuAJAAKBpISb3UUht/8yYjAO2WY3bQOXpaAAAAAElFTkSuQmCC",
          Q = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAn1JREFUeF7tmbFOwzAQhl3RgallrwgSz9GHYGbhRRh5ERZmHqISD8BeiaLulImhCOQ0QW56ju/i8znClwna4Pj//P/ni5mYwq9J4fqNAlAHFE5AI1C4AbQIagQ0AoUT0AgUbgDdBTQCGoHCCWgECjeA7gIagbFEYP98+zO9eRJfEPEHQsCt+PZzaQjZAfyJf18Zc7msOUhCyArgSHxrgVl1gHC3EpmbyEN6bW9XvnsJQsgCYP+4PGT+c+OvwUIQxAHU4ueVMdDKZ3CCKADUygtDEAMAim9sDubAjUfCOIgAAKu9VT2rzPr1pdZ/fbUw67dt/XN1Ycx0vjjmkghCcgBe8VQAzf3cW2RSAL3iW0HATrDfbU8dkKhPSAYAVfAoEXADwRiHJABQ4odEIAEEdgBo8cYYa3XfdVIEoRsZnMAKgCLe3wISv4mEwAagFg/s3cE9PqQX0ytEQGABcCI+Nt+drKN6hYEQogF4bT+0wgOtMAUAtU/gAQC91dkVoe7xvkJHGWdWkc4SkgJArRyiBpDGUQAjcUD0Ht84gzzOaBwQsnaq77kBfD2c1cdXvtfTWkff0VYqob5xuQHY51gI5/ffYMEEewBp0Z2+gXKijNoFggAgFxA6uN5uETNOxKsyDwBPHxDcvjC9AqWhGtANRgOw7gDf3DAT5wbQtOCiEegDEOwEkQCC4+SsARwO6B6BHf2OcZIDwP6tr2BDtWYUEfiXAFAdHCICqHFG6QBML4AAgBnGvSdLBMBOETNzRgCuU1hrQNsK9+nZfBz+m0MGEQnAFW3nYC87D3YA7uCYhc19DyuA3GJSPx+1DaaeRM7xFUBO+mN4tjpgDKuQcw6/a8vnUHGfMV4AAAAASUVORK5CYIIA",
          m = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAUJJREFUWEftlTEOgkAQRYdIYaX2JJh4Dg9hbeMJvIGlN/AENtYegsQD2JOIoRcrCwxmB9CFZWF2wNCwFRB2/ps/O7MW9LysnvVhABgcaO1AfF4n9urEjsPeKLpHiGMXRQHYG48Vi7WpIH73ACYucnAgWADxcZlm/gx+Y4QJYQxQKZ5jMCCMAGrFmRBkAJI4A4IEgOJyvSkXCLEcjQAscQMnagG0tmfZVRpRdqrBCQR47UeJPXWUllJaTcrMv17wbTF3wL+F+OzOAApxxEcKAA6Wg4u9bW+DrysKGAcgg9ANqYLYePculKQOoOpQxlGoOvAvAHIJhLtRCOXkcjPZDvQKIDLSLeUQ/sUByiCS/mlVAuwMuUUNxGWnSGcgeKS9LC/5GwVEFhV78/lAAjBIzvjXRgDjiB1taLyMOtLRhhkABgc+eFy6IWRLfqQAAAAASUVORK5CYIIA",
          R = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAlRJREFUeF7tmUFOAzEMRVPRBSs4ABIn4S5chCUX4S6cBIkDwIpFEWhG4yo14ziJ7XSozQ5Nm+S/fDs/011y/rdzrj8FgHCAcwJRAs4NEE0wSiBKwDmBKAGpAQ4vDz/SMda+v398HbI53ZNYCccwrEE0A/gj/PPNwgAp3dyfjGsFoh+AlXCMcwGxCQDH3R8lHmAYQmhygGsAZxNv7IJqBwQAOO9H1384YCFg1AjJEiCDjgcHFFPepQM4EZ+LhWTmBgAW6gFA8ajTAoAyfu9FQisanzRBcwBK4gGaBoQjADboSB2Qi5f2kWwsKYQxADTFo2A0/SuBYA/AQrwihHEApLanuqUwIf57AIeP9xnN9dN39cUuZxkAgIbVKQA7tL+96z3yi9/bvANggXO3VoaQj73dEkgpWUDQED9tin0PWAysCUFL/FAA02T5wjUaQq/tx54CSKkWBA3xwx0g2XVpt6fmHtYDJOLz8tHaeVhPNQDr85wDdHYHXDyAr+er+Xd+KqwEgOXSoZ3mOOsfo7rw0sM2wXCA9xKYLFJyQW8PoIJPaymZnwIBYOkSlAukDoAAw/UaqlkNcUDuAnwkugGAIeAdkdbu5h0AgmGhbgFg4Vo7pzVObYDiPlf9Kllr4VrjcMJqnweAWlJaO6c1Tu26uc81O6B0Y8STrb28zJtr7Ymi+RIUr7EaAJcU10hT4aXVBVYhaFpzF4AaF5R2rcUFlrvfDGAtJGEb48sP9Q4P54zecbga5543OYALSXgy7gUmFbZax+FElp53AeBAcMKpkDVSOMz1Cww+Il+yzLqWAAAAAElFTkSuQmCC";
      class S {
          static widthFraction(A, e) {
              return Math.trunc(A.getWidth() / e)
          }
          static heightFraction(A, e) {
              return Math.trunc(A.getHeight() / e)
          }
          static mapPositionFracWH(A, e, a, g) {
              let o, t;
              if (void 0 !== g)
                  if (1 === g) {
                      const e = Math.min(A.getWidth(), A.getHeight());
                      o = e, t = e
                  } else g > 1 ? (o = Math.min(A.getWidth(), A.getHeight() * g), t = o / g) : (t = Math.min(A.getHeight(), A.getWidth() / g), o = t * g);
              const r = void 0 === o ? A.getWidth() : Math.min(o, A.getWidth()),
                  i = void 0 === t ? A.getHeight() : Math.min(t, A.getHeight()),
                  l = void 0 === o ? 0 : Math.trunc((A.getWidth() - r) / 2),
                  E = void 0 === t ? 0 : Math.trunc((A.getHeight() - i) / 2);
              return new D(l, E, r / e, i / a)
          }
      }
      class D {
          #i;
          #l;
          #E;
          #n;
          constructor(A, e, a, g) {
              this.#i = A, this.#l = e, this.#E = a, this.#n = g
          }
          x(A) {
              return Math.trunc(this.#i + A * this.#E)
          }
          y(A) {
              return Math.trunc(this.#l + A * this.#n)
          }
          w(A) {
              return Math.trunc(A * this.#E)
          }
          h(A) {
              return Math.trunc(A * this.#n)
          }
      }
  
      function I(A, e, a, o, i, l, E, n, B) {
          let s = g.colorRandomize(n, g.colorPaletteRandom(e, l));
          return t.roundBrushTool(s, B, r.SAND.getInfo().derive({
              codeName: A,
              displayName: E,
              badgeStyle: {
                  backgroundColor: `rgb(${a},${o},${i})`
              }
          }))
      }
      const w = I("blue_cheese", "217,205,181\r\n201,195,165\r\n201,181,148\r\n62,102,141\r\n154,167,180", 62, 102, 141, o.SAND, "Blue Cheese", 4, r.DEFAULT_SIZE),
          U = I("red_cheese", "136,33,33\r\n161,39,39\r\n186,45,45\r\n207,55,55\r\n213,80,80\r\n217,181,181\r\n201,148,148\r\n201,165,165", 136, 33, 33, o.SAND, "Red Cheese", 4, r.DEFAULT_SIZE),
          p = I("cheddar_jack_cheese", "229,172,26\r\n229,156,26\r\n238,211,172\r\n253,230,191", 229, 172, 26, o.GRAVEL, "Cheddar Jack", 7, r.DEFAULT_SIZE),
          F = I("test_cheddar_cheese", "249,192,46\r\n249,176,46", 249, 192, 46, o.SOIL, "(old) Grated Cheddar Cheese", 8, r.DEFAULT_SIZE),
          N = I("parmesian_cheese", "228,211,162\r\n233,220,181\r\n239,229,199\r\n244,237,218\r\n250,246,236", 228, 211, 162, o.SAND, "Parmesian Cheese", 2, r.DEFAULT_SIZE),
          y = I("grass_mac", "218,116,3\r\n238,136,23\r\n228,126,13", 218, 116, 3, o.GRASS, "Mac n Cheese", 2, r.DEFAULT_SIZE),
          G = I("tree_pasta", "221,180,117", 221, 180, 117, o.TREE, "Pasta Tree", 9, 1),
          Y = I("tree_spagetti", "251,219,101", 251, 219, 101, o.TREE_LEAF_LIGHTER, "Spagetti Leaf", 9, r.DEFAULT_SIZE),
          M = I("pasta_natural", "221,180,117\r\n227,203,156", 221, 180, 117, o.TREE_WOOD, "Hard Pasta", 6, r.DEFAULT_SIZE),
          u = I("knife_cut", "255,255,255", 255, 186, 119, o.AIR, "Slice", 6, 2),
          O = I("velveta ", "255, 166, 0", 255, 166, 0, o.WATER, "Cheese Sauce", 1, r.DEFAULT_SIZE),
          T = I("thermite_cheese", "242, 124, 66", 242, 124, 66, o.THERMITE, "Quick Igniting Cheese", 15, r.DEFAULT_SIZE),
          P = I("cheese_ignite", "255,186,119", 255, 186, 119, o.FIRE, "Cheese Based Igniter", 15, 16),
          J = I("eat", "255,255,255", 221, 180, 117, o.AIR, "Eat", 15, r.DEFAULT_SIZE),
          H = I("cheddar_cheese", "218,116,3,\r\n248,132,3,\r\n252,147,30,\r\n252,161,60,\r\n252,176,90,\r\n", 252, 147, 30, o.SOIL, "Cheese", 4, r.DEFAULT_SIZE),
          L = I("light_cheddar_cheese", "218,142,3,\r\n248,162,3,\r\n252,174,30,\r\n252,185,60,\r\n252,196,90,\r\n", 252, 174, 30, o.SAND, "Light Cheese", 4, r.DEFAULT_SIZE),
          f = I("sharp_cheddar_cheese", "218,85,3,\r\n248,97,3,\r\n252,115,30,\r\n252,134,60,\r\n252,153,90,\r\n", 252, 115, 30, o.SAND, "Sharp Cheese", 4, r.DEFAULT_SIZE),
          K = I("red_cheddar_cheese", "136,33,33,\r\n161,39,39,\r\n186,45,45,\r\n207,55,55,\r\n213,80,80,\r\n", 186, 45, 45, o.SAND, "Red Cheese", 4, r.DEFAULT_SIZE),
          b = I("white_cheddar_cheese", "227,204,164,\r\n234,217,187,\r\n241,230,210,\r\n248,243,233,\r\n255,255,255,\r\n", 241, 230, 210, o.SAND, "White Cheese", 4, r.DEFAULT_SIZE),
          z = I("glob_cheddar_cheese", "218,116,3,\r\n248,132,3,\r\n252,147,30,\r\n252,161,60,\r\n252,176,90,\r\n218,142,3,\r\n248,162,3,\r\n252,174,30,\r\n252,185,60,\r\n252,196,90,\r\n218,85,3,\r\n248,97,3,\r\n252,115,30,\r\n252,134,60,\r\n252,153,90,\r\n136,33,33,\r\n161,39,39,\r\n186,45,45,\r\n207,55,55,\r\n213,80,80,\r\n227,204,164,\r\n234,217,187,\r\n241,230,210,\r\n248,243,233,\r\n255,255,255,\r\n48,80,115\r\n54,90,129\r\n61,101,144\r\n80,116,155\r\n99,131,166\r\n31,31,31\r\n37,37,37\r\n56,56,56\r\n75,75,75\r\n100,100,100\r\n", 100, 100, 100, o.GRAVEL, "Conglomerate Cheese", 4, r.DEFAULT_SIZE),
          v = I("blue_cheddar_cheese", "48,80,115\r\n54,90,129\r\n61,101,144\r\n80,116,155\r\n99,131,166\r\n", 61, 101, 144, o.GRAVEL, "Blue Cheese", 4, r.DEFAULT_SIZE),
          k = I("black_cheddar_cheese", "31,31,31\r\n37,37,37\r\n56,56,56\r\n75,75,75\r\n100,100,100\r\n", 56, 56, 56, o.SOIL, "Black Cheese", 4, r.DEFAULT_SIZE),
          V = t.roundBrushTool(g.colorRandomize(4, g.colorTexture(n, o.WALL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "cheese_brick",
              displayName: "Cheese Bricks",
              badgeStyle: {
                  backgroundColor: "#fe9320"
              }
          })),
          x = t.roundBrushToolForSolidBody(g.colorRandomize(4, g.colorTexture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIBAMAAAA2IaO4AAAAAXNSR0IArs4c6QAAAA9QTFRFiCEhoScnui0tzzc31VBQxHQ8qQAAAB9JREFUCNdjcHExNmZwVlJSZDDCQggpKQowCAoKMgAAa9YEi/qIH8kAAAAASUVORK5CYII=", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "red_cheese_tile",
              displayName: "Red Cheese tiles",
              badgeStyle: {
                  backgroundColor: "rgb(186,45,45)"
              }
          })),
          Z = t.roundBrushToolForSolidBody(g.colorRandomize(4, g.colorTexture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAEZJREFUKFNj/DMz6j8DMnj7CIXLCFYAEkSTAKn68+4pA+OfNhuIAiyAXgp+JDL/ZxGSRnEByG4QePSFgYERpACbA0GSIAAA5Mg27//5KyQAAAAASUVORK5CYIIA", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "sharp_cheese_tile",
              displayName: "Sharp Cheese tiles",
              badgeStyle: {
                  backgroundColor: "rgb(252,115,30)"
              }
          })),
          j = t.roundBrushToolForSolidBody(g.colorRandomize(4, g.colorTexture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAEhJREFUKFNj/LMh6j8DMvj4CIXLCFYAEvyEKgFS9efjUwbGPwtt/mOTpKeCHy3M/1n4pVFcDnIcCDz6wMDACFKAIgvlgCRBAAB5mzf3LEQZaQAAAABJRU5ErkJgggAA", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "cheddar_cheese_tile",
              displayName: "Cheddar Cheese tiles",
              badgeStyle: {
                  backgroundColor: "rgb(252,147,30)"
              }
          })),
          X = t.roundBrushToolForSolidBody(g.colorRandomize(4, g.colorTexture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAEZJREFUKFNj/HMk6j8DMvj6CIXLCFYAEkSTAKn68+UpA+OfnTYQBVgAvRT8WMT8n4VHGsUFILtB4NEbBgZGkAJsDgRJggAA+bc42SAn284AAAAASUVORK5CYIIA", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "light_cheese_tile",
              displayName: "Light Cheese tiles",
              badgeStyle: {
                  backgroundColor: "rgb(252,174,30)"
              }
          })),
          W = t.roundBrushToolForSolidBody(g.colorRandomize(4, g.colorTexture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAEVJREFUKFNj/P///38GJPDzyytkLgMjSAFI8OfnlygSIA5IjPHH55f/sUnSU8Grm7v/s/OKozgQ5iawI0EKMJwP9QFIHAAcC0jxdsT6/QAAAABJRU5ErkJgggAA", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "white_cheese_tile",
              displayName: "White Cheese tiles",
              badgeStyle: {
                  backgroundColor: "rgb(241,230,210)"
              }
          })),
          q = t.roundBrushToolForSolidBody(g.colorRandomize(4, g.colorTexture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAjJJREFUWEftV0ErRFEYPZcXGyKZJDUbakqJGiVlYWUjYTVlQs0vwD9QtjaWSppfQNkoOxYkJWSYhdJkTINhhjHGNHX1vXlT7p3ri95iLObu7jvdd867853zfSMup6Ykvq1CIvF9i75Qt7JHKqbue73qPqPheQ3XzgsSQKSPuZz6IgCJQgHBJT9sUp0YQPE5DmsyABDpq0ZMeCYOyxNgz4vToSFpIic1toB5j5GccFvA6LCR3MZJQN0we74moPo3EPb5ZGdDg1KA9NuXa2BhNAarrUvB6benFcsC3n7AatHwjIOnAW8K7HlBAirK3ylAek4CTIvIaZEAI5528NQPuHNeFLdnVAGaj6Nb7cob9JwYODpS8M/sg7K3zhZVBe/qB5UEMD6+OZkAlxNz19cg0s+3ZMWn0rO2x02ASDVi26bZOEQxPCJNIVL28dXOoDGkyjUSONk3khNuC7hdNpLXBPyfG8iv1EvOx4c7PeByIrS7jsbmDtUJTkFSDXgi87CatJzIOjnxBAgSwPmYBHA5QQJMq+wKEmB8/1PpqZBSKgL+6mPc8v0+eszniC3AjY+tD77f37zwOSLyb0lpCpHf+ti64/v9VYTPkZqA6t/AQ3RPuvGx94Lv94fnfI4IEuDGxyTA6HOn35MALkdczwN9q9r/Bq3t1o8dsPOC63kguOFn+33jbJGdF1zPA8E1D9vvMX3Pzgs1AdW/AbfzwMJyjO33reO77Lzgeh4gAVy/JwFcznwBuPwxYCUPD+AAAAAASUVORK5CYIIA", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "cheese_tile",
              displayName: "Conglomerate Cheese tiles",
              badgeStyle: {
                  backgroundColor: "#fe9320"
              }
          })),
          _ = t.roundBrushToolForSolidBody(g.colorRandomize(4, g.colorTexture("data:image/png;base64,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", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "cheese_mega",
              displayName: "Conglomerate Cheese",
              badgeStyle: {
                  backgroundColor: "#fe9320"
              }
          })),
          $ = t.roundBrushToolForSolidBody(g.colorRandomize(4, g.colorTexture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAEtJREFUGJVjTG5e9p8BCbz9+BWZy8ACE0SXYGBgYPj59SMDEy5JGGDCKUM9Bc+ePcPquJ9fPzL8+vYJ4oufXz9iKPr17RMDAwMDAwA25CSwnErOGgAAAABJRU5ErkJggg==", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "cheese_tile_blue",
              displayName: "Blue Cheese Tiles",
              badgeStyle: {
                  backgroundColor: "#3d6590"
              }
          })),
          AA = t.roundBrushToolForSolidBody(g.colorRandomize(4, g.colorTexture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAEpJREFUGJWtj7kNwDAMA89GNtAM2ky7q+ICapwiMGA4cZfr+BRki4jBQmaukmuaktiRRD+Fk35Mfis0dx9m9hoHUFXPi6+RVQXADaMDH8MVntqkAAAAAElFTkSuQmCC", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "cheese_tile_black",
              displayName: "Black Cheese Tiles",
              badgeStyle: {
                  backgroundColor: "#383838"
              }
          })),
          eA = t.roundBrushToolForSolidBody(g.colorRandomize(2, g.colorTexture("data:image/png;base64,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", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "red_cheese",
              displayName: "Pesto Waxed Cheese",
              badgeStyle: {
                  backgroundColor: "#b92e2d"
              }
          })),
          aA = t.roundBrushToolForSolidBody(g.colorRandomize(2, g.colorTexture("data:image/png;base64,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", o.METAL)), r.DEFAULT_SIZE, r.METAL.getInfo().derive({
              codeName: "cheddar_cheese_block",
              displayName: "Cheddar Cheese",
              badgeStyle: {
                  backgroundColor: "#fc921f"
              }
          })),
          gA = t.roundBrushToolForSolidBody(g.colorRandomize(5, g.colorTexture(h, o.TREE_WOOD)), r.DEFAULT_SIZE, r.ROCK.getInfo().derive({
              codeName: "pasta_noodle",
              displayName: "Pasta Noodles",
              badgeStyle: {
                  backgroundColor: "#e1cf9d"
              }
          })),
          gF = t.roundBrushTool(g.colorRandomize(5, g.colorTexture(tU, o.WALL)), r.DEFAULT_SIZE, r.WALL.getInfo().derive({
              codeName: "bricks",
              displayName: "Brick",
              badgeStyle: {
                  backgroundColor: "#af675e"
              }
          })),
          yI = t.roundBrushTool(g.colorRandomize(5, g.colorTexture("data:image/png;base64,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", o.COAL)), r.DEFAULT_SIZE, r.WALL.getInfo().derive({
              codeName: "rubbish",
              displayName: "Rubbish",
              badgeStyle: {
                  backgroundColor: "#171c37"
              }
          })),
          oA = t.templateSelectionTool([{
              info: {
                  displayName: "Cheese House",
                  category: "template",
                  icon: {
                      imageData: Q
                  }
              },
              action: {
                  type: "random-template",
                  actions: [{
                      type: "image-template",
                      imageData: Q,
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABABAMAAABYR2ztAAAAAXNSR0IArs4c6QAAABJQTFRFAAAA2lUD+GED/HMe/IY8/JladaBKOAAAAAF0Uk5TAEDm2GYAAADuSURBVEjH7ZRBbsIwEEURSg4QuABMTtA8dw/y775SlPtfpQsHGjyxo7Kj4q9G8tOz/WV5t3vnnZfP98Z6O20A02dd0Y6oLoBwqaw3EaqKL6gqmghVhQiSyop2JHQfh7JiYgYKinaEAEPxFOJmWFc08RdYVQhgMLNCF3MHt3hFRNJclBSdooHrseuBeZA/QQZc8h2IkIA0eODR8AxgZglIgweyLAADVYH9lmGfepAUg6RUafCG67HrAwzpFjnQ5wAeiJAA1+TSMNwNp78DZpa2SE16AO6vGhxgOWALwMzsbA/AYN0COB9sJad/9PH+AGhGZn8eRqE8AAAAAElFTkSuQmCC",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABABAMAAABYR2ztAAAAAXNSR0IArs4c6QAAABJQTFRFAAAA48yk6tm78ebS+PPp////wyl2ugAAAAF0Uk5TAEDm2GYAAADuSURBVEjH7ZRBbsIwEEURSg4QuABMTtA8dw/y775SlPtfpQsHGjyxo7Kj4q9G8tOz/WV5t3vnnZfP98Z6O20A02dd0Y6oLoBwqaw3EaqKL6gqmghVhQiSyop2JHQfh7JiYgYKinaEAEPxFOJmWFc08RdYVQhgMLNCF3MHt3hFRNJclBSdooHrseuBeZA/QQZc8h2IkIA0eODR8AxgZglIgweyLAADVYH9lmGfepAUg6RUafCG67HrAwzpFjnQ5wAeiJAA1+TSMNwNp78DZpa2SE16AO6vGhxgOWALwMzsbA/AYN0COB9sJad/9PH+AGhGZn8eRqE8AAAAAElFTkSuQmCC",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAnZJREFUeF7tmLFOAzEMhq9Lh6orQ8XYoQMTLH2NvgHPxht05RG6wMTQoSNCKmvVoQvIkSJFwbk4F8eJiE9COrgjyf/Fv+3LbOj8mnWuf1AAGgGdE1ALdB4AmgTVAmqBzgmoBToPAK0CagG1QOcE1AKdB4BWAbVAKxb42O1+HvZ78Q0RnxADDuLt36UhVAdgxX+eTsP9em04SEKoCsAVbyPgbrEwt4+Hg8jaRCYZC3vYef+ShFAFwPt2azz/fb0Gc7AUBHEAIH6+Wg3YzteIBFEAlJ2XhiAGABNvwxzzgWuPknYQAYBlexANwl7PZ6P/abkc3i4Xc7+az82Pe5WCUBxASHwqAPs+d4ksCmBMvBWEVYKv2+1PBJTqE4oBoCS8FAuUskMRABTxUyxQAgI7AKp4EAOhHrr8JIi9x5EYWQGkiA8qT3yQC4ENAIjHanesxsf0UnqFHAgsAHzxuf72vU7pFaZCyAYQCvupGR5rhVMApPYJLACwWg4AUmt8KNGljAPzppwlFAVA2TlKDkgZRwG0EgG5Nd5GRuo4zURALLRLPWcH8LLZmOOr0OcpPBs72iolNDQuOwCYCCA8H49owsR6AGnRft/AXgViALAoSOngxrpFyjg5n8qkMhgDEOoDYuWL0iukNFRTusFsAAAH+3KjLJwbgG3BRS0wBiDWwVEBxMapmgM4IsA/AnN/p0SSCwD+N5SwsVzThAX+JQBKB0exAGWcJiOA0gtQAFDGqQ4A6xQpC+cE4EYKaw6wrfCYINfDlMNMt3FJyfD+GlzR9h7mZwfgDk7Z2drvsAKoLab0/KQyWHoRNcdXADXptzC3RkALu1BzDb8NfRhfdeMvcAAAAABJRU5ErkJgggAA",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABABAMAAABYR2ztAAAAAXNSR0IArs4c6QAAABJQTFRFAAAA2o4D+KID/K4e/Lk8/MRaF9dwWAAAAAF0Uk5TAEDm2GYAAADuSURBVEjH7ZRBbsIwEEURSg4QuABMTtA8dw/y775SlPtfpQsHGjyxo7Kj4q9G8tOz/WV5t3vnnZfP98Z6O20A02dd0Y6oLoBwqaw3EaqKL6gqmghVhQiSyop2JHQfh7JiYgYKinaEAEPxFOJmWFc08RdYVQhgMLNCF3MHt3hFRNJclBSdooHrseuBeZA/QQZc8h2IkIA0eODR8AxgZglIgweyLAADVYH9lmGfepAUg6RUafCG67HrAwzpFjnQ5wAeiJAA1+TSMNwNp78DZpa2SE16AO6vGhxgOWALwMzsbA/AYN0COB9sJad/9PH+AGhGZn8eRqE8AAAAAElFTkSuQmCC",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAAAXNSR0IArs4c6QAAABJQTFRFAAAAMFBzNlqBPWWQUHSbY4Omw9F4yAAAAAZ0Uk5TAP//////enng/gAAAOxJREFUWIXtlMEOxCAIRCvg///y2tWiqKsoSffinBoirwNje11HR0dHR2/KW/u9jeA9mgihH5HI1m8gECFaCOQRLQR+/ybh209RO4S4P3IOnYMND8/+M2CNkPoxrgGW95DzKxwsEPL+JUBLKPKDqLU0Rf61FAQZf25MlSmBOqOLyoRACsCQQG38TUUDGDh4B1DHLysKwFhdAKRPdhtwgdEBAyg5ee5d/fDzJgkHvHOOf/5rSgCYA8YjpCPc1zwoAdkBtA7gBQDfO3Ze3kQFIEdejM4aA2AGCD66/Y+cQNSA+4DrA0Jdre4IR//TByNLC+k8mI+XAAAAAElFTkSuQmCC",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAAAXNSR0IArs4c6QAAABJQTFRFAAAAHx8fJSUlODg4S0tLZGRk18kcDgAAAAZ0Uk5TAP//////enng/gAAAOxJREFUWIXtlMEOxCAIRCvg///y2tWiqKsoSffinBoirwNje11HR0dHR2/KW/u9jeA9mgihH5HI1m8gECFaCOQRLQR+/ybh209RO4S4P3IOnYMND8/+M2CNkPoxrgGW95DzKxwsEPL+JUBLKPKDqLU0Rf61FAQZf25MlSmBOqOLyoRACsCQQG38TUUDGDh4B1DHLysKwFhdAKRPdhtwgdEBAyg5ee5d/fDzJgkHvHOOf/5rSgCYA8YjpCPc1zwoAdkBtA7gBQDfO3Ze3kQFIEdejM4aA2AGCD66/Y+cQNSA+4DrA0Jdre4IR//TByNLC+k8mI+XAAAAAElFTkSuQmCC",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }]
              }
          }, {
              info: {
                  displayName: "Small Cheese House",
                  category: "template",
                  icon: {
                      imageData: m
                  }
              },
              action: {
                  type: "image-template",
                  imageData: m,
                  brush: "metal",
                  threshold: 50,
                  randomFlipHorizontally: !0
              }
          }, {
              info: {
                  displayName: "bob",
                  category: "template",
                  icon: {
                      imageData: s
                  }
              },
              action: {
                  type: "image-template",
                  imageData: s,
                  brush: "metal",
                  threshold: 50,
                  randomFlipHorizontally: !0
              }
          },
          {
              info: {
                  displayName: "Cheese Blocks",
                  category: "template",
                  icon: {
                      imageData: c
                  }
              },
              action: {
                  type: "random-template",
                  actions: [{
                      type: "image-template",
                      imageData: c,
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJxJREFUSEtjZGBgYPjx+eV/EA0C7DxiYPrnl1cwIZrRHLzijIwgy2GWwmxCt/zn55dUcwQ7rzjcoyB7wA5AN52aFuJyOcwhYAfQw0JsDgE5YtQBAxoCoKgfdQDjq5u7/8OyBNUyO5EGgaNg1AGDIgTAlRC0jCYy+ihWBit9GR+fWQKuC9AdQG0HoRf3cAeALAdFA8VeIsMAMXVXRgDHQnlqOy8RyAAAAABJRU5ErkJgggAA",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJxJREFUSEtjZGBgYPjTZvMfRIOBsByEfvsILkQrBkvVEUZGsOUwS2E2oVtOTcfA7ALRbx8xQByADqhpIa7ggzoE4gB6WIjNIcJy0BAYdcAAhcCfd08HNgoGhwN+JDL/ZxGSplVZg9dccAiMOmBQhAAoouidDkDxDwKMt0KZwXWBHA9qeqG2g2AWwmx59AXCYgQRoGgYiGzAMf8vIwB5ZV3LwFFRawAAAABJRU5ErkJgggAA",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJxJREFUSEtjZGBgYPiz0+Y/iAYDbjkI/fURXIhWDBb3I4yMYMthlsJsQrecmo6B2QWivz5igDgAHVDTQlzBB3UIxAH0sBCbQ7jloCEw6oABCoE/X54ObBQMDgf8WMT8n4VHmlZlDV5zwSEw6oBBEQKgiKJ3OgDFPwgw3upjBtcFciKo6YXaDoJZCLPl0RsIixFEgKJhILIBR9xfRgALuGEL1RXxHQAAAABJRU5ErkJgggAA",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJ9JREFUSEtjZGBgYPiz0OY/iAYDfjkI/fERXIhWDJb4I4yMYMthlsJsQrf8ExUdwwf1IMjOj48YIA5AB9S0EFfwQR0CcQA9LMTmED45aAiMOmCAQuDPx6cDGwWDwwE/Wpj/s/BL06qswWsuOARGHTAoQgAUUfROB6D4BwHGWyXM4LpATgA1vVDbQTALYbY8+gBhMYIIUDQMRDbgqPnLCAC7Z1+Jrp0+OQAAAABJRU5ErkJgggAA",
                      brush: "metal",
                      threshold: 0,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJZJREFUSIntkCEOAjEQAKeXSxAVFf0L7ziN5wfnCf5+cB7NO3jIuoqSlARMMawpJ2lPHKN3dyZrAIZxznzwzgIQYqI21+lozDDOWaVKKf9ljLq8s4SY6GsLS8rbiwEtCDHhnaVrbi7YdoCIbPwDAJ2IrBuwqv0foAHPFJuL1dm/HvfFgZ11VYSKeg3A/nDO3yv1uV1O5g22uji0OmbEIgAAAABJRU5ErkJggg==",
                      brush: "metal",
                      threshold: 0,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAIlJREFUSIntlbENAyEMAI8XG1AxANN4XpYxA7hiAZpPkbgIkVI9ofhciQR3uIAAICInL3LOAJgZq6m1hiAip0udWd57v0yaUgKeFzUz4mrhzHx2XC38FpJS4vi5eeLeAap68wkAHKq6N2Cr/R/gAbteQoA4xnhbcPzTuFrouDcAlFLOzy3raa2FBx9rOlv6JJwXAAAAAElFTkSuQmCC",
                      brush: "metal",
                      threshold: 0,
                      randomFlipHorizontally: !0
                  }]
              }
          }, {
              info: {
                  displayName: "Cheese Rock Small",
                  category: "template",
                  icon: {
                      imageData: C
                  }
              },
              action: {
                  type: "random-template",
                  actions: [{
                      type: "image-template",
                      imageData: C,
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARBAMAAAAvapGNAAAAAXNSR0IArs4c6QAAAA9QTFRFAAAA+KID/K4e/Lk8/MRa6sExRAAAAAF0Uk5TAEDm2GYAAABiSURBVAjXPc7BDcQgEATBRk7ASwZuErB2yYDLPyY/ODGv0rwaAFYaAFDpEzdc602NuLlqrvSJCLpV6qaah6M0OqE6KpUWrTtmOgDC+lW+AK3P+pNeqZtNdTewE/Z9RDva+wA5rQ5B1Y9TLAAAAABJRU5ErkJggg==",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAXNSR0IArs4c6QAAAQBJREFUOE+dlC0SgzAQhYlB4Cs4AQpRxQ2quUHP1mv0BigEU8EJEPUIDJ2XmZdZwmabNoKfbPJlf97GFZnj1ff7tix+9Xtdw65l2/z3fZ4d3v5hjbHrdtolCHOE0Q7oAYjNZV0X9OQ6DA5zMUiD0UsPlF7gH1AMLcQUjF66R9PsdVmGqC9VdciA5p0FPQFT+cRBWjHi9VlA6bVVGETqgThFhm15KW1aOnxRCGWlUofQUyohBsKe1GEMlTCpAAoddsjMFLaEYoPUaBx6FpDpQH6twmBdNlBCrRa9TVNeLxPybNvQ01oPh04xb4bIKNVARZyE/Q+QV5W29+v19cuBWPsBruuKPtoFNSQAAAAASUVORK5CYIIA",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARBAMAAAAvapGNAAAAAXNSR0IArs4c6QAAAA9QTFRFAAAA+IQD/JMe/KE8/LBageNSzQAAAAF0Uk5TAEDm2GYAAABiSURBVAjXPc7BDcQgEATBRk7ASwZuErB2yYDLPyY/ODGv0rwaAFYaAFDpEzdc602NuLlqrvSJCLpV6qaah6M0OqE6KpUWrTtmOgDC+lW+AK3P+pNeqZtNdTewE/Z9RDva+wA5rQ5B1Y9TLAAAAABJRU5ErkJggg==",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAXNSR0IArs4c6QAAAPpJREFUOE+llD0OAiEQhSFSWLulCSfxJHaewc4D2O0BrLyMJ9nEUmsLzJoZ83BgYRaVYklm2I83f1jTuMJpO5rb8D6N3RgT7lc2Lc9PSzt/tBWOmzH6BYhsgMFP0ATIP3c+KnCHi2VbBirBoJKBiQoyEFSGNqNMRmgfu8XoVuuPDTBYCupqCjmHE2AtoSIV/wOlaiV8ipQV0o1J2JpK6Sukg4sCKCpVvQRKEX4O7Hy9DydQCcuam9uq84baTG3sBErArDBJw7cAkQ7Or1IYBrcCE6gyo64f2mYZjLD3caZLM4xzs4+DFCW7AR2Ri/4JiKeqlIGvgEoKo+sFvxt6+JkTueEAAAAASUVORK5CYIIA",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAXNSR0IArs4c6QAAAL1JREFUOE9jZCAAfrQw/wcpYZG1hKjkl4PQHx8xsMQfYUTXjiEAUvBnshzYEGLAn49PGThq/sLNgTNQDOGDugLdxE+PMOzAaiDcMFwGgbz58REDAxYDwT5CciXYhX8W2mD3IswgZHcRMBS7gUgBj+JHHIbBXAmiEWEIciUZBsEsBHkb1cANUf/B4QQFfx4fZ2Dhl8YaCSBB5JhFVoSSbGBhCTIMGeDSjC1ZYU2HxKQ/XGpGDaQk9CB6R2AYAgDHYFIO5nc3sAAAAABJRU5ErkJgggAA",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARBAMAAAAvapGNAAAAAXNSR0IArs4c6QAAAA9QTFRFAAAAoScnui0tzzc31VBQe/kLSwAAAAF0Uk5TAEDm2GYAAABHSURBVAgdtcEBFYAgEETB/6AAZwOXAnp7DbB/JiWEM2zh52Jr2gagaac0oE27Ujqh22VLGnTXckoKqOXUJ2D5kIKt3zH40ws1qgmlpQS1LAAAAABJRU5ErkJggg==",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAXNSR0IArs4c6QAAALhJREFUOE9jZCAAfixi/g9SwiJuCVHJLQehvz5iYHE/woiuHUMApODPOjmwIcSAP1+eMnDE/YWbA2egGAJzBbqJXx9h2IHVQLhhuAwCiYMMw2Ig2EdIrgS78M9OG+xehBmE7C4ChmI3ECngUfyIwzCYK0E0IgxBriTDIJiFIG+jGngk6j9yGP15eZyBhUcaaySABJFjFlkRSrKBhSXIMGSASzO2ZIU1HRKT/nCpGTWQktCD6B2BYQgAwJlSSt1+i24AAAAASUVORK5CYIIA",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAXNSR0IArs4c6QAAALhJREFUOE9jZCAAXt3c/R+khE9KD6ySnUcMTP/88oqBg1ecEV07hgBIwcdnl8CGEAN+fn7JIKbuCjcHzkA2hJ1XHKtZIM3oAKuBMMNwGQTyJsiL2AwEex/JlWAX/vj8EqsXYQYhu4qQoVgNRA54YgyDuRJEw8MQ5EpyDIJZCHM53MD/////B4UTDHx6dokBW5jCNCLHLLIvUJINLCxBhiEDXJqxJQWs6ZCY9IdLzaiBlIQeRO8IDEMAm+VfDC2bdYEAAAAASUVORK5CYIIA",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAXNSR0IArs4c6QAAALhJREFUOE9jZCAAfiQy/wcpYVG1hKgUloPQbx8xsFQdYUTXjiEAUvCnWA5sCDHgz7unDBzz/8LNgTNQDIG5At3Et48w7MBqINwwXAaBxEGGYTEQ7CMkV4Jd+KfNBrsXYQYhu4uAodgNRAp4FD/iMAzmShCNCEOQK8kwCGYhyNuoBs6M+o8cRn9uH2dgEZLGGgkgQeSYRVaEkmxgYQkyDBng0owtWWFNh8SkP1xqRg2kJPQgekdgGAIApPBRyKcZ+gwAAAAASUVORK5CYIIA",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAXNSR0IArs4c6QAAAN5JREFUOE+llM0NwjAMhV2RA7cOgGAPJFZiA44swmqRGKA5cSgCua0jN3lOoja3VPbX55+XjipnfN1+U0h/mSMHTxQ8ubvvUCr8KIGf52GCufN1BjKMT/A0Dm86Pr5ZfhuwP2ViNgMdgDGdgXxSlabC2LuwlJlo3A5ceoYGgKBlhTKIikpd+i4g6iUErnZPrYq1srr0OlAt8z6gOEOAjcPJFLI7ojM0TOSBARVLjkCrvgKQU6DC6F8NbVwdOJT4KBi2k/9IqXJnG5p7KFAJ1p5GIIkrvjYclIJ1F9Dz9QdVVJeQBIjf4QAAAABJRU5ErkJgggAA",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAXNSR0IArs4c6QAAANVJREFUOE+llDsOgzAQRE3jmtYnoEvLDXKNnC0nSkHFCVykp3CTaCyNtMLjj2A7o93H7HdyHfus6w8uPoTsmWJ03+Nwz22bVKj8SMf3smTYY54zEDAYgDEl99r3In4IGLwvxFwGKhjoAMLOKqsKWTukp+wykDUbhTYVshE9lTb1W0BVSwm0s2dHpTaytp5doB3mW0BuBoGjzSkUYju4GRZGdapBzZQJrKXXAiJGKuT+Wujo6Mim8CjU1o4/Yqp8Yw2rc0gonS1cgejXvDZwOoNtGdT5+gOPt6sAeSEJxgAAAABJRU5ErkJgggAA",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARBAMAAAAvapGNAAAAAXNSR0IArs4c6QAAAA9QTFRFAAAA+KID/K4e/Lk8/MRa6sExRAAAAAF0Uk5TAEDm2GYAAABVSURBVAgdBcGxAcJADAQw+T4DmDnoYP9ZoKPMl6HBSAue9/4Q1Hs0B8wLAk0RPIBA0y0oKAEUB0uhJ9AgaA2h7YLgBBV+nOxZfC/MJcycZs8uuDHbH/PQGYSXMIzpAAAAAElFTkSuQmCC",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAXNSR0IArs4c6QAAANNJREFUOE+llDsOgzAQRE1Fk09HJC6Qjlvk1DlJjmBapwhVorU00sjM2hAsIaTF+5j9dqFxPil+7Up/GvLN5T2HJcVwHadOuUojLs6vZ4ZdxikDDZahKeZnuD9W/puA/fm2EvM3UMGg0t6lSlchcmdK1IF9N5DVlGAFrSpEIVoqOfRDQJVLCeTe41bxWpZDbwK5mQ8BMRkAbi3OSqFNByaDYVCnClQNGcBWePydfyIVYn49J89uTS6LgqXgjZ0Xvgs0B0DhzPAyjzx+1W2jwByuWl8/WN6sj51ekX0AAAAASUVORK5CYIIA",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARBAMAAAAvapGNAAAAAXNSR0IArs4c6QAAAA9QTFRFAAAA+GED/HMe/IY8/JlaY/YUtgAAAAF0Uk5TAEDm2GYAAABVSURBVAgdBcGxAcJADAQw+T4DmDnoYP9ZoKPMl6HBSAue9/4Q1Hs0B8wLAk0RPIBA0y0oKAEUB0uhJ9AgaA2h7YLgBBV+nOxZfC/MJcycZs8uuDHbH/PQGYSXMIzpAAAAAElFTkSuQmCC",
                      brush: "rock",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }]
              }
          }, {
              info: {
                  displayName: "Cheese Tree",
                  category: "template",
                  icon: {
                      imageData: B
                  }
              },
              action: {
                  type: "random-template",
                  actions: [{
                      type: "image-template",
                      imageData: B,
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,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",
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,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",
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,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",
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }]
              }
          }, {
              info: {
                  displayName: "Cheese Pallet",
                  category: "template",
                  icon: {
                      imageData: d
                  }
              },
              action: {
                  type: "random-template",
                  actions: [{
                      type: "image-template",
                      imageData: d,
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAECAYAAABsgwTvAAAAAXNSR0IArs4c6QAAADNJREFUKFNj/DNZ7j8DFLDkPmKkhM94q4QZbhjMUHJpxh8tEMM4av4yYjMEJk+MGqoaBgCoYyn9//f7iAAAAABJRU5ErkJgggAA",
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAECAYAAABsgwTvAAAAAXNSR0IArs4c6QAAADNJREFUKFNj/FMs958BClh6HzFSwme8FcoMNwxmKLk0449EiGEc8/8yYjMEJk+MGqoaBgBWfyl4KA3t3AAAAABJRU5ErkJgggAA",
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAECAYAAABsgwTvAAAAAXNSR0IArs4c6QAAADRJREFUKFNj3KWr+58BCtwuX2akhM/YoagINwxmKLk040J1dbBh8TdvMmIzBCZPjBqqGgYANtgnconsteswwAAAAASUVORK5CYIIA",
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAECAYAAABsgwTvAAAAAXNSR0IArs4c6QAAADRJREFUKFNj/Pjs0n8GKOCX0mOkhM/46uZuuGEwQ8mlGR+fWQI2TNYkhhGbITB5YtRQ1TAAPPItzpIfl4cAAAAASUVORK5CYIIA",
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAECAYAAABsgwTvAAAAAXNSR0IArs4c6QAAADxJREFUGJVjtE2d8J8BCg7PLmCkhM9oFtUI51AKWH59+8TAwMDAcGFDLyM2BQYBxXDLCKlhoparGBgYGABz5x8sWd2Q1gAAAABJRU5ErkJggg==",
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAECAYAAABsgwTvAAAAAXNSR0IArs4c6QAAAD1JREFUGJVjtLCw+M8ABSdOnGCkhM+oqqoK51AKWH79+sXAwMDA8PDhQ0ZsCuTl5eGWEVLDRC1XMTAwMAAAanAeDGekaN0AAAAASUVORK5CYII=",
                      brush: "wood",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }]
              }
          }, {
              info: {
                  displayName: "Cheeseungus",
                  category: "template",
                  icon: {
                      imageData: R
                  }
              },
              action: {
                  type: "random-template",
                  actions: [{
                      type: "image-template",
                      imageData: R,
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAlNJREFUeF7tmUFOAzEMRVPRBRLcAImTsOcWHI5bsOckSNwAJBZFoBmNq9SM4yS206E2OzRtkv/y7fxMd8n53865/hQAwgHOCUQJODdANMEogSgB5wSiBKQGOLw8/EjHWPv+/vF1yOZ0T2IlHMOwBtEM4I/wzzcLA6R0c38yrhWIfgBWwjHOBcQmABx3f5R4gGEIockBrgGcTbyxC6odEADgvB9d/+GAhYBRIyRLgAw6HhxQTHmXDuBEfC4WkpkbAFioBwDFo04LAMr4vRcJrWh80gTNASiJB2gaEI4A2KAjdUAuXtpHsrGkEMYA0BSPgtH0rwSCPQAL8YoQxgGQ2p7qlsKE+O8BHD7eZzTXT9/VF7ucZQAAGlanAOzQ/vau98gvfm/zDoAFzt1aGUI+9nZLIKVkAUFD/LQp9j1gMbAmBC3xQwFMk+UL12gIvbYfewogpVoQNMQPd4Bk16Xdnpp7WA+QiM/LR2vnYT3VAKzPcw7Q2R1w8QC+nq/m3/mpsBIAlkuHdprjrH+M6sJLD9sEwwHeS2CySMkFvT2ACj6tpWR+CgSApUtQLpA6AAIM12uoZjXEAbkL8JHoBgCGgHdEWrubdwAIhoW6BYCFa+2c1ji1AYr7XPWrZK2Fa43DCat9HgBqSWntnNY4tevmPtfsgNKNEU+29vIyb661J4rmS1C8xmoAXFJcI02Fl1YXWIWgac1dAGpcUNq1FhdY7n4zgLWQhG2MLz/UOzycM3rH4Wqce97kAC4k4cm4F5hU2GodhxNZet4FgAPBCadC1kjhMNcvRnMiX7KYzgIAAAAASUVORK5CYIIA",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAj5JREFUeF7tmT1SAzEMhTcVNGnJETgJp+YkHCG0aUgFY2bFeDWWZVuSd4lElyEr+31++lnntDj/OznXvwSAcIBzApECzg0QRTBSIFLAOYFIAakBvm7Xb2mM0vPP58uUwxlexEo4hmENohsAFn6/XS0MsDydL5u4ViCGAVgJxzQBxCEAwOnPEg8wLCF0OcA1gL3EW7ug2QEBYO33s/M/HLASsCqEZApQg44LB9SmvIcHkIvPxYIF3QDAQl0AqLU6LQB4xh99kdAajTdF0BqAlniApgHhDwA36EgdkIuX1pE8lhTCFACa4vFglD5LIJgDsBCvCWEaAKntqWIpnRD/PQAA+/L61vxil8MMAEDDqgvACWm3QNj34R1QGqdHhx/8XB77sCmQNm0BQUN82pt5DcBWTZ+l6aAlfioA7ASNNBi1/dQuUMtbCQQN8dMdIBEsrfbU2tNqgER8nj5aJw/7aQZg3c85QLs74OEBfH68//7OT7WoALD+DC7t4ZzVqf+bp0A4wHsKJOvVXDBaA6iLkN5UMk+BALBWH8oFUgfAAMPVmt2KICwMG8Qt0Q2APBVKpyHN3cM7oOSEHIQbAPj0tU5OK87oQIWfa75K1tq4VpwAoEQgHNAKkmqPtedLl5dacVr3zX2v2QHcpFhaiBpfe+uA1Ri8uRPkSOH5gGuHtavrHhdoXoGXNHY5oDQkYRD45Ye6w8shlC5iWuO0HFztO90AuEkxX4y7wMQQqI1ycSQQhgBw02LvhikQvXFGQPwAP4lYXwD8hQsAAAAASUVORK5CYIIA",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAlNJREFUeF7tmUFOAzEMRVPRBWtYInESLsM1OADX4DKcBIklrFkUgWY0rlIzjpPYTofa7NC0Sf7Lt/Mz3SXnfzvn+lMACAc4JxAl4NwA0QSjBKIEnBOIEpAa4PD88CMdY+37+6fXIZvTPYmVcAzDGkQzgD/CP94sDJDS7f3JuFYg+gFYCcc4FxCbAHDc/VHiAYYhhCYHuAZwNvHGLqh2QACA8350/YcDFgJGjZAsATLoeHBAMeVdOoAT8blYSGZuAGChHgAUjzotACjj914ktKLxSRM0B6AkHqBpQDgCYIOO1AG5eGkfycaSQhgDQFM8CkbTvxII9gAsxCtCGAdAanuqWwoT4r8HcPh8n9Fcv3xXX+xylgEAaFidArBD+5u73iO/+L3NOwAWOHdrZQj52NstgZSSBQQN8dOm2PeAxcCaELTEDwUwTZYvXKMh9Np+7CmAlGpB0BA/3AGSXZd2e2ruYT1AIj4vH62dh/VUA7A+zzlAZ3fAxQP4eryaf+enwkoAWC4d2mmOs/4xqgsvPWwTDAd4L4HJIiUX9PYAKvi0lpL5KRAAli5BuUDqAAgwXK+hmtUQB+QuwEeiGwAYAt4Rae1u3gEgGBbqFgAWrrVzWuPUBijuc9WvkrUWrjUOJ6z2eQCoJaW1c1rj1K6b+1yzA0o3RjzZ2svLvLnWniiaL0HxGqsBcElxjTQVXlpdYBWCpjV3AahxQWnXWlxgufvNANZCErYxvvxQ7/Bwzugdh6tx7nmTA7iQhCfjXmBSYat1HE5k6XkXAA4EJ5wKWSOFw1y/QQIiX9R4mpcAAAAASUVORK5CYIIA",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAk9JREFUeF7tmTFyAjEMRaGhoE+RE1Cn4jg5W45DlZoTpEhPQZPMMquM0aws2ZLMBildhsXr//wlf5vtJvjfNrj+TQJIBwQnkCUQ3ADZBLMEsgSCE8gS0Brg83j80Y6x9P2302nI4nS/xEs4huENohkAFv59uXgYYPOy39+N6wWiG4CXcEwTQKwCAKz+KPEAwxNCkwNCA3iUeG8XiB2QAOb9fnT9pwNmAl6NkCwBKuiEcEAt5T09gFJ8KRYsGAYAFhoCQG2rswKAM37vQcIqGt81QW8AVuIBmgWEPwBc0NE6oBSv7SPlWFoIQwBYisfBaPpfA8EdgId4SwjDAGhtTzVLbUL89wC+rtcbm/fzWXywK2EmAKDhtQvACr3udr1bfvV7q3cATHBSYQ2hHHu1JTAJ94BgIX6am3sPAP9aQrASPxQAdoJFQ+i1/dBdAAstV08DwUL8cAdoBGu7PfXuYT1AI74sH6uVh/mIAXjv5xyghzvg6QF8HA633/mpsJIA5kOHdZrjrI9zhFsPSAdEL4HJajUX9PYAKvi0lpL7LpAA5m5DuUDrAGheXK+hmuIQB5QuwFtiGAAYAl4Rbe2u3gEgGCYaFgAWbrVyVuNIAxT3nPgq2WriVuNwwqSfJwApKauVsxpHOm/uuWYH1E6MtesvnAO043DCpJ+LAXBJcemFVHhpdYFXCJrm3AVAsnq1q+tyi+VyheUV+NIiNQFYCklYAD78UOd3nDN6x5FanXquGQCXFMsXcZcXVNjCk+XG0UDoAsClxdYJUyBax+kB8QsCUVhf3r0v0QAAAABJRU5ErkJgggAA",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAedJREFUeJztmTFuwzAMRdWiQAYPHnqXnqNz996ge9G9N+jeuefoQbx18OAhUzvJUBgplsRPUY35gAAJYNPk17dIO84ZhmEYhmEYhrFHbrgBHl8+fhGJUL7en9m55VB9EanCKdJCFAenhf/MCy6bgPtxOPktJcRd7YlShdP4VAg0Rar61ZcunuJFkHDBLTrgfyNbUa3V90i5YPcOMAG0E9Am2QZbDTraRB2wl+KdizggLD7c8aUHEi2Se4BWu2vNSU+91Ou9A7jCoJyEmgeadgHkbYTap1YVtyY9rgPC4pEu4jqhiQOQxdMYXCeIC4AuPhaLI0KzPUCiqyBiVr8Q6YVpmljn27OA9AX8Ch2GUfpSVTRzwHGZu4wpLkC48kgRwljfn6/Vs0ATB6BFQBXvXMMucBjGNXGUE7jFO9e4CyA3QkTxzinMAbUieNegCvfYHJB7YO/9vBZzgP9yrSu8xe4dYAJoJ6DNKoDvr+iHluMyRz+9YA4If0i5wMdGT3EIkg7oyaaSnAkQrlKP9yyaqAN6tKoUyWcBKsLD09tV/mVuXUA7AW1MgNITSjrCpWNRcbhkC8DpDOG5qDgoqm6BnBVpeQyHYkVpO6QvUGjCqVVDxeFSFTR3JthKGhWHAytwqoDShFFxavgDFmb96SA5hRAAAAAASUVORK5CYII=",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }, {
                      type: "image-template",
                      imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAcNJREFUeJztmeGRhCAMhePNdUANVmO9NiM1UMPeLxzldAXyQlTy/dqd0WzyeJLgEhmGYRiGYRiG0SMDN8A0TR9EIinzPLNzy6H6R6QKT5EWojh4WngIAZfNBufc7ruUEL+1N0oVnsZPhUBTpGpcfeniU6IIEi74QQd8GtmKaq1+RMoF3TvABNBOQJvTNthq0NHm0AG9FE904IBt8dsdX3og0eJ0D9Bqd63Z9dRvvT46gCsMykmoeaBpF0A+Rqh9alXxatLjOmBbPNJFXCc0cQCy+DQG1wniAqCLP4rFEaHZHiDRVRAxq1+I3IVlWVj321lA+gfiCt11kux+D3hFF/DeV88Cj58DOMUTNewCzrk1cZQTuMUTPfgsgCieSGEOqBUhugZVeMTmgNwL797PazEHxA9vXeEruneACaCdgDbrHuC9H8Zx/IQQoPvA1TtGbbp3wE6AOGVJHF299wN6ikPQ/T9D/ybBuBcQ9SHCoQPuaFUpTs8CqQjRFW/DuoB2AtqYAKU3lHSGb9ei4nDJFoDTGbb3ouKgqHoEclak5TUcihVN22F6qEkTPls1VBwuVUFzZ4KrpFFxOLACnxVQmjAqTg1/3iTxkIzt87YAAAAASUVORK5CYII=",
                      brush: "metal",
                      threshold: 1,
                      randomFlipHorizontally: !0
                  }]
              }},
              {
            info: {
              displayName: "Pallet",
              category: "template",
              icon: {
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABuSURBVDhPY/wPBBc3ljDAgL5/DwMlfLCBu7udoVzKAYoLQbZhA+guwgZgapjAJBUB44UNxf+hbJLDCxufcVeXE9xASoFr6V4GFjE1QzAHZDo2gO4CbABZDdXDEG4gzBYQDcPYALo8uroRF4YMDACFG1f+6uKPDwAAAABJRU5ErkJggg=="
              }
          },
          action: {
              type: "random-template",
              actions: [{
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABuSURBVDhPY/wPBBc3ljDAgL5/DwMlfLCBu7udoVzKAYoLQbZhA+guwgZgapjAJBUB44UNxf+hbJLDCxufcVeXE9xASoFr6V4GFjE1QzAHZDo2gO4CbABZDdXDEG4gzBYQDcPYALo8uroRF4YMDACFG1f+6uKPDwAAAABJRU5ErkJggg==",
                  brush: "wood",
                  threshold: 50,
                  randomFlipHorizontally: !0
              }, {
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAECAYAAABsgwTvAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAA2SURBVChTY7ywofg/AxTo+/cwXNxYAuWRzmfc1eUEN4xSAHcZyBZsAN0l2ABMDROYpApgYAAApXIabwnkhFAAAAAASUVORK5CYII=",
                  brush: "wood",
                  threshold: 50,
                  randomFlipHorizontally: !0
              }]
          }},
      {
            info: {
              displayName: "Garbage",
              category: "template",
              icon: {               
                imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAANCAYAAACzbK7QAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAALoSURBVDhPrZNLbxNnFIafemzPxGPH8SXBxYlzVYAQUC8UKFVUpUWwjgRsWFXqouofQIgVYsMGsWMFYpEVEhJIWSBVaoFGiFZN1KqxQpKSkBSDwXeP4xmPJ/bw2ZgUREEg8Wxmzqcz7/udy3xkC3hPVF+UculRK3o7jtbznVE7Buge3s1Q95e4nYHW6Zt5Z4PB2AgudxCPGqZQLGN6VSSXD38g2sr4fzZb9M3ED9yPzxKODfH3rRts+/wrNkyJ3lgXum5QWtdZW1nCMqpUqyVkjw/bsjg0voe27Z8iBwJcPvVjU/RlmgaR7i8wDA3JIaGXi9Qq6/SO7oWqg1Q6ic8fEqkOdC1LMNzBgbF93Pl1muzaCid3bkPu6SIlKYyTZzrr5Myt68/VBU2Drh07yC4lRLDROMLh9jK48wAeWSGRWMOuWphVnaq5juIJEQp5aQ9sIZ/Joj1cYNTpZG+bzFhQYSrYiT00wMXJS02D5gz2Hz9M6LMR6ihiiBH84a2sLPzJ6up84wZ42hXavF7Rnhx2vUY6lePeXFx87aCmBrhrlriQz3D+3xSBssbBsJNzRyeaBs0Kdn1/jAc35vArPdSqeT7Zv4+yVmHtn3meJO5h26IqyU3N0gn5fRzc7afdXadUV5n+K0nOcvJxbz/5ZAqj8JQ+1Y8a6OP3BzefG7SPjlJPW/SNHEZPL7NhFMmls0Si/ZhWhWIuQ0V7JJJNzn7Xz0BIZjEpMfVbgRobzD40xZwiGBVDtNCDXsphlJb/q6DxIns78XRup3drlLpVJpNKoKUzSG6JcDiKx+sSA95CzFcjvrjESCyIrRfwuxQm7yxjivHZdROXHMTQV5viDTYNXrDn6yMsLy4Q7enn8eoS49+OobR5xbpGuTJ5jWyuIOI6kye6icgVbv5U5PTPebJaoqXwKq/9aDO3r5J/Eif+x5Ro0yJlvSY2RkUT6xvuGxYb5qIg+nz3doa5X5LM3OeN4g1eq+DDAs8Ahn1B1kGf6gkAAAAASUVORK5CYII="

              }
          },
          action: {
              type: "random-template",
              actions: [{
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAPCAYAAAD3T6+hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAKRSURBVDhPvZPbS5NxGMc/7qDbdOacc9V0HqCTp7pQiISIRMtSAsMuisDuMiE6QF0U3hjd1U0XRZdB9AdkN51MLGWKqYXYPE7nITfnge3du7l3szd6MUJRg/Jz8/tdPM/3y/P9/Z64FRm2EZVybhubTvjoyVMcjj7aWr+SlWdHl5iITq1i4IuTmZFvBMRppXJrbGhYcqSKSDSBcxcref3qM72OFnakm4mEw/gXF5HEAPZkHU7PmNKxOetGerKmjuKjtbicowQCAmLQQ4IhQiwaZn5qjNhyECkkcKHIzL1SCxUHi5XOzVljWHvpCiaricCCF/2Kn0BQpLNtgCm3F22CAX1SEgaVHIo6Sr9fS2P7NJ0jUySn5ioKG/NHpDn7DiMKInpTGvimKctM4kW/D602SmxFQ1j0/+wgx2IjbN+PZe8Bxrs6mB9qx6jXk5mWQt+wU1Fbn9UJK85eRlqO4pudxOMaYnJulo5wMuWnThAMBYlpVKTasmm4eYOa+jpU6gSEUIQ4Q7p8N1JXfoim0+mU5hUqiuuzatjT5cDn9cpvZcSakStPZWSXbSfdnR/RavTEQjFu36qnsroUKRZCu+BCPz4IE/2oJRGrNEXvgAf3jEiKJV9RXcuqoXeih4aG87x7/5yHD65jz7LiGh5ErYmXU5TYU1jAyPgkzS8/0fq2G/f4DCqDVVYwEJEf5Vmnn8eOIJaUFUoskG/P4k5VgaL+mzVrcbexCefgBC1vPlBVfZzTZ45x7ep9+fMILPlGlapf5BaU4XGPoTPEy7EmsuR1U5htQme0IaBBF5ljWd7b7vY2pWMLi78VzLYiQkKYsP87u7Mz0RvNCIsCEUki1ZLBQE+zUvmPDP+GdRf/f7LNhvADWH4NREjRt80AAAAASUVORK5CYII=",
                  brush: o.COAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              }, {
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAANCAYAAACzbK7QAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAALoSURBVDhPrZNLbxNnFIafemzPxGPH8SXBxYlzVYAQUC8UKFVUpUWwjgRsWFXqouofQIgVYsMGsWMFYpEVEhJIWSBVaoFGiFZN1KqxQpKSkBSDwXeP4xmPJ/bw2ZgUREEg8Wxmzqcz7/udy3xkC3hPVF+UculRK3o7jtbznVE7Buge3s1Q95e4nYHW6Zt5Z4PB2AgudxCPGqZQLGN6VSSXD38g2sr4fzZb9M3ED9yPzxKODfH3rRts+/wrNkyJ3lgXum5QWtdZW1nCMqpUqyVkjw/bsjg0voe27Z8iBwJcPvVjU/RlmgaR7i8wDA3JIaGXi9Qq6/SO7oWqg1Q6ic8fEqkOdC1LMNzBgbF93Pl1muzaCid3bkPu6SIlKYyTZzrr5Myt68/VBU2Drh07yC4lRLDROMLh9jK48wAeWSGRWMOuWphVnaq5juIJEQp5aQ9sIZ/Joj1cYNTpZG+bzFhQYSrYiT00wMXJS02D5gz2Hz9M6LMR6ihiiBH84a2sLPzJ6up84wZ42hXavF7Rnhx2vUY6lePeXFx87aCmBrhrlriQz3D+3xSBssbBsJNzRyeaBs0Kdn1/jAc35vArPdSqeT7Zv4+yVmHtn3meJO5h26IqyU3N0gn5fRzc7afdXadUV5n+K0nOcvJxbz/5ZAqj8JQ+1Y8a6OP3BzefG7SPjlJPW/SNHEZPL7NhFMmls0Si/ZhWhWIuQ0V7JJJNzn7Xz0BIZjEpMfVbgRobzD40xZwiGBVDtNCDXsphlJb/q6DxIns78XRup3drlLpVJpNKoKUzSG6JcDiKx+sSA95CzFcjvrjESCyIrRfwuxQm7yxjivHZdROXHMTQV5viDTYNXrDn6yMsLy4Q7enn8eoS49+OobR5xbpGuTJ5jWyuIOI6kye6icgVbv5U5PTPebJaoqXwKq/9aDO3r5J/Eif+x5Ro0yJlvSY2RkUT6xvuGxYb5qIg+nz3doa5X5LM3OeN4g1eq+DDAs8Ahn1B1kGf6gkAAAAASUVORK5CYII=",
                  brush: o.COAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAARCAYAAAAhUad0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAANoSURBVEhLvZVLbxtVFIA/v8dju7HjuHZqxyalhVAIpEVJQ5oSSoxYdYV4LFCJVIkF6gYk+AUsWSEhNkWqQEhdobKIKlCFQhFxVAhtSltSx7Edx9jxI4nt2BO/xmbquBRogSiR+i1mRnfuOd+dO+fMqJoKPGTU7fNDZVdSwdCD//UzOPb1t0e2x46kF069yHuvjNFtlcnncuj1Bo68MIFBdLdn/Dfbfqc/TLyGHI7Td0jDiv0ge/2HKEx+z8TlImWNkU6Xl9CNWbq8B7g+dZG6nGtH3s//Sq2OfowNiQN6M6aixJDFwBMD+3HbCwSmg3yYamKyetjcLKBRa5BKeeRyEd9TQ1BVE5r/pp3pHvdJ99geZ+DoCBu5IosLIex2G2ZRptPpYjkcpLJWxGVW46jLNKQiAZ0Oo93MajCuJKsrGVSolQU++uQIokEgHl8iFQtsJW/zN+nR0ZMU8nmi4SQWq4NyKYOn9xE8Xid6QUc08jvpaBSLKJBZy6Fxipz64AyRVIiZrwNkZ4NKnA29uIfC+jrmjg50GpGV5Zm2YYs/C2l69idCkbhyZaJSSVCTqwwfO8aY/3kEo4Wbc78hy2q0Og3J1TSul59m8J1xJn+eIhJNICUKdPcOYjTZefa5UYZGX8IkmFlL3Uan69yStGlJz355nm+/C+DyeBFMJmV1RrRUSGdSrCSzNJVplWqDfDbLxnoa5UExyw2yC6vkY1mWZm5BvYHN24fYsZdbv1zjauBH9AYrTu9hjBYPeq29JbxDa3u7fcMMHj/Bjbk56rWCsoVhnL6DNOUm3l4XGr2GRCyDVN7grTE3XpvAQiTNZ1eWEPsfo7yUoBSNIzr68O1z06iVyKbjFDLZVmxXlxvRrOPXq1MtqbZ1VJWRihlWovNIG+HW0F8Z8b9BrSKRWb7NV1MlKvUyOq1APZ+jOR+jlIrT3CzjtApotXUWFyO4e3qVmpA4MX5ceT1mfN57Pdza3mT0GpcunH2g8A7Tl84TDU7TqFeU6k0z6jVQV9rn3Qk/l8+9ytvjHrQqPbWmgVg4hqpRo1ouKZECJUlWOsJEQWmlu2z74/BPLn78JkcOO9EoFXrl8y84/ekqDWsP5UaTfPJ6e9aD2bH0Lp+cHmZyrkjVNYCn7xnOffR++86/s2vpTtjVX2ZnwB83CW8X6RxQJQAAAABJRU5ErkJggg==",
                  brush: o.COAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              }]
          }},
  {
            info: {
              displayName: "Cabin",
              category: "template",
              icon: {               
                imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAkCAYAAAD2IghRAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFcUlEQVRYR82Y3W4TRxTHf7vetb2Osd2AY18kogqpKkETSC7sUEEAqep9L7jhEfoYfYA+BqqUN6hUKNyUQgnioxcVigOqIR84ITHGG3u9M73YzHr9tXZIgP5udj1n9sx/Zs7MmbHBR2Jp6YpsNBrEYjHu3r2jdduPitFdcFQKhaKMRCIIITCjJq5wKRYXpXBdHvz14Ng6cGzCFxcvSiklZtRESsne3h5CCPSITjqdRkqDQqEodV3n3r0/Ojrww/ffyWjcwjRNIhqsr67x66NHoZ08kvCrV69JIQQArnABqO5VAZg91fDrPduuIqUkeSKJrutcvrwkTdPk1q3fNAApdVxNx2jYtAwTDc9nGB8k/NKly9JxHFzXE4sWFNwCXBJWEoBkMsY3bAMRnlZqaJpGOp2m6TQpFhclQHlnh7NGlpZpEDUMNEIHGzik8Pn5BRkxImi6hhk1/XDQNK1HcCrlPROWQa3mvc+eqgHw5I1A13VS6RS6piOiJk/WN4jHY3w1cRLDjDOMocILhaJ0HAdN00ilUriuy9udtwghuJCTgDfqSrAiYRnU7RZRa4x8zivb2PSec9kaEOHx1luklEQMgy8yGVzh8uzf9fZMhjBQ+MWL30p73yYej2NZFltbW+zv7wP4goNi1Qgr6nYLgN2dPb9M1UkmY9RqDc5PeDMAksdb28RiMVKpFFJKLlyYl/F4vGchK3qEFwpF2Wg2MAyDdCpNpVJBCMF8Xo1ChIRlkc9lfHGHRddN8jnLnwHgoBOCv3dcHMchm80ipGB2dk5alsX9+392dMAXfuXKVbm/v080GsWMmlSrVYQQnJ9wgHYo5HMZ9QmZ8bT/Dt7oqrLgSHfXU+RzELXGAGja79nY3OXcuFoH2+i6TjrjfVssLsp4PM6dO79rAEahUJQArutimIa/4OayLuAykT1JrdboEKxo2u+7i0YuUwQ7mM9l2Nj0QmmOXcDlaWUPNDiRSuEKl0KhKKUQGG6rhSsFTsvBaTrMZZu+I4CtN9sAlF6oePz41O12W7OnvBB9WqliRk2EK7xBfrjy0I+dG9fOyukvJ/2PwFtkCatnKXwG1rl5+4mvtUfRxubuwZTtAt60qWrK9qlRWoL0CK/btY6wqNs1tt607Z8yZDqJdPzqEa52j7ptk7CsLuunJaihbtsdth7h7TDpzV7BvTszng7dLRT9pnl03I6wDdIjPMigbAid21gY3T5GJWEZlF7UBia5UOFBNjY3uosAyOfy3UUjcVR/ocLVQSkznubnX/pfv3768WvZXaYyaPAJXnip95u3/wn1NywMQ4Urwpw07ff+dKqOQjuU1DNhGSOFl/I3LHeEWw8YFGfQaRu1Xhij1gsVHrXGiFrhCzFhGf5BKXjI6mbQAawfg3wECRUeDINB1O0WdbstJExUmC3I7s7e0UJlmOiPybC2Q4VXq7WRLwxqYQ4aqaBtmL+EZfRNOkH6t3JAKpUc2ohC1QurH2YLUrdb5HOZ0HNRqPDg9vZ/I1S42lUAblzrTTQw2g7Qj2H+wnIHDBEeTAbdFwxFdwIKI1hvFH9hhLd0wCiO4HjrDRuEcCsfHgqHYadSASA5ZnXc+sMYKnyYg+MgOda+sHS3l7AMqt7fkh30CC+9KPd9/1y0NQy4ui0tLcnGeBYpJeVymcnJSXRdR9O802epVOLMmTM4jkO5XGZqaopIxHOmaRpS9t0kBqL8qj9Ng5RKJaanpwFotVq8evWKqakprl8/J5eXlzU4ED4/Py+r1Srv3r1DSommabx8+RLw/ihSjp8/fw6AlJK1tTUOy8zMTMdAqM7qus7k5CSvX7/m9OnTzMzM4Louq6ur/rerq6vous7CwoJcWVnR/gMS6rip19cCIwAAAABJRU5ErkJggg=="

              }
          },
          action: {
              type: "random-template",
              actions: [{
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAkCAYAAAD2IghRAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFcUlEQVRYR82Y3W4TRxTHf7vetb2Osd2AY18kogqpKkETSC7sUEEAqep9L7jhEfoYfYA+BqqUN6hUKNyUQgnioxcVigOqIR84ITHGG3u9M73YzHr9tXZIgP5udj1n9sx/Zs7MmbHBR2Jp6YpsNBrEYjHu3r2jdduPitFdcFQKhaKMRCIIITCjJq5wKRYXpXBdHvz14Ng6cGzCFxcvSiklZtRESsne3h5CCPSITjqdRkqDQqEodV3n3r0/Ojrww/ffyWjcwjRNIhqsr67x66NHoZ08kvCrV69JIQQArnABqO5VAZg91fDrPduuIqUkeSKJrutcvrwkTdPk1q3fNAApdVxNx2jYtAwTDc9nGB8k/NKly9JxHFzXE4sWFNwCXBJWEoBkMsY3bAMRnlZqaJpGOp2m6TQpFhclQHlnh7NGlpZpEDUMNEIHGzik8Pn5BRkxImi6hhk1/XDQNK1HcCrlPROWQa3mvc+eqgHw5I1A13VS6RS6piOiJk/WN4jHY3w1cRLDjDOMocILhaJ0HAdN00ilUriuy9udtwghuJCTgDfqSrAiYRnU7RZRa4x8zivb2PSec9kaEOHx1luklEQMgy8yGVzh8uzf9fZMhjBQ+MWL30p73yYej2NZFltbW+zv7wP4goNi1Qgr6nYLgN2dPb9M1UkmY9RqDc5PeDMAksdb28RiMVKpFFJKLlyYl/F4vGchK3qEFwpF2Wg2MAyDdCpNpVJBCMF8Xo1ChIRlkc9lfHGHRddN8jnLnwHgoBOCv3dcHMchm80ipGB2dk5alsX9+392dMAXfuXKVbm/v080GsWMmlSrVYQQnJ9wgHYo5HMZ9QmZ8bT/Dt7oqrLgSHfXU+RzELXGAGja79nY3OXcuFoH2+i6TjrjfVssLsp4PM6dO79rAEahUJQArutimIa/4OayLuAykT1JrdboEKxo2u+7i0YuUwQ7mM9l2Nj0QmmOXcDlaWUPNDiRSuEKl0KhKKUQGG6rhSsFTsvBaTrMZZu+I4CtN9sAlF6oePz41O12W7OnvBB9WqliRk2EK7xBfrjy0I+dG9fOyukvJ/2PwFtkCatnKXwG1rl5+4mvtUfRxubuwZTtAt60qWrK9qlRWoL0CK/btY6wqNs1tt607Z8yZDqJdPzqEa52j7ptk7CsLuunJaihbtsdth7h7TDpzV7BvTszng7dLRT9pnl03I6wDdIjPMigbAid21gY3T5GJWEZlF7UBia5UOFBNjY3uosAyOfy3UUjcVR/ocLVQSkznubnX/pfv3768WvZXaYyaPAJXnip95u3/wn1NywMQ4Urwpw07ff+dKqOQjuU1DNhGSOFl/I3LHeEWw8YFGfQaRu1Xhij1gsVHrXGiFrhCzFhGf5BKXjI6mbQAawfg3wECRUeDINB1O0WdbstJExUmC3I7s7e0UJlmOiPybC2Q4VXq7WRLwxqYQ4aqaBtmL+EZfRNOkH6t3JAKpUc2ohC1QurH2YLUrdb5HOZ0HNRqPDg9vZ/I1S42lUAblzrTTQw2g7Qj2H+wnIHDBEeTAbdFwxFdwIKI1hvFH9hhLd0wCiO4HjrDRuEcCsfHgqHYadSASA5ZnXc+sMYKnyYg+MgOda+sHS3l7AMqt7fkh30CC+9KPd9/1y0NQy4ui0tLcnGeBYpJeVymcnJSXRdR9O802epVOLMmTM4jkO5XGZqaopIxHOmaRpS9t0kBqL8qj9Ng5RKJaanpwFotVq8evWKqakprl8/J5eXlzU4ED4/Py+r1Srv3r1DSommabx8+RLw/ihSjp8/fw6AlJK1tTUOy8zMTMdAqM7qus7k5CSvX7/m9OnTzMzM4Louq6ur/rerq6vous7CwoJcWVnR/gMS6rip19cCIwAAAABJRU5ErkJggg==",
                  brush: o.METAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              }]
          }},//data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAkCAYAAAD2IghRAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFcUlEQVRYR82Y3W4TRxTHf7vetb2Osd2AY18kogqpKkETSC7sUEEAqep9L7jhEfoYfYA+BqqUN6hUKNyUQgnioxcVigOqIR84ITHGG3u9M73YzHr9tXZIgP5udj1n9sx/Zs7MmbHBR2Jp6YpsNBrEYjHu3r2jdduPitFdcFQKhaKMRCIIITCjJq5wKRYXpXBdHvz14Ng6cGzCFxcvSiklZtRESsne3h5CCPSITjqdRkqDQqEodV3n3r0/Ojrww/ffyWjcwjRNIhqsr67x66NHoZ08kvCrV69JIQQArnABqO5VAZg91fDrPduuIqUkeSKJrutcvrwkTdPk1q3fNAApdVxNx2jYtAwTDc9nGB8k/NKly9JxHFzXE4sWFNwCXBJWEoBkMsY3bAMRnlZqaJpGOp2m6TQpFhclQHlnh7NGlpZpEDUMNEIHGzik8Pn5BRkxImi6hhk1/XDQNK1HcCrlPROWQa3mvc+eqgHw5I1A13VS6RS6piOiJk/WN4jHY3w1cRLDjDOMocILhaJ0HAdN00ilUriuy9udtwghuJCTgDfqSrAiYRnU7RZRa4x8zivb2PSec9kaEOHx1luklEQMgy8yGVzh8uzf9fZMhjBQ+MWL30p73yYej2NZFltbW+zv7wP4goNi1Qgr6nYLgN2dPb9M1UkmY9RqDc5PeDMAksdb28RiMVKpFFJKLlyYl/F4vGchK3qEFwpF2Wg2MAyDdCpNpVJBCMF8Xo1ChIRlkc9lfHGHRddN8jnLnwHgoBOCv3dcHMchm80ipGB2dk5alsX9+392dMAXfuXKVbm/v080GsWMmlSrVYQQnJ9wgHYo5HMZ9QmZ8bT/Dt7oqrLgSHfXU+RzELXGAGja79nY3OXcuFoH2+i6TjrjfVssLsp4PM6dO79rAEahUJQArutimIa/4OayLuAykT1JrdboEKxo2u+7i0YuUwQ7mM9l2Nj0QmmOXcDlaWUPNDiRSuEKl0KhKKUQGG6rhSsFTsvBaTrMZZu+I4CtN9sAlF6oePz41O12W7OnvBB9WqliRk2EK7xBfrjy0I+dG9fOyukvJ/2PwFtkCatnKXwG1rl5+4mvtUfRxubuwZTtAt60qWrK9qlRWoL0CK/btY6wqNs1tt607Z8yZDqJdPzqEa52j7ptk7CsLuunJaihbtsdth7h7TDpzV7BvTszng7dLRT9pnl03I6wDdIjPMigbAid21gY3T5GJWEZlF7UBia5UOFBNjY3uosAyOfy3UUjcVR/ocLVQSkznubnX/pfv3768WvZXaYyaPAJXnip95u3/wn1NywMQ4Urwpw07ff+dKqOQjuU1DNhGSOFl/I3LHeEWw8YFGfQaRu1Xhij1gsVHrXGiFrhCzFhGf5BKXjI6mbQAawfg3wECRUeDINB1O0WdbstJExUmC3I7s7e0UJlmOiPybC2Q4VXq7WRLwxqYQ4aqaBtmL+EZfRNOkH6t3JAKpUc2ohC1QurH2YLUrdb5HOZ0HNRqPDg9vZ/I1S42lUAblzrTTQw2g7Qj2H+wnIHDBEeTAbdFwxFdwIKI1hvFH9hhLd0wCiO4HjrDRuEcCsfHgqHYadSASA5ZnXc+sMYKnyYg+MgOda+sHS3l7AMqt7fkh30CC+9KPd9/1y0NQy4ui0tLcnGeBYpJeVymcnJSXRdR9O802epVOLMmTM4jkO5XGZqaopIxHOmaRpS9t0kBqL8qj9Ng5RKJaanpwFotVq8evWKqakprl8/J5eXlzU4ED4/Py+r1Srv3r1DSommabx8+RLw/ihSjp8/fw6AlJK1tTUOy8zMTMdAqM7qus7k5CSvX7/m9OnTzMzM4Louq6ur/rerq6vous7CwoJcWVnR/gMS6rip19cCIwAAAABJRU5ErkJggg==
  {
            info: {
              displayName: "Bob",
              category: "template",
              icon: {               
                imageData: "data:image/png;base64,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"

              }
          },
          action: {
              type: "random-template",
              actions: [{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              }]
          }},//data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAkCAYAAAD2IghRAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFcUlEQVRYR82Y3W4TRxTHf7vetb2Osd2AY18kogqpKkETSC7sUEEAqep9L7jhEfoYfYA+BqqUN6hUKNyUQgnioxcVigOqIR84ITHGG3u9M73YzHr9tXZIgP5udj1n9sx/Zs7MmbHBR2Jp6YpsNBrEYjHu3r2jdduPitFdcFQKhaKMRCIIITCjJq5wKRYXpXBdHvz14Ng6cGzCFxcvSiklZtRESsne3h5CCPSITjqdRkqDQqEodV3n3r0/Ojrww/ffyWjcwjRNIhqsr67x66NHoZ08kvCrV69JIQQArnABqO5VAZg91fDrPduuIqUkeSKJrutcvrwkTdPk1q3fNAApdVxNx2jYtAwTDc9nGB8k/NKly9JxHFzXE4sWFNwCXBJWEoBkMsY3bAMRnlZqaJpGOp2m6TQpFhclQHlnh7NGlpZpEDUMNEIHGzik8Pn5BRkxImi6hhk1/XDQNK1HcCrlPROWQa3mvc+eqgHw5I1A13VS6RS6piOiJk/WN4jHY3w1cRLDjDOMocILhaJ0HAdN00ilUriuy9udtwghuJCTgDfqSrAiYRnU7RZRa4x8zivb2PSec9kaEOHx1luklEQMgy8yGVzh8uzf9fZMhjBQ+MWL30p73yYej2NZFltbW+zv7wP4goNi1Qgr6nYLgN2dPb9M1UkmY9RqDc5PeDMAksdb28RiMVKpFFJKLlyYl/F4vGchK3qEFwpF2Wg2MAyDdCpNpVJBCMF8Xo1ChIRlkc9lfHGHRddN8jnLnwHgoBOCv3dcHMchm80ipGB2dk5alsX9+392dMAXfuXKVbm/v080GsWMmlSrVYQQnJ9wgHYo5HMZ9QmZ8bT/Dt7oqrLgSHfXU+RzELXGAGja79nY3OXcuFoH2+i6TjrjfVssLsp4PM6dO79rAEahUJQArutimIa/4OayLuAykT1JrdboEKxo2u+7i0YuUwQ7mM9l2Nj0QmmOXcDlaWUPNDiRSuEKl0KhKKUQGG6rhSsFTsvBaTrMZZu+I4CtN9sAlF6oePz41O12W7OnvBB9WqliRk2EK7xBfrjy0I+dG9fOyukvJ/2PwFtkCatnKXwG1rl5+4mvtUfRxubuwZTtAt60qWrK9qlRWoL0CK/btY6wqNs1tt607Z8yZDqJdPzqEa52j7ptk7CsLuunJaihbtsdth7h7TDpzV7BvTszng7dLRT9pnl03I6wDdIjPMigbAid21gY3T5GJWEZlF7UBia5UOFBNjY3uosAyOfy3UUjcVR/ocLVQSkznubnX/pfv3768WvZXaYyaPAJXnip95u3/wn1NywMQ4Urwpw07ff+dKqOQjuU1DNhGSOFl/I3LHeEWw8YFGfQaRu1Xhij1gsVHrXGiFrhCzFhGf5BKXjI6mbQAawfg3wECRUeDINB1O0WdbstJExUmC3I7s7e0UJlmOiPybC2Q4VXq7WRLwxqYQ4aqaBtmL+EZfRNOkH6t3JAKpUc2ohC1QurH2YLUrdb5HOZ0HNRqPDg9vZ/I1S42lUAblzrTTQw2g7Qj2H+wnIHDBEeTAbdFwxFdwIKI1hvFH9hhLd0wCiO4HjrDRuEcCsfHgqHYadSASA5ZnXc+sMYKnyYg+MgOda+sHS3l7AMqt7fkh30CC+9KPd9/1y0NQy4ui0tLcnGeBYpJeVymcnJSXRdR9O802epVOLMmTM4jkO5XGZqaopIxHOmaRpS9t0kBqL8qj9Ng5RKJaanpwFotVq8evWKqakprl8/J5eXlzU4ED4/Py+r1Srv3r1DSommabx8+RLw/ihSjp8/fw6AlJK1tTUOy8zMTMdAqM7qus7k5CSvX7/m9OnTzMzM4Louq6ur/rerq6vous7CwoJcWVnR/gMS6rip19cCIwAAAABJRU5ErkJggg==
  {
            info: {
              displayName: "Crates",
              category: "template",
              icon: {               
                imageData: "data:image/png;base64,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"

              }
          },
          action: {
              type: "random-template",
              actions: [{
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAF3RJREFUaENVWvevZddV/vbp5fbyepkZv5mxsccxTkIJiQxOwQ7EiRKIkAJCBBFBCC3iB36A/4sShYCVBJLYxpk4zow9M6+X28vpbaO19rsjuNLTeaftvXr51hFf+XhX+r6Pet1FmqYwTRdVVYF+SZJguQjR7XZhmBoWiwWyPIcQAoauw3EcxHEEKSUsA9A0DaawYds2srxAlmWYBAt+ThOCr8/nM5imCc3QURQFRGXwfmWV8X1ag84Nw+D7stJ4fdsx0Gg0EIYh799stPi5MAoQhRnEP/3xp+SjR4+w3m2hLEvkeY44jpGWgGVZ0ISBIAjg11xe2NQEH0v63zSRJuoYpzF0XYemK8IgSt5wrdfHcrlkxulnmS4LqILEeDyG51pMPD1LjNDeJFigYqJ9v84CoXMSCP1P94lW2rcUBsajOcS3vnhXhqkA0iU/oEEwQcRQs9lkZkgTuiEQRREgNV5wNpvx8/P5XD1nG6xRAYOJoR9dL3LJjNGm9L7QSriu0j79Ec+0l2a6THitVuPnXdPgvek9YlxKwUfXtfl6pQum4epyyOfi279/T06XOeoWeGHddHlDWpBe9GyHpRXGKRNNmqHzer3OBNAzxHgYxGi1WlgsQpYwmQNpwnUtNhOSIK9vCD7S76lUyxKeW1MatU0mrEwTPk4mE76+1t9QDOvg/ckqaO/xaKoY+YvP3ZGLJEK75rANnpycQpg2pFAbacLkjYmxlcRocSKO1EzXSQOmbqDT6bDE6bphuswMMUUaDJcBa4JMjp+3lInR+6PRiLVHzxom+H1ajwgvK421kqUxC8b36szIiy/ewo/f+gWGwyEzyoxMwyW6DQ8bGxuYTme4//4DJAULTdkhSzODaRp8Ti/SNSKUzmlhz/XYl4gRulartZggZQ4uIFUwYOLKErZpPnVqMiVak35ZFvE7mmmwzwhhsgDJpDgoJAWkBD772V/B/fcOWWMkGPF3b7wkTweX6LcdNo1lEPONy2mIj3zkIwiWc9S9Gh9poWanBV0Y6PS60CVFN8lqhq6xdIhoeo6kx9FJ05iguuczgbNFwNdNS/nhioEizdhEojRhhkiL5INkDRzBshKWbePwyWP84oNDfPnzr+B7P/wf5FmmfPPbX/xleT4aYK3j8qaabrGkn5zPrkNwBVMvcPdgX10/GSLNKhhky4aA65j8HG1GC5L0VhojsyFtkckSE6uoRP5FzxKxdJ99B4L/X0bh/7tOzKooqCFJM2y0PfzP/V/gi7/9SXz/J+8hpQhYVRB/87svyMvJBN2GD8+zkVFoLUs8Ohqg1mlDVBWbjFZJPPfsTY4m81mI81GJTA7RrnfQbTdh6prym5wiUYU4SvgcQvJ69P9K+qTxOMr4OWKi3+/DMa7NDlJFtUyyaWZ5yIFgFKRYBgE22g7Ozy/xud/6BN762SMMrq7geZ7ykagosNXvQNMkBqMRa+bR0QhJWeH2rR02nfFkCgMSd25tsmRzTeKHPzqF1Ap4toma77FJGoZ+7Rceh+2qKp8yQKZCEZFMKElD1rBrO7weCZ206fm+SrRJxOs16k2UJTBfBgjjGLe3W5jPl3jj9Vfxk/sf4snjx+j1ehDffP2mvBwF2N3ocASZL6aQ0sKD4wEv3O+0sdZrICkTBMsE25011GoWa28xj/HgaArKX1ITqLsOZKY0QVGP3qd/SLLNdl8l2jRnH8ml5DxQ5QULbpVgy7Lg50oB3Nzb4HUoKc+DCGmWo+3rWMYJPv2Jj+PhkzOcnJywL4l//NpH5ePjAXbW27zgaDyA67bw8PicJTmbh1jvtdHveUiSHFlaIU9T7G130V/r4dHRBUazCLZlQKfsa4inmXrltKTRgMsfk7VAjDqWw4zapqWc1VCR0PUctoBFEKuwW2RshkIYmM5muL2/jukywG+8fA/v/OwhVwfsi3/xO8/Ks8EUW20X3V4L81mAAhpmkURZCThWifOzEbY2+/BsKj8yzOYRSlTotZoQMketVscHxzMsFgFsm5jR0Kqp6JUVOZuOMp+KCWfHdywW1Crr55lKcJ7n83XWWp5DQuPkO5xNMZkFaNcsjMdTfPlLr+NfvvMm5rMJHMeD+Osv3ZNXkyWaVoV2p4EkzrGIEoSphovRHGtti8uSZRgxgc/d2UMQ5Ti+uIKBCmudLhxXxyIssYhSuI6OumtDlyXbuqFrbFqur+okKgLpukTJkl8Vh5SjiBHHrrFmhFDJlIRDzn81mWEZpWj6FpbLEF/8wufwnX//AYaDS9i2C/EPX/2YfP+DI+xstCFExVVuXhk4Hy1wMpij4Tq4d2ePM/5oEWK734LvOTAMDbN5zAnQsShJmmzbg2WCVq0G33WQJQHkdZ3FhWUcw7I0xYDlsuSzNGNzoz+KjqQ5ikIUKNjp84rPx+MJojTFeqOOIIjw1a++hu9+78eIl8RgDPHtL70on5xcYWutCd93uPgL4hKH5yMsUkBkCXStxM3NHobTBQzLgSxzrHc9CMPF8cUATd+FQ5EszzFZhmg2eojTCLapod9uPs3w1A5oWsWRSxcqCJiGqng529s2+wsRTmvRfSqXuFwPUgymE2x0WqwRYuSf//X7yKIlFmEE8a3P35FhVqLuCl4giTNkFTAeLeHWW7AtVaRlWc4J8NHJEFEcoelaeObWHooyxpMnF5wL2q0GS3s6ncL2mtA1Ad82kBNTrq/KcVGpQlAzOdoQwfwTFRelxJjKRwkzZ5nk/BUKQ0NZScg4RQGB1z79Cfzbd99Es0G12gTi77/8orwcz7C11kC73UaRV/jw8BiF5mM0D2FqqujKYcIRJdqujsF4higr0K77uLW7jiBJ2Z+219dQFgk76vH5BFFWooCE71gwqRkzDLZ9snn2B8e5rgIKFgCZ2ko7q/JF0wRX1K5T46ZureVhNJvjK298Ft/9jx+wmR8fn0L85et35XAa4uZemzvB4XTG4W64CCHMBjxNNUhhHCFMM7TqDRiywGwyQ1QBDcfEzRs7SOdDfHC1xP7WBvIsgV/TMLhaYLAAuh0b/UYHjaaPYLFkoieLJZcuw9ElS55qMW6k3LrqewwV0VrtBhbzAEleIU5y3Lu9h4ePn+ALr38S3//hT6HJFJNpBPFXv/OcPL2cMCMqUQF5VuFsNMUsKNGwBF+nsKsZNhbLEAJAu2ljMQ2h2Q4sDTi4uYvZdILH50OsdzswDYFWq44gLHF2OYZpUPFowvNc1jD5AhGcZeV1/vBUMQnV5qbXiVFoEnlWQmomgjDBwU4fZ1cDfO7Vj+Otdx6izALEiYT4+m/uyPEixMH+Fi8QRESogfPhFBk0aKB+XINjWqz2IMlR5CXyssDNrT7msyUiCNiosL+3BZlluFpGaNdrMHQB21H+NppXaLUs1FyTK2MyS4pUnuMoDVAbbFns8HSfjmR6S+pdqLtMJMazBVq+gfF8gVd+7Zfx5o/uQ6uoucsg/vp3n5UUefa3+twYnV9eoOY3mZEgK7De8eBYOtJAbVZZyvnCsABkCd/RMBhOUWkGE3djt8elyyiI0fBctOsmXMfD8fkAZ5cT2I7qZ6o8YWev+e7TiEWmNBgMVDVbqWJTGKrfoXA9XQTYXmsiynL8+svP4ztv/gRN31GM/OXrt2WQUuEn2EfITk3DwfFgjCSTqNdUJ+g5qjegCpSkFUQlAB2aIbHWcjG4mCJHAc8ysL+3gyiaYzrL0O346DYbsKwKF1chfnZ0CdexYaCEa5vIo4j7oFKTLCjSOjG6yvqrWosauzitsN1zEaYVPvXSc3jzrffgexayrKA88oIcTBewDZV4aKF2q4eTiys49Rb6dZNNbjmfsqotx2ZnzalbKwWG0whpEqHhmWyrcZ5xlbzeaSCrKiRpCYES+9sbsE2BOEzw1nsPcfPWATRRoebq7PSdeh0XFxdsXkQD7cWRi0AI08U4SJAUFaosQJRJfPTOPv79v9/FxnoX0+mcwu9L8vHxJZp1Devr65xRPbeOw8sxKs1ETc+oB8T+1g5vsGpLE245JaTtIE4LTlKuVkATFgZBiKZjcIwvZYFgnvAam+sdbPZbCKIYP3jnIerNHlpmgWbNY9wLgmAmyUyQsLjzhECY5ggLibzIsbXWxePjC7z6qy/je//1Nuq1a9P62zdekIenA+zttJ/GcUO3cbHMcHY1hK1JdDpNVNedGtU/qhdPOR/kRcUlgmvXoMkKN3baiJMCc+otLBN3ntnB2ekVpEEFqIWbOxuQVYnBPMB/vf0YaZGh7jkoy4prNvI/ymcMYBgGoigBdBMirbjsf+WTz+PBo2N87LkDvPP+I3TaqmQR33jttjy+GKHf8rC3s4k8zVCUwOnFBLkU3MubArBsBQ6sKlNh2LwZLUKSy5IMlu9iOE/w3M0d/PzhQ3i+A8+0QWiBpgFBmMI0JF6690so8hDnZwMMQwFUGXzHRs0he1eZvtLENUCnoltWCCRpjt2tNmvk1lYPP/rxfTz3wnN4/OgY4s8/f5fLeMrQLpcTGYRm4mQ0R5hkrAnL1GFT5EpTtlsKh7ajGCE/IS1FYcIwKINnJW3YwdXFErot0PB9mMhhOB4iQkhkiWcPbqAocmSVjnd+fggJKmd0Llop/P5fhIZ7/bRkhOdjLx6wRoiRhx+coNlp4upyDPGtN56XHxye4fk7N4AqRxiqMDuYppjHKWpWhW6jhSLPlOSLnE2KAgM3XtTlUZ/KZhAhCYk4Mm0TH31hB49PxoxNbfbqyIsUQjO4ctZkht3tHrq2h1GY4z/fPUSap3CNCnXXha4plLEUksMrtRFUnR/sd3F6Pscze32cXg7QrLVxdHSkGqvL8QJrbR/r/Q5GozFLeL6MYdg19OoWw6hhpEoKxpZKBbKtEhh1aMQc2XRV5ZhMF1hmEu++cx8Hz+xhvlgiiDLud3oNC7NpDClMOBawvdFRwIMQePfhGGtrLYAElke8l5QlygIoSg2T2Rg39/oYTzM0PYF5GDMjBEOJb75xRx4fDXBzdxu6IZkBIiqMM1yMp+jVa8iyGLZlcv5Yxfg8j7lzm06XCkkMYpVvagRAK2CPCDm9uMCztw8wuJpiHi0ZqNjf3UKeZxyaUcbY31HnWQm8/d4pDDMFSp0TsRCqBXYokWo6+r0Gji5G2O41MBgvUL9GOsXXXlmX00mM/e1NNFs+LgcTNpvJbMklSpPzRgrX9p6akSqzY9aQCpEKIKCKFpqqzVa9BaEqhmVxLz8YLTia7W6uo+mZ3FJPJhEcs8Cdg30cn11CM1xcjiMUVYxeuwkNlSpawxxJmmJno8mM7PSbOD4boN/rqar6Tz59U5I0m3UXfs3BZKZA6DCS7CMutbPrHRRJzAtSO0smZZiqq8tjhRzmBVgA5EMcNmPV6hLoTdHGNHTYQuJ8MGYf2troot2sYTwbQhM16EaKnf4mHh0dYr5MYdQaQE7Yc8aa1uChlDm6TRNX0wBb3QYmhFrqJlvGU0bqvs3gw+VgqpwMArOQemRqdAQsTWcGSerEkO+TyakAwFivqzo9ukcm1ev2+dkkKzAjVL7exGg8wXanjvsPH8FxXextbcLUSqRJhiQrcedgE6PhDHmpYbFMsLO/jW5LoZXzJYEbCaoixqOTS2bkcjTBen+dI6n4g9/YlIRCoEiZESKWhjcfXoyhOT46js3dG0WkVUdHtRHVZCR5mkCR5FfwJyVKYjCKFHSa5LnK1DkQxCmqUuLe3W08+vAQhRS4tbfFzVEYzjGfh3j53m2cnIwwWizh1Oo4OhtzpzkLAriahnvPbuFiOEO/7mI6W8K7hl/Fn3zmlpzNFlwOb22vM7FZWuJkPMPlcIrNThuuZ0EWFXO+GgCZhkJBdN1mE6P/ieCyVHmGgDhaK5gpDRPi6NWaWGYpikJD27ExCcY4H8xgmzo2+01UNGaDhn7TQae3gbd/eh8adAQ5UGgGsuUSuxse4hwwigQQBtq9HmNb4o9+c0/GcYpWs45GzeHRwXAwgea4uBot0K3b8F0VgUjF9NfrtZAlJZuOX/f5HsGtlDA1qF58Mps87THUYEdNwugewU0EKRkcGIAHD09hOzr67QbMa8BO5il293fwweMzSGFgNFnAr7fQ9TJoTh2uKDAaz9Dpr3HVIP7stTtyOBxjY72P7c0+Li8vUJUCiyTFIsxhIYNjafB9hWwoIIIgHDVia7UUoKZySEWjPg6XtUaNn1/hVnmuevIqK5GVEoVuYDIP0bZsrO108KO338MNipyNGmv44uIUDbeOgzt38LNfPIAmBd59cIZPffwmkkqHLTPuGNe3thFFAcSffvYZuULEN9e7ODw8ZEKCuIIg7Kkg5IOGOtR/ALZuqJKkUr7gWTTZjXm4SYkRlWQGVnOS1XhNI9PgQtBi/4orCdvykBYFdvstjMdzpGGAjZ1NWJrAZE4jNwu9uovz4RiJNBCFEXbXW5iGGTNCPXx/YxNpGkN8/TO35Gqz/d1NdmqyuXkCjCZLtBsGTEvjnoAhz+tBaVEo00qKnPOJUYHNZjgnUJuGOjThUqDcaqZI7xOTFCzSOIZte5guKAAUePZgE+++9wS+b2C914EmqJcnKEpDrebjbDBGkRfY22jjYrxAx1M9fFqU8H0X4g9f2ZW0AfXYvX6bpX51OcIwyHE5nsM1JIRWoV1rMIGORZFqzjUTD0JdWxE8X7LZkZpJG8JSc/KIIhUxkEhVFZgKHZGl0hwxuYxJ6yZ+7SM38P7DI/g1ao/raNY9LMIAju3BNXWMp1PcPdjDzz88QtvTcH4+we7+MzzjF3/86g1JhFA76vkK1Xvy+BgxbIwXERoW+YWEKHJOeJquwAO35qroxP4ioWsaE8rDfQKtLTX5ErJihjjJGQbM6+d0GrNFEQzLxnwZYjyL0KzX0e/6OD0eoxQ56p6LZqvGlbVhmVjr9KAjxuH5EHdvbODBgyO4fpOTOWuEotbmRo8loJseE3o+mmGwiFDmSpJVrghelR4Erap2VI2aRaGpKbBONV+BNFEmV8mCJU+IIb2bpNHTeo3zCzXlAKKEZicpFtM59jdbSPISRSUIm0K97nFrXfNq6Ps6zkYzrPd8zGYJwiTmIa74xut35WQyQ823sdZrI80VRDoPcrz74DFsTU2cPNtibRGRdCSnXZkGPS8N1XRVpQKpZaUimWFW15Uy5Rg1a18VnwyhXqMkUZyxmdG1SmZ4+e4z3HmGcY4gWGB7s4eM5jLdJk6HU9y+tclQrenYypRXGuk2a2xaVLIPRmMUpcodPLyn6tNVM4vVsJOurxhZzdNZI9dzdaq5OPzq6ssFmocoEzT4SI5M6DuZDeNbnscMUhVBglm1CoQF0/WyyllA9RohOEsO1R9+eAq35qtBzze/8DznkXbdw/pGjzPpYDjheQT1zivCi1IVb6tNmCga1AuhusLrD2HITGhDV1foS5apSRUlOnVUwcK5HvQITX28w9iVYTAGthovKFNUfQ+VNrS/LkwcnR/zWO7o6Aq6ZSrT+vpnbsir8QS393fYVqkBIiJrdVsN6h2fN8lzNYGlvoDur7RVVSpBpqn67GP1o+fpPRoSUQguStUmE/jH36oIZbKtlhpdr8Zyw+GEtUFgOv2o9aV1aO1Vm80f9ZQl00BYHAeVb//eS/KnP38f9+4e8IuLIFLzC51wWg8CmhpqXk+QaOxMElKfRJloNOvcp9DUkqew1z2KX1OVQHxd9tP8kcyOehtliqQdMrvgadtM1+mzJboOqcAOgpHYtGjEYFnMEGmM1r66usKNGzdUxfGN127Js7MzfObV31LOeV1qEPGcwQN15EmtlEhz+uQI0IVy6nqzwQsXmSoWyRzPz89VK3D9mcf/Q1+E4PlIo3n9DYuhRgtUeRNAt0qi9MkGT7Z0VVlTv09rj4ZTdm5KkiTwR08OERMjf/bbNyV/8CXVpxYE0JEqiXj6kTMRocQELWhqumqFk5gHOnROmpsHSzYxqgp2d3fVSKDV4s2IIaqwVzUZ9zNenTWt6fKpf9B+KzyLoh4xounqIx3K8LTP6mMe0hULt0w5wv4vwRVrIc7tHsAAAAAASUVORK5CYIIA",
                  brush: o.TREE_WOOD,
                  threshold: 50,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.TREE_WOOD,
                  threshold: 50,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.TREE_WOOD,
                  threshold: 50,
                  randomFlipHorizontally: !0
              }]
          }},//data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAkCAYAAAD2IghRAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFcUlEQVRYR82Y3W4TRxTHf7vetb2Osd2AY18kogqpKkETSC7sUEEAqep9L7jhEfoYfYA+BqqUN6hUKNyUQgnioxcVigOqIR84ITHGG3u9M73YzHr9tXZIgP5udj1n9sx/Zs7MmbHBR2Jp6YpsNBrEYjHu3r2jdduPitFdcFQKhaKMRCIIITCjJq5wKRYXpXBdHvz14Ng6cGzCFxcvSiklZtRESsne3h5CCPSITjqdRkqDQqEodV3n3r0/Ojrww/ffyWjcwjRNIhqsr67x66NHoZ08kvCrV69JIQQArnABqO5VAZg91fDrPduuIqUkeSKJrutcvrwkTdPk1q3fNAApdVxNx2jYtAwTDc9nGB8k/NKly9JxHFzXE4sWFNwCXBJWEoBkMsY3bAMRnlZqaJpGOp2m6TQpFhclQHlnh7NGlpZpEDUMNEIHGzik8Pn5BRkxImi6hhk1/XDQNK1HcCrlPROWQa3mvc+eqgHw5I1A13VS6RS6piOiJk/WN4jHY3w1cRLDjDOMocILhaJ0HAdN00ilUriuy9udtwghuJCTgDfqSrAiYRnU7RZRa4x8zivb2PSec9kaEOHx1luklEQMgy8yGVzh8uzf9fZMhjBQ+MWL30p73yYej2NZFltbW+zv7wP4goNi1Qgr6nYLgN2dPb9M1UkmY9RqDc5PeDMAksdb28RiMVKpFFJKLlyYl/F4vGchK3qEFwpF2Wg2MAyDdCpNpVJBCMF8Xo1ChIRlkc9lfHGHRddN8jnLnwHgoBOCv3dcHMchm80ipGB2dk5alsX9+392dMAXfuXKVbm/v080GsWMmlSrVYQQnJ9wgHYo5HMZ9QmZ8bT/Dt7oqrLgSHfXU+RzELXGAGja79nY3OXcuFoH2+i6TjrjfVssLsp4PM6dO79rAEahUJQArutimIa/4OayLuAykT1JrdboEKxo2u+7i0YuUwQ7mM9l2Nj0QmmOXcDlaWUPNDiRSuEKl0KhKKUQGG6rhSsFTsvBaTrMZZu+I4CtN9sAlF6oePz41O12W7OnvBB9WqliRk2EK7xBfrjy0I+dG9fOyukvJ/2PwFtkCatnKXwG1rl5+4mvtUfRxubuwZTtAt60qWrK9qlRWoL0CK/btY6wqNs1tt607Z8yZDqJdPzqEa52j7ptk7CsLuunJaihbtsdth7h7TDpzV7BvTszng7dLRT9pnl03I6wDdIjPMigbAid21gY3T5GJWEZlF7UBia5UOFBNjY3uosAyOfy3UUjcVR/ocLVQSkznubnX/pfv3768WvZXaYyaPAJXnip95u3/wn1NywMQ4Urwpw07ff+dKqOQjuU1DNhGSOFl/I3LHeEWw8YFGfQaRu1Xhij1gsVHrXGiFrhCzFhGf5BKXjI6mbQAawfg3wECRUeDINB1O0WdbstJExUmC3I7s7e0UJlmOiPybC2Q4VXq7WRLwxqYQ4aqaBtmL+EZfRNOkH6t3JAKpUc2ohC1QurH2YLUrdb5HOZ0HNRqPDg9vZ/I1S42lUAblzrTTQw2g7Qj2H+wnIHDBEeTAbdFwxFdwIKI1hvFH9hhLd0wCiO4HjrDRuEcCsfHgqHYadSASA5ZnXc+sMYKnyYg+MgOda+sHS3l7AMqt7fkh30CC+9KPd9/1y0NQy4ui0tLcnGeBYpJeVymcnJSXRdR9O802epVOLMmTM4jkO5XGZqaopIxHOmaRpS9t0kBqL8qj9Ng5RKJaanpwFotVq8evWKqakprl8/J5eXlzU4ED4/Py+r1Srv3r1DSommabx8+RLw/ihSjp8/fw6AlJK1tTUOy8zMTMdAqM7qus7k5CSvX7/m9OnTzMzM4Louq6ur/rerq6vous7CwoJcWVnR/gMS6rip19cCIwAAAABJRU5ErkJggg==
  {
            info: {
              displayName: "ERROR",
              category: "template",
              icon: {               
                imageData: "data:image/png;base64,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"

              }
          },
          action: {
              type: "random-template",
              actions: [{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !1
          }]
          }},//data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAkCAYAAAD2IghRAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFcUlEQVRYR82Y3W4TRxTHf7vetb2Osd2AY18kogqpKkETSC7sUEEAqep9L7jhEfoYfYA+BqqUN6hUKNyUQgnioxcVigOqIR84ITHGG3u9M73YzHr9tXZIgP5udj1n9sx/Zs7MmbHBR2Jp6YpsNBrEYjHu3r2jdduPitFdcFQKhaKMRCIIITCjJq5wKRYXpXBdHvz14Ng6cGzCFxcvSiklZtRESsne3h5CCPSITjqdRkqDQqEodV3n3r0/Ojrww/ffyWjcwjRNIhqsr67x66NHoZ08kvCrV69JIQQArnABqO5VAZg91fDrPduuIqUkeSKJrutcvrwkTdPk1q3fNAApdVxNx2jYtAwTDc9nGB8k/NKly9JxHFzXE4sWFNwCXBJWEoBkMsY3bAMRnlZqaJpGOp2m6TQpFhclQHlnh7NGlpZpEDUMNEIHGzik8Pn5BRkxImi6hhk1/XDQNK1HcCrlPROWQa3mvc+eqgHw5I1A13VS6RS6piOiJk/WN4jHY3w1cRLDjDOMocILhaJ0HAdN00ilUriuy9udtwghuJCTgDfqSrAiYRnU7RZRa4x8zivb2PSec9kaEOHx1luklEQMgy8yGVzh8uzf9fZMhjBQ+MWL30p73yYej2NZFltbW+zv7wP4goNi1Qgr6nYLgN2dPb9M1UkmY9RqDc5PeDMAksdb28RiMVKpFFJKLlyYl/F4vGchK3qEFwpF2Wg2MAyDdCpNpVJBCMF8Xo1ChIRlkc9lfHGHRddN8jnLnwHgoBOCv3dcHMchm80ipGB2dk5alsX9+392dMAXfuXKVbm/v080GsWMmlSrVYQQnJ9wgHYo5HMZ9QmZ8bT/Dt7oqrLgSHfXU+RzELXGAGja79nY3OXcuFoH2+i6TjrjfVssLsp4PM6dO79rAEahUJQArutimIa/4OayLuAykT1JrdboEKxo2u+7i0YuUwQ7mM9l2Nj0QmmOXcDlaWUPNDiRSuEKl0KhKKUQGG6rhSsFTsvBaTrMZZu+I4CtN9sAlF6oePz41O12W7OnvBB9WqliRk2EK7xBfrjy0I+dG9fOyukvJ/2PwFtkCatnKXwG1rl5+4mvtUfRxubuwZTtAt60qWrK9qlRWoL0CK/btY6wqNs1tt607Z8yZDqJdPzqEa52j7ptk7CsLuunJaihbtsdth7h7TDpzV7BvTszng7dLRT9pnl03I6wDdIjPMigbAid21gY3T5GJWEZlF7UBia5UOFBNjY3uosAyOfy3UUjcVR/ocLVQSkznubnX/pfv3768WvZXaYyaPAJXnip95u3/wn1NywMQ4Urwpw07ff+dKqOQjuU1DNhGSOFl/I3LHeEWw8YFGfQaRu1Xhij1gsVHrXGiFrhCzFhGf5BKXjI6mbQAawfg3wECRUeDINB1O0WdbstJExUmC3I7s7e0UJlmOiPybC2Q4VXq7WRLwxqYQ4aqaBtmL+EZfRNOkH6t3JAKpUc2ohC1QurH2YLUrdb5HOZ0HNRqPDg9vZ/I1S42lUAblzrTTQw2g7Qj2H+wnIHDBEeTAbdFwxFdwIKI1hvFH9hhLd0wCiO4HjrDRuEcCsfHgqHYadSASA5ZnXc+sMYKnyYg+MgOda+sHS3l7AMqt7fkh30CC+9KPd9/1y0NQy4ui0tLcnGeBYpJeVymcnJSXRdR9O802epVOLMmTM4jkO5XGZqaopIxHOmaRpS9t0kBqL8qj9Ng5RKJaanpwFotVq8evWKqakprl8/J5eXlzU4ED4/Py+r1Srv3r1DSommabx8+RLw/ihSjp8/fw6AlJK1tTUOy8zMTMdAqM7qus7k5CSvX7/m9OnTzMzM4Louq6ur/rerq6vous7CwoJcWVnR/gMS6rip19cCIwAAAABJRU5ErkJggg==
  {
            info: {
              displayName: "Ultimate Bob",
              category: "template",
              icon: {               
                imageData: "data:image/png;base64,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"

              }
          },
          action: {
              type: "random-template",
              actions: [{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAADoVJREFUeF7tnVtzI1cRx1sXW5Zkex1DIORCgFRIbfGwn4InPjivPPAQHggbNoGFbBbHXl8kyxL1O+f87bZjo5E0lzOUpso1o9HMeNT/09fT3aezWCwWtt2yoUCnFYC83jHb2TG7uTEbDiPxrq7M3r/KhpBlvUj+gPyzZ9bpmi3mZvOF2d5eBOfiItIAkLods9k87nd3zWD6n03KolGtz8kfELhDhL8BkF2znX48d3FpxrmOmSF42Q92zXq9+D3AzedmR2e1EnWTf5Y3ICcHZpeJE+CAGzPrmtluPxL9chJBgDMAZgYIZrY3iGBwDdwCKN2u2eEPm9CqlnvzBuS7vSiS2CSyIDwboExBABC6ZpO52dTMYI5R12y8HwG5vo5gcMx+NjM7OKmFuOv8k7wBkbiCkH6bTKOIAgg4J4g0uw9If8dsNIogsHVgJYsAwTWZcku+gAgMdAJKnQ3iTiaRa+AYiD67jt/DAWd8h8hyugQjwAMKIIGrdsyGb9YZxJXeky8g/x5Ei0l6QKNbIgzFDhBT5FTigKvJHecIJAgv5S5SwiE8F92SmfjKF5DvR3fKWFaTRvdgEL/jszgELriamvWSgmcPEBJV0iMCR1zDMzKywvIFBJHluSNxwfEXyCN089xO/3IefRP+EFVII6QblhaAmNnR8307Pj6209MTe/O1mfWTySyuAhC4LhNQ8gTkq47ZwSDK/ukkKu5+N4iow98OA4HZXv7xVQQjiLO030mcAQct5nb0xThg0+l17c3rQeQYRYsAI1wHoDOz984r1Q9FHp4nIK86ZvuIrEUEBJOWkd8xO37x7I5D/nwWLa3dQRzlEBiuGo+jKJtM7cXvP7cfzi7s7du3dooYlKgCCExg/uSrBJZq1onMExDCJcNRtKSIWQFIsLKIYZlZ+mi76Rznh4MIApYXWwBoFjmLZwGUnEUNVRkI2gMWHLT3XZHBXMk1eQKC/oBIwbGbRf2AwyePPDnvNjIzhaz4HiyCmYxiv7l7Bhwjy8rrJYkvefJ8x7md15UQu8hD8wUEIABgsjBDD6MIIBh/p5PIJYCQHPnAPXtJf3gPXeaxPHVZbNIjgBG4L/kyW0AeGTfiEAC5nsd4VSBaIjjHeOu4IFhW4xRcJPAINyDm4BCI2+9FMeadQ449EFyn74Op/E2RwVzJNflxCAFFdMcMb3wRCY8e6PWjJcQmzx0uUgiFc3jlbOfnETyAkN7wyvwhKcUdEme7/6qE2EUemh8g/xlHgjPCGcV44jJtIb5ElwjN9wDFPegPAJQIkqcvR9JPjvJsKXOulxPZoEIPYy27GUMAgRsQO3jeCq8z4hMwh8/3rQ/XmNnh4ZE9OxjZq2//EY7ZcAI5Zo8DyYbv8vLL5GfIzJXY4rPE1vhtkYFc2TX5AXL50/hjmRH0Thvnkld++LuDAMgnH31of/v6m3AMAPgav/7043AOAPjsrzslPubnR2Rdsc8krpUfIFfvR0AgXHDcrqPpywhGPPV6wVuH0Ix+AJDjJ+JzO6BoAxz46Ss4RNwg8SXTN5PIb36AQEW4RKMWQBBfiDHOSfGGGNTCXvzh+Y/Ehzjk5Z++j99xDzEsBRo9l2QChH5EnoDAJXLsZFlhdUlZe1Gj69AxgBY0Y4pXeR8EpY01JUXOMxrWF48ponwBURRWb40pLHNXxxBY2ScKe8gj5z4ffveAZApGGEvZWVkCQP4Iilweuka4orRci0gLv6QbAdAG0XEKCTx6R5BrGvQzHuMKfy5fQDB/5RwigvAlICaK/pL0n1kMOg5iWP42eBgMghQOkWPIOURVhiLqIUD5AsKbEvVVAlyYAx9G5fzuXbS40Bt+Q4dIccMdIWKc5kkyU95PcUregPDW+A44iKT9AAqZJFeXKQqcPHTPFRJxiKmQxTjPYuJpmajK28p67O2ZtCI0QvAQHcKfAocyjQFDXAO3YGVlMAtYFIy8lfpjv0KZKEp2gFvYsLQU81IgEu5oePZvFSDaxyF649Nn0VGUomfPZzl7iKhfaJJkHZI0e0/+OgT6kFKqkIcsJvaIMDZCK4reKgr8E00rNkvgVf973oBgZYUUH3yRVGoQFHiKzqJDpDcU7+J7QGmhuMpTh3hTVwoa01cTUUpiAAzvuQfg0iyhvPJM83f/F9fkwyHohpPT+K6aL0dBAwBlBzjkSKjR8M6S0kRWCDgmZ1CcAmAct6xwp3lACJHIapKllKIhIbmBjdQfZZWMh1FfwAUCAWDwO2QOKxFbTmGLQGkWEIVHFLFF7MAVlwp9EKvyZQYuq0TizDuCCkgquUFTv1zbEn+kOUDwKTRtCsEoTyMdVKk97AEH/QHHwC146yHAOIuhdqX7+AQ4hdeVGKdsRmJhHGcez2oOEJQ3WSIq6FSGonJzVS4AgamUIjNRVbffumAi1ykhArDEOYr++nQfP4eeqcJvBhDAIFI7Sn4EIQ4iu6rvQE8E5U460PWPHT35JSH5LQUYpUcUXJQp40PvynxXKUOGpnH9gDC6L5JoYqJbRZw4ebKQlpU1A6hiVZraVaqPZhMBRPMoPndXQKu2JDPdUi8gZCQifsjHRUcMU7EmcxphIimN9mVEAhDMYfkiHgwqos6P788Wei+f4yAeqbZKofmMrLB6AXmZCI4RxeQe9FAps/wLRNeyDg1qJqAmAqquZfSrRI15eSVEeDEWdNI0KngldHNfJqGW+gD5EpM1OXfKQAxxqDRKxylninPLRqzKpQFESdTSGQ+tqJsP7/QRR8w43hbqpO4QAJNJqL4eQKiICqEPMtTRFdSOO2WMI6fZvmXcAVExmZXzSz36rflMLcgTlbUAc5t4l9JUeY+QYoQITHGxhjmlekDwxM/epXLl5Dvcpvgk7gAbRugHctGXxEili9RmA/2jMoNlubnXH9x59TKX+XehaDQ1s2kQlHoAoT0GDh56AsLx2VdF/XLFDlFwiKwon91eJL1HgMgnkR6RslcYpyFQqgeE8AjihR/OLB5+haK3cMYnK4IBEDxTYRGeKV+jaIeGxcd3mZG+vlB1ijKTGwClekDkxCkDUfMX7D9SseCK0zgPc7Z8MU4RD3z68/uK3jcS4FhKvwHHsXpA+OlUv94WWKZMkaL64jGsANmHSXQNIBcd1cqyl+iSDuJZSvRuoMtDPYDwI/9OsXgKGG465+0BwW/RhBRKeZnJ7AE+O7pzDmWpyRIrwmkrMnaRy+sDpMjbFL2GySxV2qptk8Ik64xqRGDgjOSXFOWyou+7wnXtBAQO2d+PTh5eN80FMH1xFDMPry/Dpr2AkJOFeEFMYbkBCOdakjL6FDDtBcSbugCjuNaWQ5YxYQXfq1NQiEFRiJMKQtEjDZiqZf7CdnKIus1BCThDBTwAso5SL5OiGz6rnYAodPJYc7KtyNpwSKxzO2aqkh3wQzhWK7+tUl+Hohvew4wgGxaWpmxDqdpuo62VNvxV4fZ2iiw5hr6+UFyy5ZAyxsWKzyDkocgst/rmMVulviIxy7gcDmHz8+KbhE7KeKeSntFOkQWHsPn5C9KI8Na3VlZJQ2OVx/hOD6TzEM8KCn1v64esQsfSrhWHaB4c0SWzt6GweVm/rZ0iC7PXT3iJGiTPbZV6WWOj4HOYfvUNkH0jmm3opCARy7pMYEihs/cdSAFnG1wsi9pLnkP6DptKoH1ynLLZEWMNzvaVQYl26BBlHao1OIRXOyaVGNBuo0hecBlUq/AZ7QAEUQUI6tOulCKlnwIK5i8gba2sCodLEFGpB6PaweL8MYeuTaXRSuPB/F2WTlrxK2/y+Lw5RFFddY5jZlCl0GrpB7eodl31Hi3mknwBIV4lk1aWFDODVFmpoNOvBRIsL9euqaXWVr6AkOpDiUAoXduJvgd6Qhkmvp+iwvCAIhG2BWQTyfngXrIcKYHWCm2aMydr3ucEkw4qRQ9YbIAoYFoISn4cAhiUuY0SIMpyV6gEMaWiHhS+QvD4J+oiJ3xb6LnnBQhd47S8KsU4PgFaltXDvGCVJqgSSvUiaruxrIC0RMYu41F5AUJRaFhlLTWd8aviYPY+lUhN0oOqn3wHB03rtsjqygeQv6aaQ9UhMrchvbCs/5XKHWQCq15QvXsxDFoCSh6AIKrSsh+hMFQcosbJRSpkZSbLgVRhkOrZWyK6mgdEFboUU41S17i0CkKQyYBStOYDUzmspkBZwYOlvnlWkQrfMhTBBs9oHhD0hoi3x7JGrK7G6p2kia5QmQsREF0ofwBJqyOFLkLqt8w665mD0iwg5OhqrUEcOi2RBxhYW5+vURBKLxU1IwAkRGEou2bxsC0gTzOv1prCj0CB32t5wWIuZvabNQDhP2rpVroLAUjgttQeMPMM+WY4RGBAPHVxCLV9qaSM85tMNNHGAwDovRXiYGlNRLpi8xk9k6mSbwYQJUsLBELqwUSlb9asnEQFdFPo05i60KnxsvoyblIFvIHSXnZr/YDAHYxYv/qN3hJAyszNJQwTOg91Ys94NcpUxVWGGSr1AqLKp3td3lLTF0Apu2gTLsE4kLPJchfq3ICzmWGWY32AoGgHbulUOMSvZrBK0f8yvvff83/DOrn9CLifWQScMjlylfd64tr6APGNA/Ce6QIHcfAbqgxtSGzRtU5NN5UgQfwLJ3TdFh8lAPDwEfUAQgc4NrhA0Vh1E63DDJWC3x/FhGw17j9JbaM+W9O8biUgKtCUeUtSNKD4+o5NTNyiRKEuUYsXh/Wrpmbnaa12mqP+Kg9QquUQYkuhvyEr36SFhQ8Po3kr87MOMACNd2Eg8D5+6W++AxDwyIBTqgcEbzkECd0C9Zpmrds5g1tVLEq8iwZ2asiJVF2nd1dRDi14XXWAqFGlvGQlJahla1NBPt6LDW/9IvXr2nNrkzT1Xgmw6gCRIvcL06fVnoN4WLWtX8ERtvQydElofsmiMClEj0ksy+v/FhAmnfA1FDsSGDhqTStQhfwJzWvlnqY5N42k/wIT+NI+DJkPYgAAAABJRU5ErkJggg==",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAFgZJREFUeF7tXQlwXOV9/71zD61Wp2U7adNymsPBt2XZlg+wjGVjcwRoEkqSQoEQpmmbSdN2Oj3SaZt0mkJDCqXN0E6YpCkwBQoBaoyNwbbsAMYGgznClYaZTuLYlrT323d0fv9vVwWC0bVv923rN+xYSN879v97//v4tCAIApw8IkMBrRkA6VtwHjRNQ4AAvu/DNC3E4nHs2L03MoSs1YNEHpCVixfAD3xo0OADCHwPumbCjJkwDAOaZkDTdVgEKRFHW3sbErEk/vHOO2tFo7peJ/KArO5dBD9QnCGfIIBpmNB1A4Gmye8CaDB0A6l0Cul0GxKJBGKxOFpTSVAi33zr39eVqNO5WaQB2bL+AjjlMorFPMplVxE/UKLLNE3hjlLZkd/zSLWkkEq3oqt7Bjo72qFpOjQNsONxuI6Lb9xyy3RoVZdzIw3Ipy+/BMViEcVCAU7ZRdktAwHgkWM8H45TRrlcFq7hkUgk0dHVgRkzetDV2Sm/s21L9A/XFnI5+Brw7Tv/pS7EncpNIg3INVd9EqWSg6JTRJkELRSEU8quC8/zkc/nUXIcEUuGaaI1lcLMWTPR3d2Dzq4OmJqm9IxhCBcNHz8Ow7KhAfjW7f8wFXqFfk5kAbnpumtAeVPIF5DL5QSMYqkoQFCMkTOy2az8S31CwqfTrfjoR38JM2fPRDLZAi0AdB0olUrQAg26ZcL1PDilEjzPxR3f/ufQCTzZG0QWkC9+4Qb5LiR4ZjSLUqmIfKEgADmOg5JTQiFfhO97ADSYpoHW1jROOfUU9MyahZhtouy40E0DlmEIAKZlI5vJiAgMAh/FQh7f+f69k6VZqOsjC8jvfem34bsevMDHsaNHkc8X8OZbbyOXz+P48WG0JJPIZDOY2d0N3TDQ0tKC9vY29PTMQteMLqRb08gX8jhw8CCO/OwIuru7kcmMYvHC+SgU8gjKrojDbGYEDz3+ZKhEnszFIwvI73/5d+V7UEQdOXIEuUwWhw4fxnU3fF50hq7r+Lub/xbpVErEFQHp6aHu6EIinkB3TzcO7N+P9Rsvgud5okO+e9ddWLJoPvLZLEqFPBynJNzi+T627do3GbqFtjaSgFzzuath6aboEE0HRoZHhCtyuSwuufzKMWL8zV9/HTNndAsgqZZWdHZ3orOjE/FkAu3pdjx/6AVcOLhRAOHnjttuQ++ShXAdR7jEoy5ySvADuRW27f5haISe6IUjCcgnL/+EmKs0Zz3XQyaTxejIcfz4nXfwh3/0x3BdV77f1/7yL9DR1gbbtoVDWlIp9MzogRWz0dHejlRLC7pmzpL11EX33fNv+OisWYozikVoATmHXg0jAL6gsmPo6YnSLpR1kQTksi2bQfePFhGJOTqaEUuJytwVv8PH0eMjmNHVKW++ZVviFNoxGzNnzUYymRQdk2xpEaX/9ts/RiqZwOjIKNyyIz5J4JeFQ3gPmsH0bUzdRKABTww1jlMiCchFF64Xq4hgEIiq/8HfUaeodxpwXUVM+iCWbcO2LKTb2tDZ0SEhlHgijrLroVQoiIXmlIryoVOpawzH0AR2oGuQOJmYz7qBbbv2hPL2T+SikQRk0/p14vz5rotCsShvtHCHWxYRU1X2npi8gGHoYvpalgU7FkMiHkdra2uFQwLRE6ZlCge4nuIMmr3w/bH7aIYuwPLY+sSuidAulDWRBOTSTYPigRMAeuOO48J9V+jEJadUg42VOJZ464Yh4otxLtuyEY/HBSS++ZbFgKQugFEcJmIx4RYC7nveWHyMzPfw40+EQuyJXDRygFy6eRNVLEpFB16ZyteRGFapVIZTLiklHDDyG4iPQqX/7kOF5FXIhJxj6BRnFmw7JuBYMQttra1ob+tAoZCBW6YFRq7xoBmMHgf4j0cfmwjtQlkTOUAu3rQBgQeUnILoECrtfC4vHELOODY8inRrC975758KJ5hi8iaFOMdHRtDd2YGf/vwoAj/A7FkzhcNy+QLa0mnRMR/5yGyk02nEbBu6oSMWj8En93keaP/eff8DoRB6oheNHCCXbdooeY58PodisYBSsSRgUJV7rotMLocvfeUPxGwVC8tSIoocwYMOIH9PEVb1P6rE+PrX/gpzTj8N8URCTGL6LrTMqIuo2Kmdvvv9eyZKu1DWRQ6QSzYN0ilALldAoZhHsVAUp42ixPcCjGRH8Ttf/sqY9029QDBUfkQTf4OfqjdfBYfUu/1bt6KrqxPxWAypVKuIsXicn7jol+98719DIfJkLho5QC7euEHM2WKeEd6iKHaaunyLSWQ6i9fccCNisZh8T4LAgyDwZxK2Kuq4vlrDQc655eZvYPaMHiTooySTyiqzbfn33gaLqipokQOED3bRhvUoZPPIF/NwHTpvrhDbI5dUTN3jwyPi1P3JV/9cFUAEgZjG5BSCw+Orf/anmD1jhuTch0dGJYtI4ieTCRFbMSuGR7Ztm8wLHPraSAKybs1q5HMZSUqJP+IxrKFoQZNVgy5g0MoiMO3ptJjBXELio8JJDMlbli16hYxkGiyEiElBBMXczt2NcwBPhGwkAVm5dIkkowiEpG39QLJ+hq7y6cyV828ERRw8aKJTdPm74haCIz5IxQyuSDbEY3GJdT21J5olRJEEhG/P/HPPFmK7ri+EFufONGCYhgQByT3MHFK/KM5Rh/jx1B0CiA07Zom5KwUPuibcEUXOiLQO4cN9/Kw5AgjrF+hrMLRB34Hiiv954pcoDqFYk4XUJeI4qqqU6oemLbll5+6h0HXAdG8QWQ7hFzv3zDNE9qtCOBPJRFLectK+UCyI2FL1WvS2FafQ2RNPXTcQizF8kkQimcB/Pr59urSqy/mRBoQUWPjxuUJg5kcogkhw6gs6hsxhKBNXgUFgCISAAkjJaSIRw1P7nqkLMWtxk8gDUv2SK3uXiAgi8ZkPYb5dEk+eigDrFcuKSBAOrqXuefr5F2tBp7pdo2kAIUVWLF08Zt6KlSXcoeJdFGU6U77UMoYG27Sx98DzdSNkrW7UVIDwSy9btFBAUJ65il2JPocKv9Oa2n/opVrRp+7XaQpAVi1fJjEt5sJJfIos6g+CIAZvJTDI+iuaxbZpYmh/83GHmO9R7g+5YHV/pagtQDaXU36HpG3pl6g4lnxEgTMpxaivCjbuefZg3d/uWtwwcoBs2bRBwu3UCwy9MwRPf4NWFQvbmN1TMRKatjoMTRerimaxfCwTMcuUJTv2PVsLGtX1GpEBZPPgevEzyqwKKTlSg1UsqSoTVoQwF0Lv3GWRg4RLlLQiV9D7Ng1dykkJCkUWQyaMGj/RRCZvJETWwNpV0oBDwpLQrDIhhzDXXU0wUW+w6t3zGWhURQ7kjkALJCzC88kV9FXILbS2qjl3nre7icRXQzlkYHW/ED0WMxG4PhyXYHgSZmdQUQGiuqaovyV4KEqdXVS0qACrUi1CB5BKnczDSBYB4YfX47H72QN1FT1TvVnDAFnd14uWlqQqMHA9KdVhckm8bynP8VAWYgaKyFogbz45g6atYWiiP6jEGSKJmQYCnVFgJrF8KXhTAUhP9ShK5xUwtD/awDQMkHWrV4q8Z22UhNpdV4XWGUonKJ6HskskFIGpMA689LK8eMsXzVP6wlBWlaRvKyawyoeostCy50v1Cruv2CzCChTX9wTQoWf2T/UlDvW8hgCyrn+F6noylGctCttVeXByhMe3XOJUTEIFeO7Fw+8hAhtBGYqX4gZewdSl9JCA8goUZ6ZloFRyUaxkHAOQ+1QvCaO/uqZj25ONK4g7Eap1B2TTwFoUi5X6KqkkYQKKYoWGKsUSs4Eu9j73wgnfxHUresUIEJ+wknni2XKuZAdV/oRgqoI7pUfIGQTLYN8h8yWmhYe2/j9O4V668ULpmmVHLHMYEovyXSnB8Vyas+QafVynbnDVcoldsVWhmppiHoTHIzv3YP2qPhGFpm2L6OOfaAjomgrJc+gAQ5CmZSGfy+EHWxtXGPf+t66uHMIiOBYilCuNmoxJBZ6yqAL6FxqLoA0M7f9wL3twzQrFHZWhIFKXqxtSt/vIDpUnH1y7UsL19O4lxesHkqRicUO1hks6ex1HdNbW7TtC1Q0TvXjdAGF5T7UyhJUkSt4HEkYvl4uV1KsSK3vGMVHXrViqQia0uGgOG7qcTyvtkR3v1QuDa9cIJ9FRZDE1z3EdKnZNspDkUvo9jutgZwOr3quA1QUQVrOzKC0IPHH8KEKYs9C0QJo52dFEYtLveOrp58Z9mdYsW6SqSKRaXWUISXRaXT/Y/tQHnr9x4HxVSiRZRmUskBurJUQ0IihOdw81trUtdEDW9q9AMtGCWNwWIrKombKbesO0LWnmz4wMi1U10e6lVb0LJbdeLf9khJfeOvXIY7s+PG++blW/mNGSZdQ0aVNQQwicsUr4gy82LnwfPiAr+5BqTUs6VTxrDomJ2cIxvl+WZs67H3hoXK5494JVSxeOTQdSlnIgIgm6gSfH6X7qX7ZU9E01tEIwJXhZYPCyJD+zmvHQYeXz1PsIH5AVy9GSakFra5so1Ur6QuppTVPDbf80+eb9/iXkEFVloup5WdnIqK+BXU+PH+FdvniRePIUeRSf2WxGApq0xKjkWabKjqwXXnqv/1MPcEIHZM2KPqml5RwSjk6ihcNyHvoD37z9jil9xzXLFiu/goUNASc7uNB1U5JTEyloWDRvrjjzJDz73iWQWWkkrZYQ8YU59PIrU3q+6ZwUOiB8uE3rB2RkUiqdlvgVRyfd/M1bp/zcAyt6VdOOpuJc9GGYsWJjzvZdE6tIPO+cs+Q8hvsppt59kOsoWl95440pP+NUT6wLIHy4T115hZRxplpT0x78sm7lMon8Vic9VCPALalWPLp954RpceYpv/oLYPBkOo4vv/ajCV+nlgvrBkgtH3qgf6kaYMaYlxi+EJ+ira0L9zw4OQOBz3Xqx375PY/35n/9pJaPO6lrNSUg6/v7KjEset+qe8qy4zAsC3ffP3lAJkWxkBc3JSCDq5eLlWRUvHXdtCAf3cR9Dz0cMsnCvXxTArJhdV8lEGkICGxV0A1LwiIPPPxouBQL+epNCchA/zLpFaEpzZgJfQnaSSwpfeSxx0MmWbiXb0pALly1XHXf0oGzbIlBea7KLD66rTmq3E8Ea1MCctG688UrpGeuQiAB9Epv4WPbGzeFoRa805SAbFy3Vvx0FlWXHQ86U7jQJPexfecHR3trQax6XKMpATl/1XLE7BgMw1Q9iNQjvg+nVMaTe6LXyDkZIJsSEJYQMdkkPSDMaZjMpfgSGHxi1+7JfP/IrW1KQJbMP09Vj9gxtKSSUl4qE32CAE/uiX4f4Ye9BU0JyLxzzlHFEbqOVCoN02aSSZX47N7b2IzfdFmuKQE5+/TTxmadcIwf66zILQyh7BqaWLR3uoQL6/ymBOS0X/nY2AwTEoY+CXMbHOu3e99JDgnrZTnhdd8fna0ubGtrx4FDh+r+PLW8YVNyyIkAIae8+sabtaRP3a/VdICcc+bpUop6oqORuYxaoNdUgCyZP0/AyOVzJwGpBfrTuYbyPSCzEWWDF0fNxHr3QT/krZ+8M53bNPzcpuAQAUNVVstkuVJBjXf9oOOkyKrDO7V0/nmSQ2epIutw2WJQHYL5/tufBCRkQHplD0NdvHKW+tD5Y9yKG7pkM1nFNZXtKPhzs1takRZZ5AwZTMb8ucGpoyzRScKOx6RakTPhWc/Lgm1OeeDQTAL3o7feDvk1Ce/ykQWEG0oyaChjXpmMYveTaUgve7qtHZqlJgNRn5BbuC7HPak4wL9YxCuv17/IrRYwRRaQFYsXyPeTtmZWKFYKqjkAuaOrW4rZEqkUCjluqefIVhQcalbdCaERdbn/ZwFZsWSBNIOyIpENNdLKGVBsqZa0nXvVpis33XijDEIulko4+rMjGMmMCjDSc1Iuo5FtBVMFJ3Ic0r90sWqFlrFLqsuK7WjV/kPqiKFKh9X1134OdiwhoLG/g1sjHT12FPlcVuakUIy9+MqrU6VNQ86LFCArlyyCF6hpPxrZg64Hi6llgLKaTrrvwHu7c794040yOyvP8U3klJ8fld3bHPopuo79B5trTFOkAOlbtEA14pD40vtBziDDaPAD7xfAqL7Cv/WFzyMzmkE2l8Xw8RGxvmiR0VfhD88eaJ5RTZEBpG/hfLFvSUi1ta0SV2QSWll7P2Qg2bVXXyXztLK5/NgYJ57P8Io0fGo69j4zfiNPQ2TU+24aCUD6Fi6QWSbsYJKm/4oSp6jiLuoUYfsOfnieY8vGDSKySg6H1lR2lpZ2aA96AAydBGRi7xt7/hgOoX4QvhCFzilArtqqO/Cx/9DEWssGL1gj801kLAfP51QhR7WqcWjN3mfH7/Cd2FOHt6rhHDKwZpUSLbSotEA8cM4koaKm41cdODMREpy/sk/mpFRnMIqVVqlsJMBkvB9GXJ80FJCBNf1qqH6lv49EZzcsd9OhHzEZMKqA9fey/1DpIinCrkygk1mNWoCnxxF9EwE+zDUNA2TjwFqZk8WddMrcH0QUuFbZTJLDkX0cPDw1H6J3wTyhGa9RDYYJ6NRPGrD/hcb1oY8HZkMA+cTmDSgU1H60MsNdGjcJiiZ7grDG6vmXpwYGv/DCueeKmSz1vxpNZjX2Sc0v5aQgLbKzfRsCyBVbNkpf+Egmgxx3YJNRfkrGk3aHXn1tvBdp3L/PO3uOrGF1PA96+Gq8rILlucowtHEvVOcFdQfk2s9cJSnYXDaH48eOya5rMha2Mmn0pdderxkJzjt7TmV3HtnkQobUKLHF2fBGJPVJXQG5/jc+IzEnyvbhY8MYGRkWh44ZwKryfeWNt2oGyNw5Z47ttsN2N/YkEhlb+hF17IvgbPi6AXL9tZ+FL3tKcddOR2JPo6MjGB3JVHbKcfHy67WvqTr3jNNl2BmnPNAXYU8ip9HRiOB836jN9a0bINd99tOqZaDsSbicO3AOD4/IwGT6Hi+F1Kh/1mmnqtmMpkxnlDZq7mPIKUAxy0Lgudj6VHQq5usCyG9e/SkRHRz9KqlWApLLYWQkK1bWoWlYVBORb+eccboAwpgW56wkW5IyXCZuk1M0PLg1Oo2ioQPy61dcNrYT52hl6g71SK6QRz7PPc4dvBAyIARt7pw5MguFCp3du5yCzeQW/5/hla0RaYULFZBfu3SLmJiy36wXVPa35YD9oszq5U7QB+o0LGzuWXPkxSCXVHduq24aVt167/EIjI0NGZDN4ilzCmmxxGpD1lSV1VZF5TKeOXjiUbATEUWTXVPdz4o97mZlPyvOjmdFC8dFPRqBQZihAXLZ5kExL5ksouJmaLxY2YaCc3SfP1z/WVQEsHfhgspObwFM3RDu5Vas9FRaUgncfd+Dk8W5putDA+TKiy8SLuC0NhZI88O6XJmj6/o4/HrtHMDJUISbi3GE3/9ux2rK/urUL7Zp4K67/30yl6v52tAAuXzThcgVCjIgrFAoic7gYHyKqzD8jclQZsP5q6U0lc4hzWDuHM2NKg3LwPfuvX8yl6r52v8B2e3pibMei0gAAAAASUVORK5CYII=",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAG6pJREFUeF7tnXl0leW56H/fsPf+9jwkISEhBHDoaYtVUWi1tfWoR2UKoCBIVERQCASsVtEePT3n3tseRD22vaXKHIiAgnWmONxz6+2AQwvFWsEBMCSEQLL3zp7Hb7p37x7uas/qgYAk2Vmr+6+slXf43uf3Pu/8PI9gmqbJ334lIwFhMADZuehOWkMhLr3nDvb8aD0jy6pQxSz1KzeWjCDP1oeUPJCVN9+A2+JCkvNU3jCe9zf/jIDDjVeyYLPpdISi2N1lGHqO4fXjeX/7DipcMnPWPHO2ZNSv5ZQ8kB9On4HDlkc0ZGpnXMfh7TuJa1DpdZFJJ8moAg5BwBAEam8ez9EtO4hJOpVOD9lkirgucv/zL/SrUD9PZSUN5M1XWxg28jzSiRDdoQQyBmWBIWiGjsfr5nB7G3XVI0mk4/QkYpDN4q8qx8jLuH1+jrUfoHL4eWR6eoglwlxX3/B5ZNUveUsayKqGaXzr3gc4uGE9kk0jn84DMp2xGF67l3QqyriHHuLI+rUYmoxpJhENgyPxNIpS0KAE33r4H/lsw3rkrIaqaYimwOS1pTv3lDaQWfWMbVzM/ubN+BwWDoSj+Owugvk0Zl7AJ6lc3NjIgZZNuEQLn6QTVNnsdCfzyGIOh2BlzMI5fNSyFZ/FyqF4DK/TSyieZtn25/qlx59uJSULZPWsSSgON2OXNvHr7z+KI+DiaCKDX8wTydnw2cBmU7hs6RLeevwRbDY30VQcBzpRVcIlC3hsTr6ybBFvP7Icj+SlM5/Do6tEAY8ks+iZ509XXn2evmSBvL/3bbo7D1NdN4pMPEykO4osyzg9TgSLic0xlK6jH1FZeS6pXIR4LIpogM/hxRREXP4y2toPUTuyjmw8TCgWB82g3FUBNgO7o4zOYwe5dnxpzSslC+TlBbcjOqzImokhiRwNHuPn8Tx6azuSJJLJ5/G7nMy5bByyBJ91hrmgaQ4f/XgdtUMDpFSTp3+7h6/VjeDlP/4RU9XxfGEU08oC1FWUk9bTOCwuTNNgwo/X9nnP720FJQvkpfm3IgsmRzNJFJsT3TBoPthKPBqnta2j2L6rRw3n6i+ej9OqIAkGldMn8uHTL1DhduGToeW9veyOJOnp6Smmn3DNN7nEaqfKIeJWFGRT5nikB8Xh4pYNT/dWZn2ariSBPHbTDCpcdrRUjKBuUFZY8Aoqr6TS7N//WVEgXreDYZh860tfwGMxQTUYMf0GOl5+gaguMsShsO4X79FuQjwexePxccmF53GNWyGZVaj2WImnk6RFAacho5lZmrbt6FNh96bwkgSye9erOL0VtB1spWb4CBKZEPGeGMsf+ylt7ceKAq6tqWZ4zVC+v+L7ZONRoqEeDEHHW1mBZFJcEKz418fZ99GnxBLpYp5pUyewaF4DGgYupYrjXfupHvZFkpEQsXgIDZPrJ8/pjdz6LE1JAll5Uz1+h5t4MsE3H/4nDhX2IaZA3syx5Te/41A4zKhAGdeddy7jHnyAzi3rkPOQFVREXaIjEsflspCM5vh5NsuodILD4Qi3XjEWUVMJhmJYHQFy6RRXfu9+WtcV5hAJLZ8hZ4hMXzNw+5SSBPLYTfUIFglPXufie5ewv3kjZaLMJz0xfB4P0UwU3RRwiCJj5s3jwMbN+B0OPon2EHA56U7kUcjhNEQuXrKYjzZtxiPpHEjkCCgW4rEcyAZuXeeCxYv5ZNMGHE4Hn3WHqfR5mbN24OaT0gQyexoeBBx2BxctWcqu5Y9gd9o5lktSLsiEVAG/RcVmURjznXvY9d8ewep2E02ncZkGKRGs6LgUD+PubuKXyx/FZXcQUpPYNciYOnaLFZuiMLbpHn69Yjkuu5WOVBq3YdD0s1f7bEg6VcElCWTPO/8Lm9VNR/tBRowYQSQTIRFOoSPg9XlAEvHaPHQc/ZShw75MMhEkkeopTuw+bzmCaWCrCHD8SOGs61xiseNEkwkkVcMfCGBoIrYKH8cPtVI9/FziyRDpaARVg0B5BV+94tpTya3P/l9yQNbMmszw6mEkkyk8FhtZWUAUTdqCES5ePIcPVq6jtqwSQ00jiQqCaaLKEkeC3YxZsIh9Tz5JbWUF+VwGyaqgiyaiINHR2ckli+7md6t+wrBCfsNAlkT0Qvm6zpFwjLFL5/HuyvU0bflZnwn8VAWXHJAnGqZT5lTwW01MXaAznsFusyPLEtVTJvCDZQ8h6ALlXhdm3iSjZwln8sVDw8ov/x3tH/4RRZI5b0iAw8E4Vskko5rYrCLKOSO43OKixmXB6VYQDZFj8SBuixtVFhl2wwSuGeCde8kBWXPLjSQ0kQqPTDqeJmGI2EUBi5FnRMON/PPS75HxuIsdrbBBDAQCxT3JiV9hiXtin3LkaGfxb00zium+/IXhTPJ7yWoyFR4ribhOVNbxawKCaFJz07VMmt54qk7cp/8vOSDv/eqN4pmU0+um/XgrQyvPJZ2Nk+gKAyYbt/+M19/438V9yJ8DObF7L0irIPzC7lyWxWK6ApjCxnBkXTUr/vvDxXJcnjLaOz5hRN35JMJREokgV9Xf1qfC7k3hJQfkpUVzCEbjWB0ecpkEl99/L63rmzElASGTYfXbu/kwkSu27cQGsaAVJ7TkBKQ/b/yJdOVqnsarLiMYSuHwOchGElz+4D/S1tzMpJWreiOvPk9TckAKLX505jQEBDxCnkubmvhg3WY8dpODkTyVisiW335AKBnnnICXX7R3/n8tOKENhSFqZN0wyvNpPOf/HdkjHThMk3Hnn88Qn0J3JIMggl+EO599qc+FfDoVlCSQFQ0z8KsaNp+bi5YuYtf3f4DT4S5O8D7RIGGYxfMrlyPA9q5ugvv243E7iaUyWCWRdD6PIlmYf/VXGbvoXt5a8T+KDyWC6Sxui0DcALuUp2nrwO03/itIJQnkvbdfxe6q5Gj7R9QOPY9UtodoPIquCVSWl5FTVTyuocX7jKrhw0lGe4iHEgiyQLnfjYaM0x6gu/NTqupGEYknSYTDxaWuLxDAJsIlV1x/Oh2339KWJJBC619pnINFEhFFG7qc53BXN5cubmTPT1YzbGg5QtxEclswdBWLbOVAd5BxjQvZ+6PVVFeWoZHBZlUQVRHDyHMoGuOyBfN4d9VqFm99pd8EfLoVlSyQHYvmkRfzdAdjWFx+FDNLxY2T2duyjSq7D7dLxJozOZKI4lY86BaTionj+ejpFygvs+GxSIgCHD8exRIoQ8yb3L6x5XTl0+/pSxZIQRLrbp5CBBO3KIJuUndjPW3Pv0JUNajx+sgk0vQUjlHkHELWwoiG6+h49hXikgWf3YGWyBHRczgVC01bBsfbrJIGUoDywe53URMhQtEIgg18rnIMwUBx++hqa2X4qPNJxILFO3VBLBwoViBZNayeMkKHD1I18ly+NPryfu/pZ1phyQM50bA3l84laWiYpkhXOIXiUcjHo1z+0D/TsXYdiCp6UsWQRTpiSZxuG8lomqbtpbWsPRWoQQOk0JDHZ0+jwu6iJ56gMEG4JZ0vNS7g4w1bqXDY2B+OUmOzciyTQ0Divu0Dd0h4KsEPqmXvyRqzauZUYugETAmH4uUrdzfyy+XLsTucRDMqLovKgq2DSyv+vL2DQkN2/2oHwUgSm5jH7apAFHRkTwVdRw9SW1tHNJYgnQpDTsJX7kMVDb729Yln2kkHNF9JA9l5z13IeY08Ap3hbi5obOQPa56irrKaTCaJLDuQLRqoAh3BHi5ZtJDdT61iRNUQrvvhmgEV7JlWXnJA/m3mVMoVOx5FQbcYdHVHcbt9mCpUTbue/Zu34/c5CFgkdEOgK9aD3eNC0ySG3XAdf2x5kTKnizKXRP3K5jOVy4DlKxkgaxumMmzmBDqefpO4rFOh2EimsqQsEoXDEPIi1bPr6XhuBwnVoMrnIpNJkzFUHIIMKgxrmEzn0y8Qs4n4FTdaLMaCAbwfPxOqAw7k473vEskEiYZ7sCDh8HixYMPu9dDZfoiqmvPJZHqIhLsQTRvuIQEEM4viqqT7s1ZqRtaRiCaIpLuxqjruwFAMI4vbHaCtvY3hI0cy+sLLzkQ2A5JnQIGsbJjKN+69j6Mtm7CoGnHTxGpAZzyM3eEnlYxz1f0P0dqyBtGUSOgpBMNKuCeI7PWhpZKMW3YfnRs2Igkq+VyenC4TSsZQ3G7UnhhXPPwg7WvXcu1PB8fwNWBAHp81FQcyYxvnsX/9FrxOiQOhOEPdLroyKdAFvKbJBUsa2bexBY9VoC2eImB1EMqkiu9+7brIhfcsYP+G9QyxOTnYFcHvd3EskULBxGZIjF18O/vWbyXgkDgUiXLPttI7ci+JZe9TsybhUbyM+U4jby1/FIfdS3cyjUdWSRsSiqjilrxcdE8jux55HJvTwdwNW4vfvmLmZLyijOJ0MK7pHt5a8X18ToUjqRweVSMjizh0AY/bzYVLGnlneeHdlofueAqfTSCS11i2vTRPfAdEQ97+9U4C7gCftX7K8BFfIJUKkgon0EQdv6cMQTSw+bwcP3yIqrovc8FXLv2L8fx3v3kNu+Km+2gbleeMIh3pIRGOFZfH5WU+tMJto7+co62fUFs7kmTBBrE7giEbVLj85AUTr7eSL130l+UOyKTxnyrtdyCrGiYxwltJXiiYC0rF1x42TeDTcIixd85l70/XUju8kolP/Nc2G2823UlW15DtNuScSV4Q6QwFGbP0dnY/uY5h3nLyuopilZEEE8O0cDgU5KLGO/jwx+uorK4kn9ewiiL1T5aObUiBTb8C+fcXn2HvtueodFnxilZUySBcOAh0Kug5k4qZE/jjxpd44LkXT9pZW267BbdLLt67FyyjLE4FQRcZOuV6/qG+gY133EzAYscUNI6G0igeCcm0MrR+Inue20at3YlLsaHrJqFkNws2D7wZwokG9yuQHS80c+yFl4mbOj7Jg5pLkZEtONUsuigwYvZ4Dm1+nabtL58UyBPTZ1AZcJBO9hA1LPgMozjc1dw4ifoZC4p5N827mWwqQ1wAj6Fj6jKjbpnA4Wd/TkISGWJ3kk4liBsCDgQWbyuN+5J+A7Lz5S3Ipo7XV4FokXHa3HQca6O65hxysR6CyWNYZXD6hvDVy8afFMh7v/45DtcQjrbtp3bUOaSiCRKJKIKmc9WUW/4i777du0hk0sQSnUgoOOxuTMHE4y/jSPshqmtGoiXi9KQjXDv+5gGfRvoFyGtL56FjYmQNkAU6e4LYHR4y6RzfWPZdjm5+Ch0ruXSGaatObZvx5KwbUewO8pkMV9y/jLYtG5DRiacNpq9a/1eF+vrShSTVDIop0xGP4rA6SWVSXPHwAxxdvx5DVVF1nfpVmwYUSp8D+e1vXi3abzgEJ63xKEM8VjqiOSyGhlORGXPnQj7d0oLPFJi0bnOvhFEYsgzJwCXDmMV38tGGLTgFg4PxNA9uO/n8s/6OmUX7EE0Ucds0Lpi3gENbnyYgOfkwGGGYV+GW/1he9+pjznKiPgfy4d53+M2/Po7DayMUzWK1GWR0AbdhYlPsfG1pE1+89Oun1axHZk7DYxq47E7G3H0vu5b/Cxa7ly49zne3nHzjt3bWNKK6jrtgsGNxMubbS3nrsUdxK3Y6sikqMAkbIg9sG5h9St8D+cO7pFJxYrFjGDkb/nI3ki7h9PtoPXSICdNO3078vXfexGMPcPTYISora0llYqR6IhimWVxlner33i9fx+v20H68jeraWhI9aRKRCKIJHr8PyWpgcbj5ykXfOFVRZ/3/fQ7kjXvnYeRE2sLdXLRkIXt+tI4R1R40XWTKyr8+3p+qlTvuvgtdyyDb7Eg5E1WUON7TzZeaFvL1y05tbLOjaR6mnsVid2HkwDTzHI0nuPCuuexds4q6siHoKY1J6/p/PulzIAXhtsyZhWmVqJ5azwdbthJw+pi79swbu/72W6i02tAFjSOJHtxKAMHQqJk6gaunnlpDCt+0Y/FcTDSO9yRw2G2gW/BPH8++Z58n4LRSKUtMenLLqfrGWf9/vwApfHVh7K68cSLHXn6FBZs/3/i8vKGeasWPmowRQcZtyVO4MqmbNZnxU+/stZDW3DSZhCTj1QxMdOpmTeXAszuIWyS+u3Vg/KD0G5BeS6kXCd97aydK+RDCn31C2TnnoiV66OqKYZV0rpncOw3582refes1Itk4BfeTPq+Py78+cO9+ByWQtdMnIbm9aJkM33zwXtqb12NIoGbyTH6q/4eZXvShXicZlEAenT0VybSgiDrjmuaxf9UzlLlFPgwnefCZ0jgC6TWB/5RwUAJ5ZMZ0/IKO3etkTFMT76x4DNluJ5hOs+xvQM60L5x5vt/9eicWl4/QsYMMLdy5xyNEe8IIhsjV02afecElkHNQasgrixsxc2nsbis51UCwShw+HuaypvlccvnJDyZLQOYn/YRBCaR5/m0EBB3DVOiOhVHs7qKDgBHT/4GrJg2sN5/PC3xQAlneMJkqyV303hPXwSuoaKZI7c2TmXhD7/chn1d4fZF/UALZtetNPE4/R1o/puacL5KJHiOejGAIVq4fP6sv5NRvZQ5KIKtnTEFx+kikU1z9wH0c2bAGTZLIGypTB7k/+EEJ5PGZ9SAJKIbB2EVL+LilhYBVYn9XmgeeL01/vL1VsUEJ5NEZk/HIJi6bnwvvW/wnf1qyg65simXbTn4f31vBDFS6QQnkvV/txO3wc7jjMLXnDicejJFJRjEMiWunzBwoWZ6VegclkDeWNKKaCRAsFHxkCLLIkaMRxi6cyyV/PzgNdU7QHJRAmu+Yjc8mIkgSnV3hotsN3ZQYccMkrpr6t1XWWVHV0ynkiRun4i2zY0TzhHSNCouMqeWomTWVCdPnn05RJZd20GnInv/zKppFwOEoI3j8MGVVo0img6R7wsWgLtdNGnifV5+H8qACsuOu24o+Eo/FYljsCrlkjr9/aBmtq9YhWSzkMmnqV5e++4yTARs0QF6Y38BnmQwVdiehTJJ8VqdMNhi9eAkHmjfjtZl8Gikse0/+Luvz9N7+yDsogKybOQlZ8dKtpvFgkjIlXKqKzeXj4sJ9yBMrcMs2ulWVe57528awzzvO7l/uJBzrQRAk/H4vqqHj9FRwtP1Tqkd9ES0WoiccBUnj2om39vn39GUFJa8hry9agCDpHAwe5+IlS/ngJ2sYPqScvJrCarGDoaIJVtq7uxjbNJ/frWqmacvAvBg5G6BKGshLd95BdzKGzW1HMg2qJ0xgz3PPUyY78LttGBh0BQv+spyIgkigaF/yPMsGoY+Tkt8YbryzgWQkRsYU8YkieavBiCkTaH/xNZKqwRCXj0wuTlIwceRFLFYYNr2e1mdfIi7ZeHCQziUlqyHv//49urs+pap2JLmeNPFYGEMXcZV7iibSNqeH8LHDVNeeU4z9kQ5G0GQNb3kFpqrxtW9OPhsjSL+XUZJAVs+ox+l2k8zFuXLZgxxufhpNE8jlkghYuGHthqKgnmyYxOUPPEzH6g1IgkCGLGJe4Fgyid1h4/Z1g++NVskBab6rgZ5IHlPM4zANLlq0gI+btxFQrByIBymzerhj05/sSNbeUs+Yxkb2rWvBK4scjCao8tlpT2SR1UKcKYmFA+hY/0zUq6SAPDZjKk7ZJIaJXxVxutxccvcCfrn8MaxeH6F4kge2/eUKav/7u/jFiifwuC2EEllcCPToBoH/Z89ud7u4df3g0pKSAvL6z7dQ5inDlEQcioOurjbKhowshljNhGNcPe2v2wDueec1gscjCIU5xOtHskgodj9dHa2UDz+Hi77y1TPprAOSp2SArJ4xldFLG9m3ahXV3gogh2i1YuQNRNHChJP4Zt9x9wKOhLoZu2Aee/9nM3W1fpJZE7tFQJdMBNVg4iBx1VQSQDbeNRszJ1Ez/Xr+0PIS5X4Jv8WOkBc5kg7jk2zc0rLtpD22eU4DNTdM4Pdbn2OIU6FCtpGX4Xg0jEMpY+6GM7dH6U9VGXAgP2yYjAsRTRUYdvNkjvzsZdKqRLlDIa2mSKki9/fSs+jrz63ns+d3UgiONMThJZvuIaLb8MlmMQjMgkGwYRxwIB/v/g2xbIJoJI6pZfH7qpBFHZvXw/HOo1wzofd35G/ubMHnLi/4XMYbCHD4yGdUV4xCy4SIROLF0EZXTyvts64BBbJ25mTG/tNDdD21CVNSyeSzCIZEMB5F8bi4dc3pr5B2LJzL4VghzLeDZLJgP/IgHZtWgy6S1jSmriptv1kDBmTFrMISF8bOu4uPtj5DuSBxIBzB4/QS1hJIhsx3nj2zo/RHGqZhagIViFxw93w+XrcJjyJyKJig0uXn1ubSnU8GBMijN9bjkQScLh8XfXsRb69Yjt3mpCuTxi6IRU8/932O91WPz56MXZXxemyMXvpt3v3B4yg+J8FwFJdFJKPDvadwcNOfE/mf1zUgQHbver0Yq/ZYRzs11eeQzHQTCYWRTSvuchfjrvj851Dv732XzrZWqkecSzYWIhkJokrgLwuga/D1b04aKJmftN5+B7L6pumMHOYnkzWwKAIFKZkWlcPHg4y7ayFjrzx776p2LJqLIMpIpsaRUJTRdy/kw5VPUVfl/w+/KKU3dPUrkJ07W9jX/DxD3F5ctkI8YIFgVxyr3Y4p6dRNn8Q1Z/HG7/mFt9EdjeOxOVFtOtXTprBn8wvUWBz4nTqTf9o73yr9qUr9BmTl9CmMunUK7dt2ktA1yhUXuXSUqKRQLqig6cx/7uw7Evu3hmnYdQEDkRE3TeDY9pcIqyJVThtpVWPRM6V1u9hvQN7YuRndEPH5vUgYuJ1+OlvbGDbyXJLxIJf20Zj+4e53SKTCJKKF0DBWfAEPsqHj8Pg4fLyN2trzGT16bH8qwcDPIa8snY+CQDKbx5R1QuEsFo8FNVGIU/g9LrhkXJ8KZEdTI4aQRTU1RCS6wz1YbV5SuQhXfudfGH1p6TjD7HMN2fP2q+xb+xwep8CBYJqASyQSU4sB5R2yypimBXztG31vqPnC4rl81hWjwumgMxlDtIkECvHUFy0u+uu6bc0zfdopelt4nwJpmXcLly5t4u2C/YZNKQZacZsmSQs4RLApTu7op1u95vmzCSVS+IGgZOLTwOFzceniJby1YgV+m5uG5oELbN8vjxz+/bWnKR92HuloiHg0goSAu8xfiE6Eo6yc0aP7957ijVdb8JaXFx1iuu1Ojhw/yIiaLxCPB+mJpxg/aeBfzveZhrwy/3ZEhwVDkrGpeQ5Ho4xpXMjvn3yKGu8QJj05MLFnV82eTLWvhrxeiHNoBdlA0i20h4Nccuc8xl45obejS5+k6zMgLy+8Dd2QCEeiKD4FXZMZNvV69m57kYDdyrz1f3Ib3t+/x26uZ6jDgUeQyIsi4UQau8sOmkr59ClMmDiwniD6DMimubNQ02l6NBsuWUM2DepmTubIizuZv3lgHcQ8NrOeKpeXbDZFUhNxCHl0LNTNvp6J9QNr5/5/AUoItomj9QqBAAAAAElFTkSuQmCC",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAABGFJREFUeF7t20uOEzEQBmCHmRXSPJQlDyGWrDgPJ2DBPeAELDgBtwJGPFZoxMxIrEYEVTSWola6q2z/dlUllQ2v7orzfy7bnRGrzWazSfEyk8DKBcjn1f7A3hzeXLIPMofBzWmnWIcLsgvmCMc2SG13zHWPA5jjAslQhmGOE4RgjKLYBUEvV/uWMYMoxw1isFMCxBiKO5D1u4vt4nN//y/dfrrjnkbS5duztF6v0+3tn/T748389UaWL5sgC/vH+UPAlOy3D1cikJNVSquTR8sgRjrFHUhph7x+/yrd3P1N19fXoo7SPn25A2FbAnGB4vIVIMaOwwESIII1ZcRD4dIwYsnaSUcbQ/m0ZW/J0gZR7A6aCy5B6Fnk9PTRtq3Ozy/Txdnj9P3nr+3v6UUPgfR7+pUeIOlFD4eS55Y49k7XckGHZJDnT5+kr1c/tjgEQM8aL1882/4dAdCf6d/ydeyTvXJ3uO8Qmv0EkB/8cvj0wQglvwiH+unL0pO9AQybIDQqQZfksOlJfPrKHeJhiZqO3d4eUggiOESb/0Jxd4DHC2JkifLRIb27xCiG3T2kF4hhiNwpNpesPLqCzZ3dSxxg2O4QJIoTDB8grTCOMHyB1OwrzjD8gUhRHEL42NRbliunKId7ygoQ9uApu+AIj7o2vzpBQux+Qmedor9k9YJwiqILMgIjwzjpFD2QkRiOusUXSJ7lCEyjHaMDUhroNLzS++fOdwZRxoNIw1wKS1pDctA2hjIWRBokF9JSHbpX+j4GN/zDBJF+52Vwsx8HUjJrWztkN2jk+0qWwMZrxoCgQ+GWrH2hSMfATYbGwLnb+4NIg6CRSsOoASn55lg6Di7din+3AVIaQG+QkslREfrSLfogpRjchi2pJ+1aSa2DAqn9wC0dwoEqn7z6d8hcALUYXKDSupIukdYCdskYkGmIrR+0tUMkG3zrGCuRxoFUDnDvbSiQORglDBpOgCAnCqBWgABCRJYIEGSagFoBAggRWSJAkGkCagUIIERkiQBBpgmoFSCAEJElAgSZJqBWgABCRJYIEGSagFoBAggRWSJAkGkCagUIIERkiQBBpgmo5Q+E+0mf4s8yAB7Ofh7CYVAiAYKYF4IaEowAEQSJuESKESCItAU1AkQQ0qhLSjDymBzvI7ZPWTUYzpctuyC1GM67JEBGLb3C97EJwnWH9H/jOtxL7IFwGLt7RMm1whmqfZktkJqAuXucdYkvkLlwDwjFDkhLqNy9jo7CNkAQgXI1nCxd+iBckCWzm6vlAMU+SEmIHEgJrtJxSxeEC7AEIwfYo+ZAHD0QLriW2czVroEehKIDwgXWgkH39q7fEccmCGIGcyiI9+gAMx5kZFAj3wuEMxaEC6h1qZqGwr2fwS4ZB8KFg8ZweuqyA9JrtmpNhMolbAwIF0ovDIdd0h+Ew+i1VDndT/qCWMFw9GyiC9J7qXLYJf1AuO4YjeFkPwmQaRdpTZSHceiAKH/oxe+6lMf2H8EWCgKIRxuwAAAAAElFTkSuQmCC",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 1,
                  randomFlipHorizontally: !0
              },]
          }},
  {
            info: {
              displayName: "Weird Bob",
              category: "template",
              icon: {               
                imageData: "data:image/png;base64,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"

              }
          },
          action: {
              type: "random-template",
              actions: [{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              },{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              }]
          }},{
            info: {
              displayName: "Furnace",
              category: "template",
              icon: {               
                imageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANYAAACXCAYAAABp56XnAAAAAXNSR0IArs4c6QAAIABJREFUeF7tnXmwbFd13ndPd3i8xxTzT4YSTsVUUhCZCMuS0HsaHpogGOyyKxX/4XJC4kgCSYhJDJKtaEbMgx6SgnFhx1RsRdgCY0PZkgICLAlJCAlhiP+Ii8pQlaoERxLvvntvDyf17b6/x/eOum+fsW/3vX1fvep7u0/vs/fa61vrW2uvvU8jLH5yS+DMV70yWVpaCs9/4QvDT73kJeEzv/e5Ru5GFl/Y1RJYKETO6RWoGo1GELBWV1fD3/mpl4RmuxU++7k/WMgypyx38+ULZcgxu2efdkoySBqh1Qih1emETrsTXvCiF4alzlLo9vvhDz5/z66V58EzTksGg0FoN9vhgQcf3LXjzKEO2166EFAOSV50zllJr9+N32g1GqHV7oTV562EAwdeEI4eXQs/Pvps+PK9X9t1Mj334JlJo9EMzWYjLK8shaSfhD+7975dN84cqjDx0oVwJoroJxe88aLzkrW1tdAfDMJyuxOarWYIjUZYWVmN762vr4ev3L+7gHXOmWcknaWlKISlpeXQ0L9GiAC7+54/WejPGP1ZCCYjsP7lr/xSsrmxGQa9Xuh2N0OSDEK/PwjtdjssL6+E9c310Ov2wvqxY+GBhx/dNXI9//A5yVK7E3q9Xmg2myE0Qxzz6tJKuOueL+yacWZUg8yXLQSTUVRvfN1FSZIkEVCDQRK6mxtBwussdYJij431jZCEQehuboZBfxC++dgTu0K2Fxw+N2m3WyGERmg2GqHZaoVGSEKn0w53f+FLu2KMGVUg12ULwWQU10XnHU6UrBCaBv1+/FaS9GO8Ic/V62+E3mZPH4akEcLXH/nO3Mv2Fy66IGk2WyEJSQjJQNCKNHCQJEHOa6mzHO6654tzP86MKpDrsoVQMorrovPOTVrNdlQypdtlvUWP+pEadkMy6If19WOh1WqGdqsdksEgPPDI43Mr31/8569N2p3lEBpJjKvarVbY3NwMvd5mHLO8drvTCl/88l/M7RgzTn2hyxZCySC2w2cdTER9kkGIwGm12zHW6vX7kQaK/smCb6yvDzOGzWZotVqh1WyE+/7ykbmTsUDVaDajh+on/RCpYJKEZ55+OtJcGReNXzHX/d98aO7Gl2HKS1+yEEoGEQpYWhButZuhkTSitZZHEi/q9YdeK4RB6G2sR/ApwF/qdGLL933zW3Ml49df+JqYWm+L9oZGWN/YiGNbO7oWPfNg0I/eOklCWF1eCvf/5cNzNb4M013JJQuhZBDj2a8+IwbwSq/LW4kaKezo9rrh3q8+0Dj/7EOJPlt75pkINl0ruqhYTNf+lznJEh4+eHqyb3VfaDRbcRyKr46tHwsbG+sxOdPrduOygjyyxre80gnfePjbCx0aoUMLoWQA1uFDh5Kl5U5IBgrah+VMooC9Xj98+d77Gq87/3DSabXDM0//KCqjUKfPBapmDPZDuP/B2aaEh049JRqPpaWV0O4shUarGb3S0aM/jlRXgFKM1VfiJhnE7OBypxMeevzJhQ4tgJUBRSMuufA1h5N+txca7UZYWV6O4OltdmOG7Et/fm9UrF/95V9K/u//+d8hIQaRt2o0h9lDkarG7NLCgz93SiKDEVSytLQcVvatRq8rw7Gx2Q3r6xsxptrobkY6qJ9OqxXabVVjtBbgWgArP7B+8fWvS9aOafF3MywvL0evtbS8FD2XEPXHX/rycYv9+sNnJf1+N2z2BzHIH679SF+H619fffixmbPup7/y5EQxU0xWNEJYWV0JyyurYWVlOfZfmc/NzW58ffbZZ+PieK8/CB155lYMJ8O3nvjezI0r/0xX+42FQCbIUxmyY+sbYXNjI6aXu5u9sLKyEvbvWw3NTifc9UcnFt6ed+i0ZNDTOtdQtAKU1K/X64beIIQHvz0761s//8qTk7jc2xgCJGmG8LzVfWFl376wf/+BWAv5ubv+cxzIL1x4QbK2djRWl4gexvW8gVLxITz21F8t9CilRwuBTADWG153UXLs2NqQDg2SGLh3Oq3wvP0Hwhf/7CvPkd/5h05LFFQN/zXi4rFiEtGq7mAYez3yxFM7LvczT/nZpB89aTIElrxWaITVfavhefv3h33794c/tGp9LRbLa2mJYe3oj4fJjH43NBvN8O2nvr/j46nW35RvbSGQCTJ87XmHk2PH1sPG5maMlmJt4FIn7Nu3Lxal3v2F5xaiXnDW6SrKCIOkH7pRGQehr8qFpBHT8Q8/sbMB/8FTT4kgUeynuCpJlAEModnW4nYneuQ//9o3TtCNN7z2wuTY2lroxuWFfthYPxa6XXnmJDz+vQWw0mq0ANY2wLrwNefE5are5mYElmidqioUYzUaAlknfOW+r46U4YVnvzrpbnZDV6Aa9ENPSjjMD8S461tPfHdHZH/u6acm8joai7J+An1MWwoijSR6roe+89y+veGiC5Ifrx2LKXd5XVWZiBYOKzOa4fHvLeigq9KOTG55RzudFs45eGYsvJVVVqp5c6MbGk2V9zRDq9mKCYyvPzw6jX7+2WcmsYaw2ws91Q8OhgkN1dlJ6Gr3kSenSwkvOHR67JPW13qJaGkSf1dCRh5Vn317jPd5/VaMtanyrSSEjY1jkd7q+6rA+M7Ca52glAtgbYPRM37uVYnWc1Qnp/WbjY2NSINiulkLxY0QHn58fBX7WaedmshbDRMZW/GMvISUM4Tw6BSBdcFB7QBWH2JP4rrUEOghbPa6ESCPTYiVzj14RgRmXNPa2Ihxp35Xav7Jv/rBQpdMlxbC2AZYt99+e/LZz3w6Buj9vopt+7EIFSv93R/89UT5veoVL09anXZY6XRCq90Km91Nca6gdbFBIwnfGkG7qvbHFyiholKsrQylKkb0IyMRvU+/Gx7NkDI/75xDSSzE7XZjEoPYU9v1VUP53R/814nyqHpss9reQhDbzMyRI0cSear/+DufiUkIgUvKKKX66//2N5lk94p//LKk1WjG2sHVleVhwiDmDPqRFj74WL3p99ee9erIPeVZNBY8VezDVoz10DZe18XzmrMOJvLaQ083iHWE2jWthfBhtrQTHn9qsaYlmWVSjlm1CnX264477ogYiDV/MXMGJEJU0Msvvzyz7F7+sn+UqEphqb0UVldWYsCv+EQZxrp3G1941umR/ClpMkxWDMEVt1glIXzj0ey1ftqmr+8rbiT2FLD6fSVyVInRCo/uUFKmTl0o0nZm5SjS+Dx/57bbbkviVvStRAMAY0yXXXZZJtm97B++VMtEkQaqtm55eSnGbHFPV6sVvlZzDeF5Z/58XK9SBb7uqSygPOUw5lOV+iA8nJGOfuADH0j+9J7Px+/pR8W5eEGVOqky5bEFsKJsMinHPAOkaN8FLFlleSvtrdLvUkz9f8tb3pJZbj/z0pPiOYSdditSpaVOO2bRVHOoc9Ri9fs369t6cejUfxadizyNOi0K19ei8DAHE9evpAZZMpQClq7+kz+6OwJKABUw4+L3Zjc8+f1FAgN9y6wgRRV0Xr8nYGkRdah8KjYdeq+8wHrZT780UfZQXkoAXV7uhFajFVb3rcQC1m6vHx54qL49W2e+6uSk19PmRMV1w4Xq4X6qobfS7wJW1rIkgUsU9u7/9PvRKGgpQYfs/Ot/d0m44oorFvq0pfALQYxA/sc//vGt9ashqACXQCXzn5UG6nsf/ehHkztv+0TMmqktnXi0b3UlHpm2ubUD+es1Akt9OPXkl8fDNuWpghaomzoOJp5kMdxbFkLm6olbb701euDhwTpJNBYCmsb21re+daFPC2CN96Uf/vCH445hKYsUUv/xVlKmPAr0yU9+MoL005/6ZEzbqxxqZXU1xiOKe6axtf20V/7TCKxhxcVw3HJU6k8EV5KExzIu8L7//e8/HntCkwUuyerKK69cAGsBrPHAEt1RvZwssUDBmXpSnjzxle7wqU99aqjUvV74vd++I26SXF5aCvsPPD/86V/cPxVFfPUpP5vEesW4R2yYIZTXUrp9GHdlr/fDY8Xki3lzyUntv+td75rKmGY9xFgIYcQMCVgCgP57mj0vDRSoiNOgTlJGwPqOd7xjKvL/yEc+knz+c787LGFSQiYeXzYsCM5bWiVgSWR4KQFMPyxJvPOd75zKmBbAmnUJpPonGqjqAnksKQ+KAzDy0EBVbsQq8i3+BbVUalrW/aqrrpqKEn7sYx+LYLjr93837nBubsVEevONv/IvcnsZEhjEWngugevtb3/7VMY062q1EEJqhqSEAlZMkXc6x4GlywSQPHGEKjegSAITQBXYpm3ZteANJU3HjHnGJDl88IMfjJlBX45AjG9729sWOrVYx3qu3fvEJz4Ry5iwxihQ3qSFWkaZVZ2AMgPQacci8p7qg4xGPOhmi8KpP3m9jIAlo6N2fBlCBmNa9HbhsWZdAqn+KR5xpdPHUiL95EmzA6y43WRLmaGC8lzTVkCtywFuDAc0NS/IP/ShDyXEWKzxkT3N69XnTD0yd3fhtkdQQRRPAJPHiqfatlrh4osvziwvJS7UzigPoXanDSytp/lQKdESuPLGeoqxZGzwVmpXYxWoJK88cWhmTZ2zCzMrypyNq1B3oUtSEsVEAAslygMseT48ghQQaok3nHaMpf5A3YiNyOapT0XApawp4+FYNL23qMBY1AqeAEDWnAjypTRUFuj3Sy+9NLMhkiLjrWTF9R9POG1QaZAAC4DHgze3EjICfhFgQQOpoWRtK0/lfyELOAdfyqwoczCW0l1UKRNxiKy6FIdYIu/CsNL28YEJ3e5xOolST5sGIhiBiyylUzf1K2+cJTrocRb30Ht5Y9HSEzeDDSyAZZOi8qO4DWIrK+iBed6UtAJ8lBgqyGveLFxVeqNsHuDGK1PnVwRYGg8xKAvE+nsBrAUVPK6ziq8AFVtEpCQoYl6PJWD5BkmnTTsFLPWJRAPxlV41xve85z25jOwtt9wSawYVf8pLKZ5k3U9/v/nNb87VXlXGY1ba2dOD90lgGz4UkLhBYBPA8ihK2jNQrEoMslNUEHpKFUncU7W130yvV199dWZ9uPHGG6P3U7JC8tGPlznlNUSzAoiq+pFZkFXdcFbbkceKT2bciq3op97L62EAlnsF/U56eieSF7o/9FSAIMYCZHrNAyy1d/PNN0evNdxnpodFDLOfAuleT2AsgLWFINadoIMsCktJisZX6TrDIkmCqg2RQE/a3amqfn/f+96XSx9EB9U/eaz4YL6t9T7JcK/HWbkEWfUkz1J7XjArxZCSSFkUO+RVElEuqCSZQTxW3rR21TJS34irNDayoEWARaU7CRBiUrW119eyFsAKIajwFqXw4J4dsnmBRfU3C7FSYBabd4oGAlDKkaCpLOyqf+9+97tz6YO8n8aIdyeGZLx7uSA3lyCrtp6z0h5FpQThpKKJP/KAwTcCOhXEY+1U4gJZp70pNX7Qwjx0kCwjVftkU/HWe9lrLYAVQtB2c1ldSpeo8ZMy5l3fEbC84pt0vdqS4uVtr2rjIzCkYz+8l/qXN+0uoPq+NWim7rGXExgLYG0BS8rh+6904qt+8sZEeCw8FJsc9Zq3rapB5XRQdI1j3fDM+jwvsDReT7eTcpdxWnisumZwDtqVtyI2IM4iHa3XvHGC2iM2S+97yhvD1CU+xYBeXYIHU3/z9tENifpL2r3I+SB1jXcn2t3zHktrMWS1UDA/RzDvFgiloCne9TUi/f7e9753JuQtMBBTQePIDub1WBgS6C9rWpJB3qTPTgCgrnvOxETXNbgs7XKcl592C43L6630PdpzL0DNYN4F2Cz9L3IN60/QVNpQn/OCX4bJaa/aEKVeXV2NzeapWCkylln9zp4HljKCvl8Kyy0FyZMN1ATjCfB4etXWEX7yKm1dSgOw1L6Di9/zGAAZEmglABOwRAnFBC655JI9qWN7ctAorKwtmUAv88F7FQEWKWeU1rOCeWlWXcCCvnkM6AvaeVLu6qOA6jWWApVOuVL7C49V1yzOaLtSBk08u2ClWJwBiJLlTY3L+2m4rA3pdyjhrICK6UiDyw1AEWDhpalYIebK+8ijGVWX3N3akx5LWTHKedjdK8VSFQJUMK9ySfJql4SFewMp26yk2tEQDIuDvwgVhAI7/ZVMGT8A22uJjD0JLMVCAIBSIz8HIm/KeZwXKJMUyG0ic34B+gawSLBIHtdcc01uvfCKDsAkSuiZ0b20lSS3AHPO38xdziEvpJtJjaNgeeMq9wAOVtrDchfxgHUKDyrIPXyRWB62CHWlNExtclYI41f7YgR5dwrUKYM6295TwNIRYNQBQvnYTwQQitby3XTTTc85jxBqJfDOGrBEW1F6P+6NxXLJI2+Mqe9Q4sT6mNr2fVr6u8gyRp0gqKPtPQMsTTh0x60oyYUi1d0+IQLWqHhF7+VJX9cxyePahBJ7v5EH3ykSG+pQHhJAAEtA0w97wXY7LdwTwOIRnwCLGMA9ShHqkwYWmTV/1TWz5q3SMSEehX67XIoAS+2r2Fftkob3Az4xbLsZXLseWJQYudI4TZESlAWV2qACAaWFUkmJZmVhOO25vBwJEPg1FNQWpW6wBA6dcYPD77s1W7irgUWFgScoWMAlC1gFqACW00os9SwDS/2WN/cYSP2FtjnIiiZ1eIRQ2it627txe8muBRYeBGXH+kJzilRyj4tVbrjhhuN7klBKLxUqmr6fVrwFuNzbqv++YC5gFElmqE0OQqXYWdlBtUcCSXFY0aTRtGSU9z67GlgeK/hmPL1fpbKzJsSaGMkAQD0vSsMx1JKVlJ7z68mcajxFaaFiLg6c4TgAjl/jkUB5T8PKq+zTvH5XAsvLdSRM39FbVUzlk6T1G8558IM5BeCiFGqaSuD38sNm8Ci+tUTvFR2TgKu2qHCRfHgkrdrdTZRw1wFLoEJR0pXbJBSq9FZSFiwv60Ecu6z7z4u3ShsK0uXIkORGWWMhWqi2tENb95C34jQsAa6oR9wpQzTuvrsKWBwgiZdiDUV/k+KtKllBStlLobgvXkufzSu9Ie7yhXSSQHrNuwEUBdQTM8kIMifs3NaTL+fVGKUBtmuAxRZxsn4aqGcANZlF12RGWSU/rpltJsRWUM95tr5U6vvjfkg+YDiKgktPl8TYOVUX0DCGRdueFc+1K4CFdfV6N9LdErQmq0pPpTZVHgVd0isn6OozAW2eQYVyKuHAUdRUTHDgDunzogDwRybRFvcFzPMsw7kHFvV/aVAxSVL6omnicdZP9+Q4ZaggCqjXqu+3k1aYqhUBy7fY+IJ70cJarXE5LfSFZMVb+l80UbKTMovMZac7UOb+0BXS2mTmnAZWmajAU+GV3MJ6Zfu8xlXj5oItIZ4dJAUvQyK5Fx2znkmm+UvHcmqTPXPzaKjmGlicxAqQPB7QZFVN/6QE7A4WJQJMKEWZoL6MgZnGd8nmMWY/NVjvlTlDEHAB0nQ1vOQ6b55rboGlNDcKlaZjdYBKz88ilpIlRbFIkOiz3Vr3hpwpT6K6hIVkUvJl1qGULfQMq8AlKsjzySTzqtlHnQZpLoHlFDCdusWiVjkJmnQ/4dWfLYV1LWOx65zgKtt2YDFuSpNI3hSNt9RPte9b+gGa5lggE7hmdadAWs5zByzORk9XSpOm1WRUzckFZHkovBMWW+suer9ofFGl0k+rLSVuABUH8XDWPTFRmWUN0XtfYAdctD3rRc3Hk2bTmpAq7qMMFdUTmlw8B+/VsbjIepVXfPPYGo2pDP2pQiY70YbmQfLQEWf6ITbSGYqaAwGjjHETeGEeMAWOUhDA9FkZ8E5DZnPjsTxR4RXrJA7qAJUoIMWo7rG8smIvUMBRiiiD42taUniAhaErU85FqZgfp8ajbJnzWWYKcwEsHj3jtX+sqTDpVScOlAWjogIryf1Zw9qL3spBpgoKFskFKjKmeJuyXoUnmcgzkpKHpTA3s2rYZh5YogWsT6HYgIrM3KWXXlrpOKhnk2diTxLWkq0hZYL0aVCRad1Dz27WvBADeaVGFWVkSmjgGTkISPcDWLrfLHquShWyjsmEErBWJaFSEV3H2eCykjyETveUJSbzJeVRwD7PpTZVzxF1f/48Y5YlKNota4S0zuXsgV3Oah82MWvgmmlgyVqRFYJmyELpSRZS8DoOIxHt5OATPJavVc0q9agaMHnaI01OZtbX+DCIZY2R1hFZ2/K9b7CYWVucn1lgabJYgEzHOHiUqoHlzyKmiJd7C8h79YD/LCATs/BNnjxlhX1cAltZowRFZ/8buwh4naUzC2cSWDzFnlQugTHrJ5qksvQirSx+0KSfOwi4BeaqY7ksCjtP1ygeJv6l1k/9lzxZoigLLnkuMrV4SOoW8Y5FK+6rlPXMAQvOThbIKaAGXgeoqINzqiGPJS+FNdzrGcCsSkfpF/OGx+K1iuytdIT0vvqltllUhr7vNLhmClgKUvFKBMOkc1kQrlpgnNqqCSLoZjGSvlTtHbMq6bxed8cddxzfx0XqXR5Lc6rsahWJBoGLomtAzHnxMJ2qdSXPfMwMsNJPq2A1X4PROkYdVIzDTQiAAS9UcLftrcqjGGWuFbA86SS5yvvrZ21tLVZqVAEuaKGfn4FnFIAFtJ0C10wAy2vxyMD53io9DqYsNx+lKBz3RSUH9YdcW6ZyoIxi7obvKtHAOHwxX/Eycq6CForlCFjsFfNMLmVoO8E4ZgJYpLgFKt9TRXxThXUblazQBGtS+IF2VrGwuRvAUXYM7BBmHsm04lUEsrJpePWR2kIMJMcIcJ89CSxRQGIZKJnHOHWAir1cAJlqASaijv1cZZV0Xr/PWqTHysy35rkKryXZyDjjoVjUB9C6T5mi4CKy31GPxdkRDiisDYWWVdMx4irSwJwMhLXT+9OehCITN0/f8QfSUaALCPR3FcsYHDQqXeKkXT/ue9rbTXYMWCi40wSsGp6kahcu6ynv5JPq2+qlrFXfc54AUFdfZUC9bVLjmguAVsXiu7wWdYu6H+cVUuepz6b1rLIdAZY/4QIho+DKHkngVVdVMLlKirDu4VlA/b4AVV3QGsZBvqZFsgEaXuZAGu814KIKBEbie/em8VilqQMLLoxSSyhYLehZFQFtWkWIq9KTy7kK83ZYSX0QqK9lrRnCRtxrofS6cxXU38989A2SJMZ0n7rBNVVgEVORbsVLAS79XQeoKBKFAqazRnWk8utTz/lu2Xdky8hRU+iZ2SpiXDfgvqWFcEP3K7tfbLuZmBqw/CAS9jixEEv5UhXWKj1YTlwlE6XP+R1LuVOLiPMNkeK959wSX3PCuFa51CGW4qVxxNd+ulQVIB4liakBi0GSfRO4vIiyDlCRIGGDnCo4OJNB966qvKa4iu3dbypTSCkSDIL9W1VmZn2Ny/dxQUn1WkcYMBVgaRWeDJCrEsCqg/6l18cEIvF69lrp3gsKuHPAVgLLldvXudQrzU9VR50JxJwoRYzt2UPdr+r10tqBJVB5ooKiTOfUVWfjRP9IhHAfVVhQszZrm+J2Tr139s6ihOnlDvWIOkO9XnPNNZXoKCVWxPdQRAx+1RtnK+n0uOkhCyQBqd4PK8HmQX2vDjfsRxYDZAkQIdYZtO6sqs7f3fWYWcID1jTT2/yrWnviARrE9ux0ZvlF0qtiPS3Gi3VOBWtHGoiApR82wNX1qBuBCm/FVgV2nNbFp+uU4V5om6dweq1fOmNcJS0k1uJIO09mVRWW1AosPzKYTAyr4DzErEoaKCCzUxXODqhIYNSVBdoLAKhzjDwuCCroIYPmrkqvJeOePgiUheSqHqRRK7AkJDwI9I9XDmKsKoHgHFr3Zfcv2/oXGcA6YVFN21RNsOHUEw0ymFUkGFh+odJePZeOALaqzvyfGrCUPGAwUnIpvoRVxZZ3nlThx0D7ueISWlVV1NWo0KKVURLwh124x/Iq9bLxsYDFOipUEFajPlXFaGoHFlvfsQjpIsmyVFCZJbyTJgAXT9ZH71188cW1j3MBlWokQMUE1IyNr1BEzWdZ5efseTyiAEZMJ6Nftv3akxdaSyLzopvhUdhcWMWiMMcQe6mKF3iWBW416rJoJY8EBC6U3pMYtKHPyugOTzShjpC1TZJrei2rN7Vacja5UTq0b9++E3YIly0lEnVwQKXTqGWFk0cZFtdWKwH2V3mBNtleEmFlMnh+gi8sJ3qaxk8gUSb1XhuwqDBWZ+WhiKnkwarYFiJQwb2xNBIKe3D0XhnBV6smi9aKSIBDQFF2FncpOChrOHXuPNU/gNazymVCiFqBld7E6LSwzH4rWTMSIdSbQTVJ41eRFCmiDIvvVCsBirfRJaeIVZz2RBEDMRy0kHP6L7nkkkIYKfSlSaKj8JFkApaGILEMqHjAtldUEOCSwi/T/qSxLT6frgTYIMlDEfwpI6xNlqneEXB986t0iXsQZhTRp1qARQGs0O8VxViFIh3Vd8WLiaMo4ES4EobuVzZum67aLO6WRQKibGR5vdDA0+RlwMXOCzkC9JWkid4rstZaObBYgKM2kKf8KcYSGMpQNIClyeDAEAC2eLxOFhWd32s093gS4iG2HpF0KLOATDxHiMFeMbWt3/Ma7MqBpcVaHhTG+drqrBRffxdNKPCERWoNcdnEWGUXDudX5U7suagyxqaorGdVFvJcbP+B/fh2JI07LwAYKywLkPo2FkCWx3NVCizWB7ShkMyNBKH/6mhRi+K7gCmJonBSwlT7VZWipJWKbS+6b9ksVJ0Ky0K8bxosY8jq7GuZtqmy8fkHBBp7GUaUPgPRn/MFNcwKrtLAImtDqlsWhMycBMh2DQBGjCTBkNqE2+LadY0+Y6GX5IRecc1eCc02Az5nJyoL0iRR1K76QUmLr5HwO33xvqXbpypAfSG9z0ElaocnTjJWvXK0MkpA8gXqgeXF29AeMsBCM0bWBhmbP06U8aMM3MsrUxgnMvGDVriHL84yFuTkypyeE32fOSSL59RdfVWowBzcDFwnAAAVT0lEQVT6fDA/JLzUlq5FzvSNSh5fd6KPAJcxamz+ZE76Rk0i/fczUXQfrbvCkBjvVIDFM6XUccqK0iUoCMgV2o88QzAAkEmRULBKBK5MNAEsAsRK81297wqJQuHdOPsAYaWVBEFjsaC0akfvcbKTrtO4uZeuQ6mpQ2N83jeyUICFVHJaBoAu3T83NFzj6y+0yzjSfyN/vD9FqL67mvUdjIrLChruRoJ7AaS0oUJBMajML3Ol+yFnjLMrPDJGJxgTOoFhYI6QC9UV1KrqOsapPvqc4Qg0v2pHgIYGIg+1l4ViF/ZYnMuNwmjgHlxiDRCwrzeRLWTQAMc3I7oAEYCDzr0NbTOpKKoEBehYmE57Fq518GL5SLhI8TAefp3645MEP8eqMlFpq4pC42Xop3uNtIfC+tJfqDbGxTftIXv3ehoTDydAqZE3JyVhFMi2oVTMkxtE70daOQG+p631Hp6JSgfAovvCaJx1+BwDQM6dRBf8Xsy1zz/y0b25h0IVYn6MnJfBqR29n2ZeeH59PikLWRhYyqJglRE8iuUUjvdQLibY3TNKAhXEw+i7aevuVh5viPBG3cspjH73yZSg/EkY9MM9o/pJjOgL3Ix5VDkMyoECY/VphwlCfuo3+9RQJsYG7cQ7IBvA417NrTrgcAYhILsnVVt4K65zMAIsP7JZ98Djq9/UfWJYmWdACr3CI9FfrseTuFflGsCUnjMMqcsKeeFZYDUYW4wIlFveCN1wdkTb7sWZa+ZN95pUqFsYWKKBmigGgnWGJjhN0+8osJRM34Macj0DdyAxSQhnFIAAQRpkDmS/xhcYubcsmN7HqyFI92a61i25AxxvQh+w4DwTiu/yvn9Xn+ExHJBMIsbCjRYgwFBAmXilHaw6cuPZzfQXwPsc0kcA7AClfeSp9jWP9IMCALw4Hg7DgWGRnLgWWTvV0lxAsbkXMtN16+vrJ1A1lxVeEcaTliPAQR+hnciEfqCPut6NHqCftCGyMLA0UCos9DtgUYeYeFc4JgrroA7LWmE1nDZhnVEmFBMLxne4j1tJlAkwomQOSvrofVIbAhi0BNC5R4Ii4NnS1pF7jWqf8bmVxOtADZl0AA21YZxYfzdayArrzbU+bqy0U0E+5556dWoK5aVv9D9tbNx7oPwAw+cHRQWcyM5ZD5/p3oCTuac/GGTdg7jS5cTnznroo+aXcWBgmQ/GjndmDmEMAFSvWXYzlwIW4FInAJajm866JXZhQA/SVtkteprSOF3DKuERffC06ZRK77kFhK7ApZlkhItl9UmAe9N3vqtrsZZYtTRV0f09ztDnUCEMghsN95yMFQXDmCArDIEbpXQshWFy6oPMdC9/5rLeh5rTN+bZ7+le0oHkMQtyZw3KwUm2zw2sfkeuzL/+RnaAEl2gPd2HeNjlwXhhJPTHjRD9QH+RvXtK151Jp0eVAhZP79CAUT7cvQ+GiUHRsmRV3MPk/V17tFCiUYLxiZjk0vV9r/jAOtKuK3KZNZS8Y+SMCFiBZAz1cg8O4OuWOf2HxfgObryI+ifDqr4WXcjNK6cs10uWvlzB3Lo3dyakzycdblMKWP5MIufdeAu3jAwQD1LnRGuh2ukPlsw9o3PwSYGovucLsK64+oxgPusaR5bJ3u4azobAKnvcoHF5hhD6qj7XvcBNWRAxl7MFtg45nZ0FcEmWeEvmFYaFR0uzpix0sDCwsExQCXevUCGnah7zqKN1lSD5ueAIBuUHWE7RJNSsu1E5CBSaBF1BkablsVAGKBMKDLWFwhLDYWTqVmQ/swJwu5I6BVTfpmWItjNSbEFySozeOLNJg2tSnFUYWGw0TMcwAEwlRuzwBWiyVnBYXVcHuAQsFIxJpU+8D8jpu67LUm4l6qvvwvU9/Q4VK1q5n9WLMT5iLcDt1hXKJXmT+WMO6gI/R0a7Nyc88NiLz/GsdctrEqhcf9Nxrs9vOjuq721HBwsBS6eXurVW50G3XqF5gA+a6B3lO1VaUd0PMAEeTzwQoHt8hBfLQpM4ys2NA4vIBNT6u4pHf45TiJtuuum44dA1ZM8APLSUmAGvxTjrABbxnoPKaWo6PnEDp35VqQNZDZQYl2SFHtJHzxEQPzvgPMmyndcqBCydXEoaOh0oqxMeP/HAN49v+F1tVDXRxB0e6xHME4M4FXSBqh+TJlfjQInVHplD4kgmFLnUAS6BivthyHw5AOMgesOTVcjE4bXrUGTpA/TajRZrVaTa8Q702cODSZUMWQGT9TrJiP7QZw9rYFNyIh6P+1LKdg+vyw0sP8CFG/rNRlEqqoZdwX01PYu3mCQwD+jTaWp9VwkKjr3CYjpF1O/b9YOdrM67ASdZUUCtv7NQy0ljSn9+8803n2DQ3DtLnvSfLTbqqxf/okCTjEiefknuvoTAd6GeAIbH9qSNG31SX6cFLumBJyqg8ein75Rwo5FOaujvcbsqcgGLLKADCauDUo2Km9j2wao+lgFXW1agTjkdvCg+gycN72U99EXj2C6Joe0Knj1iTccpmGgg99dYsyZFsigyMQxjIm1Nn9JA9ieuOKvA6FQBfOhUeqHc13tcHxiDGwRPvGAAs8ij6DUkWOizMymSUh47yWO5MfAEjN4fp7u5gCVBEgwzMI+ttlMkTTTZKZQPYOm1zEQ74H1hD6/o6XRZIKcgjIP4b5yg2JfFd/EEFHPqvmyFoNhTsqoiQePLGvSXdSK8btoLUXKG4SBOIOasYrlD+sB2DADPuprGPsqay+tybbrqAiZRpUFKA1Ae1t8jFtTruGz1jTfeeAIFp9+eT0jfJzOwsIBe6oGA9DpJGFpkBZTu5dyaFplsWUHADWBpX6/pNSqA5QD09PSocUCtGK++i5Hg3m4BqVjg+jJGQ2347lasPYZAfRlHYX15ACOm9gjai8gbBeKROACW93UfedPtaLVTWvoDdSQuriI8GAUq95a6F1tEJJNx65mKbUnWqU1fShg3t5mB5U9IlDIBMFKpWZRHCQCux7K5K8470fBfLJ2nz7nPKA8kOuDpU6/MltDSk8pTTFBO37TnXhewUpjKZEjRip4dz6mwHs+ybqb3touXABayJkUPsCYZw3F0y2NmB5YncibpA7E6HtfjF7Ujj1wluGTYfU8gfcUY63VcvAR99IQRFFz9HjXWTMBKKzDZHmhGngkiS6iO4VmYcL3maUveytdx0sHluMklLZ9OciDsNMB5ljFHDhw9evT40ym4FmWDUuiV2juNq2j2E89AxYJv4VC7k4wRzygjDe9gKQp4yQNwp+PlSWD3+5Nw0nsA1A2v+jdpfFljLVF5DB59hy3p7+2qb6CPJDn4HkmbUcY7E7AI+qFMDIbJmmSdfPCeyHBwQZuyJjKggLhl9Y2BZonZfPGae6O8ozyWFEb3ohiU/To+IRyjhbL5WpLGmrfSgMMk0zST/mYxQhydADNQ33ypIEsbPn9SUCi9F9qSbs/rZcjQYRRpB2qYR7fGgezIkSOxz5Ij1foYcxm/LPfAa1FE7pR6lAwnAovyGdYefJI1+LwTow4BLnfDTgmzBPx4HU+dE/dk8XxMKFSOiYQ2IWwWhVEiBEpVuhsCdlUzeWws1D1Yy8mjeBxOCnUj2wYNyVLjqP4KDMhJ/fbtOjIUWdvRKUm6t+84xnqXoZewGOYA70XmM4/MRoGLh8sjP2cVmtcs40ffPNaiHd0z7RAmAovsEuUxCJXF0rxWWJ2QBWGCEKJbKr233WCxHtAGqARCzQpMXY+XQjEwIEymuDn3IYZT37GA6X4KDL6hjywcHnUcJ08rBMeYcR9oKxmpLMpAm1IsxqX581hD7WVlCbfffnscWxro3KeIkdV3odppo+1VM0UpoeToSTM3cpJplt0N6iNpd1iLx6uj4rNtgUXw62lRsigadBFQMQm45/SgAdokYEEdABXB/SRQugJ7wS7KQlZLY1bCQf0k0eHZTAlznCLxdEkoG6DgHpM8PWtm0DYAjVfX31nB4PIm6YRxRHZZqDMPucAQeQ1iHpmPo2uMGRbjT+REjnk9lz+9Edmx7sicZDHC9Dld4O1jyeWxvGNYPOfCRQNyOkQKXtREiow1IUgcxX19oRTqQKymdvMKCqWFKknwKI8MBzGKQMFBJhiX7Sy0aBNUgaDZ6e52wHBg+dofcsvjrVzWkjEbAT0+Eki264/vZMCA0S5AyAv0UQDDS6uPvp8L6qs5ygMujAEg8jHrvbx9Jq5HBmQJmVd3NGM9FvECvNRLkNRgmWcHOUUh0Pf0PVUNacWVxeB6BofQoHV5gKXvkPEhMePegVIlaBzAgrJMoifydiwWY5BEoSVLndswqq+k15ksXUvQrfeKgAp5i8rRFpkxvJb+HmXIvOIENoEHQVZ5lH2cxxqlEz7HGE/1P0uygSdDQtnUPsZb8zpp7kb1kzY9m+3rie5oRgKLHZVq3K0FyqvJrqrcn925xBJUjkMFHFwURHpc5h4nK192oZHJY+JQZF1D1tO9GXROn0+iwjzv1gN8UvYagyxzWklIj+tz9YUDezgDP6+V9bFSPYL8MFKAeBRAMA6e7pesUNIq6w7pK9lQ2IN0In3s2XZgTp9oq3bTlTJZwDkKXMwPSzOuf75WORZYuDnoFsqh9xnUya/4J8nTz66FH/7whxOTIOMsFRkrKIoAhkCJCWTZBSr6AOBpU+9vV2k8yUr6REJtvG1f+MTCTwIV3+fYbQcnVlSy1XiRJ9SFTCUpfpIlWe+53XipImGcvi7mc6s2SNzQHp6aOarSU6X7TNEzyxuelSbmHQcOD2HQY9hHnnW2ccCC3ehzZJE2tM8BBDEMlhvLBDIZzIte9IKk1xuEF7/4xaWApQ6JW2ORAY9bVa2Ia5HaYylPneo7k84g2E7ZsOSkxKE6rFlw3BZ9I7ExCbBObzw2IZZksgGMFCLN2/EO6lvZmFb9kRw1LvcA6gdHo8FEyNRhSAA3KfA0CLPKIs918jzSQ1gT9/YDi9IeE7YF9faMru5dhAJ6nwmRwEOa0dGf5wBLlgJQEaSvrq4eP91Ik3vgwIFEgHrmmf8Xnv/8F5YGljpOkgDO6mftQVmIpxgMnmvSNuksk5muwJfi0RcHHOVPeWNMFJV1MveMbrycGeDR9J0qQIUcOBrcaS+AhuY7ncJDqM8ss9TprXy+ZHSRmd73DG16LqhSIQaCtlMppP6XiVF1fz/yj35i/NQf5ukEYN15553RK2CdsKjpAQhYPvh2W9vVB+HZZ58tTAlZiIUGcsKqxzS+fuJgqwJYTAqg9aPA8I4E/FL+vLV/1EligZ1i+8TgIbiOpE6VsYx7Iywv8iQjq/uzZkUfWBzNavXFav72b58urBPomJIuGBm8lfSEQz3ZVIpxxluRUSVOzdrvSYbYD6DBuJOUGumxNACsAl9wwfOlk046KZG3ggr+6Ec/Cj990t8PTz71/YY+Kxpz8YgW3LfTEJQ7bfGzJixkDGQA/sHf+7uxn6M4PffTazr9TzJBn7mSQ4lpL21c8O6Skbz8lVdeGS8lXnEP5XussLK6rorYKj1ewOW0FNnq3r44i7FFkUcZFcXbusff/PB/BOSs+Ft6op+yACPeo+IlvVBLf8V0POMp+Y0qrJ4EHn3uOqO/0Rtlp8mS631fotG95c2PK5g8BhfLU3mhrd7HKiBACU0/AEzA0nsvOLAvvhYFF5k0Okuq24HF+pC7dfVLk6qftHLrs//+P/9XBJWuGedZOSyGe2mSpOwoFp7bgcV9BRr9+LhlZAQoKZr//NZv/fuR2VaSJLLKxHejKCcTXkZhqV7xImaYivpBnSPUS2MfF1uqP5p/yRY5SA/8R0opWY0yauOUXEZLn2ne3vRvL46XuadHD4gPpbd+5jrt6rq8WUB3HmqH0EcGgm39ep9EBvSTZNRxYPEoSjJxEqQuuvP224KUMv2jwfI+nsuBNkq5AaOEziSk4zTO74PzE9/g3n1dx8v8EURa2Xhf/eWHyWXioLHUrEmBfO0IoUE/3GI7aNU+RgVPhvXmM8Z7xRVXxO6MWpj2BI6ABUB1PQYMDyhZMh6ytNyDa/SKciADXSOZ/Ks3/Ub0TowROaPEXL8dqOiXXvFY6AR9UT+lL+NCBvqODgEovJ6+d91118XukAhKrw0CLEIGAU5GCgOsOVFOwGU2CtToha6l/3hecgqwK/qDXgrYWiKKwMJSM9FQkquuuioiFaurRkdZYAcZvyPYUSCCOjIRbu29GhuLhADxYi4sBIPQ9LcLzqmalJwxSEHdMOh7MgbURupvr4TW36wruRdB6RmDj42+pS25/r7++uuj9SX7ybOYuI+8hzJ0eEQASlvuEfDUgM6VBYVAUVH84fi0HtUMv/mb1x63vNBwjd1T1B6Ye/tpb+WgRt66Hr0ZBSzNEWzCPR9gdKP4a7/+pggsdBR56T0W4/UeSRa9J2+FAQRYDljGg66rD+im/87n0hM/+kDXkujifhFY6eevqpO//R9uj4oHUBg4iQoU08GGALBMbsn0O4NxQel9XY91uPba6yJN8kwU6zoIS5/5wrGUGwrqwE/3zfsFPaMv0FhZcOKrdBZSyuXxDpSMyXKl1Xv8uLUeTkIzXH/9jRFUeGSeTKLPUe6rr776BGrl8kNmGC7mg3niPlJklMPnU+8zP+q3vIGv11ELiLEdV77lngYApRXUQwQBT3TK2YLrEvOotvCq6h9jkHf2E3edtkpuLAQTJyqEAbiuZ+k5c9bFvBHmpA0yfeA6WAdzGfU1fcQuSvzZ3/n0cYuOgqohLLNbIZQIQbgCw03dkzGhLnC3aLLmVGKgfOqXrLqU27M76RgHJXaLjAAAL33hb/9cMRI1ayiVZ8w8zSxAuwJAdfFaHry7pdTnt9xySwQVx5MRfLOlQwojObgnBCzp+QBcGD282yjD6EpP/9Te5ZdfHr2W0yzAtd3znT05gwK6IXEP5PQVmaMDGF5oqxsDPKuuIQnii/ootj4nHtY4oOyAWJ87Y+HebhDdMElWMAPPKagPvveOsIXMZcxVcCwVmRSs1rXXXnucBnID589YfCyfKwBg8s+c72OhsKbergYv6+kLwL44eeTIkZggwLX7PQD2qElyIabdu1smuLxbb/0O0G+88fqoE+6d+Vv3QDEwQozbs6iarH/zG5dEYOEdUQotRkPBbr31luP3SdNJaKwbNeTpMbH66QDnbwwC37/sssuip9QP8RYeO515dUVF/s4AnJp6LJ32ptw7HS74OBwInnhSH6677obYXzLXZDXJ4AIsj78Bl98TkDuo6TfvOa2V/smg3HDDT+7voBaw/j8W5t1XdhbMZwAAAABJRU5ErkJgggAA"

              }
          },
          action: {
              type: "random-template",
              actions: [{
                  type: "image-template",
                  imageData: "data:image/png;base64,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",
                  brush: o.METAL,
                  threshold: 50,
                  randomFlipHorizontally: !0
              }]
          },
    }
        ], r.ROCK_TEMPLATES.getInfo().derive({
              codeName: "cheese_building_resources",
              displayName: "Templates",
              badgeStyle: {
                  backgroundColor: "rgb(127, 46, 0)"
              }
          })),
          tA = {
            //tcategories
              tools: [r.ERASE, r.MOVE, r.FLIP_VERTICALLY, r.FLIP_HORIZONTALLY,
              t.selectionTool([r.SAND, r.SOIL,r.GRAVEL,r.COAL,r.THERMITE, yI], {
            displayName: 'Powders',
            badgeStyle: {
                backgroundColor: "#b7a643",
            }
        }), t.selectionTool([r.WATER,r.METAL_MOLTEN,r.OIL], {
            displayName: 'Fluids',
            badgeStyle: {
                backgroundColor: "#0487ba",
            }
        }),t.selectionTool([r.METAL, r.WALL,r.ROCK, r.ROCK_TEMPLATES, r.WOOD, gF], {
            displayName: 'Solids',
            badgeStyle: {
                backgroundColor: "#656565",
            }
        }),t.selectionTool([r.FIRE,r.METEOR,r.EFFECT_TEMP_MINUS,r.EFFECT_TEMP_PLUS, r.EFFECT_TEMP_PLUS2], {
            displayName: 'Effects',
            badgeStyle: {
                backgroundColor: "#ff5900",
            }
        }), t.selectionTool([r.FISH2,r.BIRD2,r.BIRDBIG,r.BUTTERFLY2,r.CURSOR2,r.WAYTOOL, r.GRASS,r.TREE,r.ASH], {
            displayName: 'Biological',
            badgeStyle: {
                backgroundColor: "rgb(0,147,30)",
            }
        }),t.selectionTool([H, j, L, X, f, Z, K, x, b, W, v, $, k, AA, z, _, q,], {
            displayName: 'Basic Cheese',
            badgeStyle: {
                backgroundColor: "rgb(252,147,30)",
            }
        }),t.selectionTool([U, w, p, F, N, y, G, Y, M, u, O, T, V, gA, eA, aA, P, ], {
            displayName: 'Classic Cheese',
            badgeStyle: {
                backgroundColor: "rgb(252,147,30)",
            }
        }),oA,
    ],disableBigButtons: false,
              /*brushes: {
                  wall: g.colorRandomize(5, g.colorTexture(n, o.WALL)),
                  tree_wood: g.colorRandomize(5, g.colorTexture(h, o.TREE_WOOD)),
                  tree_wood_dark: g.colorRandomize(5, g.colorTexture(h, o.TREE_WOOD_DARK)),
                  tree_leaf: g.colorRandomize(9, g.colorPaletteRandom("251,219,101", o.TREE_LEAF_LIGHTER)),
                  tree_leaf_dark: g.colorRandomize(9, g.colorPaletteRandom("251,219,101", o.TREE_LEAF_DARKER)),
                  sand: g.colorRandomize(5, g.colorPaletteRandom("228,211,162\r\n233,220,181\r\n239,229,199\r\n244,237,218\r\n250,246,236", o.SAND)),
                  soil: g.colorRandomize(4, g.colorPaletteRandom("218,116,3,\r\n248,132,3,\r\n252,147,30,\r\n252,161,60,\r\n252,176,90,\r\n", o.SOIL)),
                  gravel: g.colorRandomize(6, g.colorPaletteRandom("229,172,26\r\n229,156,26\r\n238,211,172\r\n253,230,191", o.GRAVEL)),
                  grass: g.colorRandomize(2, g.colorPaletteRandom("218,116,3\r\n238,136,23\r\n228,126,13", o.GRASS)),
                  water: g.colorRandomize(4, g.color(255, 166, 0, o.WATER)),
                  steam: g.colorRandomize(4, g.color(220, 210, 200, o.STEAM))
              },*/
              scenes: [ l.SCENE_LANDSCAPE_1, l.SCENE_LANDSCAPE_2,l.SCENE_EMPTY, l.SCENE_FALLTHROUGH, l.SCENE_PLATFORM,i.custom("Cheese Hills", (function(A) {
                  function e() {
                      return Math.trunc(1024 * Math.random())
                  }
                  A.layeredTemplate().layer(10, !1, o.AIR).layer(10, !1, o.WALL).layerPerlin([{
                      factor: 120,
                      threshold: 0,
                      force: 80,
                      seed: e()
                  }, {
                      factor: 30,
                      threshold: 0,
                      force: 10,
                      seed: e()
                  }, {
                      factor: 5,
                      threshold: 0,
                      force: 2,
                      seed: e()
                  }], !0, o.WALL), A.graphics().fill(g.conditional(E.IS_STATIC, F.getBrush()));
                  const a = S.mapPositionFracWH(A, 100, 100);
                  A.graphics().drawRectangle(a.x(30), a.y(40), a.x(70), a.y(50), N.getBrush()), A.graphics().drawRectangle(a.x(10), a.y(60), a.x(40), a.y(70), O.getBrush()), A.graphics().drawRectangle(a.x(1), a.y(50), a.x(40), a.y(60), N.getBrush()), A.graphics().drawRectangle(a.x(70), a.y(50), a.x(100), a.y(60), p.getBrush()), A.graphics().drawRectangle(a.x(70), a.y(50), a.x(100), a.y(52), y.getBrush()), A.graphics().drawRectangle(a.x(68), a.y(20), a.x(69), a.y(21), G.getBrush()), A.graphics().drawRectangle(a.x(0), a.y(90), a.x(100), a.y(100), M.getBrush())
              }))],
              primaryTool: r.SAND
          };
      A.init = function(A, e) {
          return tA.extensions = {}, a.init(A, e, tA)
      }, Object.defineProperty(A, "__esModule", {
          value: !0
      })
  }));</script>

  <script>
    // global variables, accessible from browser console
    var sandGame = null;
    var brushes = null;

    document.addEventListener('DOMContentLoaded', function() {
      if (window.SandGameJS !== undefined && window.SandSaga !== undefined) {
        var root = document.getElementById('sand-game-root');

        var config = {
          version: '24w19a',
          debug: true,
          scenario: 'x-sandbox-cheese-game',
          lobbyUrl: '/',
          nextUrl: undefined,
          includeSnapshot: true
        };

         
        if (config.scenario.startsWith('sandbox')) {
          function sandSaga_showTryOtherScenarios() {
            var alerts = document.getElementById('sand-saga-alerts');
            alerts.insertAdjacentHTML('afterbegin',
                '<div class="alert alert-info alert-dismissible fade show" role="alert" style="margin-top: 2em;">'
                + 'Enjoying the Cheese Game by Mecanix? It’s just one of Sand Saga scenarios. '
                + 'Go back to lobby and try challenge-based scenarios or start with tutorial for guidance.'
                + '<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>'
                + '</div>');
          }
          setTimeout(function () { return sandSaga_showTryOtherScenarios(); }, 2 * 60 * 1000);
        }

        const localStorageKey = 'scenario_' + config.scenario;
        config.onCompleted = function () {
          if (window.localStorage !== undefined) {
            const oldValue = localStorage.getItem(localStorageKey);
            if (oldValue === null) {
              localStorage.setItem(localStorageKey, 'true');
            }
          }
        };
        config.onAccepted = function (id) {
          if (window.localStorage !== undefined) {
            localStorage.setItem(localStorageKey, '' + id);
          }
        };

        var controller = SandSaga.init(root, config);
        if (controller !== undefined) {
          controller.addOnInitialized(function (s) {
            sandGame = s;
          });
          brushes = SandGameJS.brushes;
          console.log('Globals:');
          console.log('  sandGame, brushes');
          console.log('Examples:');
          console.log('  sandGame.graphics().drawLine(10, 10, 300, 150, 2, brushes.sand);');
          console.log('  sandGame.graphics().draw(100, 20, brushes.meteor);');
        }
      } else {
        var placeholder = document.getElementById('sand-game-placeholder-content');
        placeholder.innerHTML = '<span style="color: red; font-weight: bold;">' +
            'Failed to load the game. Possible reasons:<br>' +
            '&bull; Your browser may not support modern JavaScript<br>' +
            '&bull; Internet connection<br>' +
            '&bull; A server side problem' +
            '</span>';
      }
    });
  </script>
  </head>

  <body>
    <main role="main" class="container"><div class="row"><div class="col-12">
      <h1>Sand Game JS</h1>
      <div id="sand-game-root">
        <!-- Sand Game JS placeholder -->
        <div style="user-select: none;">
          <div>
            <button disabled class="btn" type="button" style="min-width: 4em; line-height: 2; padding: 0 0.4em 0 0.4em; font-size: 75%; border: none; background-color: rgb(230, 230, 230); color: black;">&nbsp;</button>
          </div>
          <div style="height: 70vh; display: flex; align-items: center; justify-content: center; margin-top: 4pt; padding: 2em; outline: 1px solid #b7b7b7;">
            <div id="sand-game-placeholder-content">
              Loading...
            </div>
          </div>
          <div style="height: 20vh"></div>
        </div>
      </div>
    </div></div></main>
    </body>
</html>
