<!DOCTYPE html>
<html lang="en">
<head>
  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Cheese game js</title>
  <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"
        integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
  <script>(function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
      typeof define === 'function' && define.amd ? define(['exports'], factory) :
      (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.SandGameJS = {}));
  })(this, (function (exports) { 'use strict';

      /**
       *
       * @author Patrik Harag
       * @version 2023-07-23
       */
      class Assets {

          /**
           *
           * @param base64
           * @param maxWidth {number|undefined}
           * @param maxHeight {number|undefined}
           * @returns {Promise<ImageData>}
           */
          static asImageData(base64, maxWidth=undefined, maxHeight=undefined) {
              function countSize(imageWidth, imageHeight) {
                  let w = imageWidth;
                  let h = imageHeight;

                  if (maxWidth !== undefined && w > maxWidth) {
                      const wScale = w / maxWidth;
                      w = maxWidth;
                      h = h / wScale;
                  }
                  if (maxHeight !== undefined && h > maxHeight) {
                      const hScale = h / maxHeight;
                      h = maxHeight;
                      w = w / hScale;
                  }

                  return [Math.trunc(w), Math.trunc(h)];
              }

              return new Promise((resolve, reject) => {
                  try {
                      // http://stackoverflow.com/questions/3528299/get-pixel-color-of-base64-png-using-javascript
                      let image = new Image();
                      image.onload = () => {
                          let canvas = document.createElement('canvas');
                          let [w, h] = countSize(image.width, image.height);
                          canvas.width = w;
                          canvas.height = h;

                          let context = canvas.getContext('2d');
                          context.drawImage(image, 0, 0, canvas.width, canvas.height);

                          let imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                          resolve(imageData);
                      };
                      image.src = base64;
                  } catch (e) {
                      reject(e);
                  }
              });
          }

          /**
           *
           * @param data {ArrayBuffer} ArrayBuffer
           * @param type {string} type
           */
          static asObjectUrl(data, type='image/png') {
              // https://gist.github.com/candycode/f18ae1767b2b0aba568e
              const arrayBufferView = new Uint8Array(data);
              const blob = new Blob([ arrayBufferView ], { type: type });
              const urlCreator = window.URL || window.webkitURL;
              return urlCreator.createObjectURL(blob);
          }

          static getImageTypeOrNull(filename) {
              filename = filename.toLowerCase();
              if (filename.endsWith('.png')) {
                  return 'image/png'
              }
              if (filename.endsWith('.jpg') || filename.endsWith('.jpeg')) {
                  return 'image/jpg'
              }
              if (filename.endsWith('.bmp')) {
                  return 'image/bmp'
              }
              if (filename.endsWith('.gif')) {
                  return 'image/gif'
              }
              return null;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2022-09-09
       */
      class Element {
          elementHead;
          elementTail;

          constructor(elementHead, elementTail) {
              this.elementHead = elementHead;
              this.elementTail = elementTail;
          }
      }

      /**
       * Tools for working with the element tail.
       *
       * The element head structure:
       * <pre>
       *     | color blue                                                    8b  |
       *     | color green                                                   8b  |
       *     | color red                                                     8b  |
       *     | blur type  2b  | burnt lvl  2b  |            2b  |            2b  |
       * </pre>
       *
       * @author Patrik Harag
       * @version 2023-08-06
       */
      class ElementTail {

          static BLUR_TYPE_NONE = 0x0;
          /** This element acts as a background = blur can be applied over this element */
          static BLUR_TYPE_BACKGROUND = 0x1;
          static BLUR_TYPE_1 = 0x2;

          static of(r, g, b, blurType=ElementTail.BLUR_TYPE_NONE) {
              let value = 0;
              value = (value | (blurType & 0x03)) << 8;
              value = (value | (r & 0xFF)) << 8;
              value = (value | (g & 0xFF)) << 8;
              value = value | (b & 0xFF);
              return value;
          }

          static getColorRed(elementTail) {
              return (elementTail >> 16) & 0x000000FF;
          }

          static getColorGreen(elementTail) {
              return (elementTail >> 8) & 0x000000FF;
          }

          static getColorBlue(elementTail) {
              return elementTail & 0x000000FF;
          }

          static getBlurType(elementTail) {
              return (elementTail >> 24) & 0x00000003;
          }

          static getBurntLevel(elementTail) {
              return (elementTail >> 26) & 0x00000003;
          }

          static setColor(elementTail, r, g, b) {
              elementTail = (elementTail & ~(0x00FF0000)) | (r << 16);
              elementTail = (elementTail & ~(0x0000FF00)) | (g << 8);
              elementTail = (elementTail & ~(0x000000FF)) | (b);
              return elementTail;
          }

          static setBurntLevel(elementTail, burntLevel) {
              return (elementTail & 0xF3FFFFFF) | (burntLevel << 26);
          }
      }

      /**
       * Tools for working with the element head.
       *
       * The element head structure: (32b)
       * <pre>
       *     | type class         3b  | type modifiers                       5b  |
       *     | behaviour                   4b  | special                     4b  |
       *     | flammable  2b  | flame heat 2b  | burnable   2b  | t. cond.   2b  |
       *     | temperature                                                   8b  |
       * </pre>
       *
       * Type modifier for powder-like types: (5b)
       * <pre>
       *     | sliding  1b |  direction  1b  | momentum  3b  |
       * </pre>
       *
       * @author Patrik Harag
       * @version 2023-08-20
       */
      class ElementHead {

          static FIELD_TYPE_CLASS_SIZE = 3;  // bits
          static TYPE_AIR = 0x0;
          static TYPE_EFFECT = 0x1;
          static TYPE_POWDER_FLOATING = 0x2;   // floating, not wet, can turn into wet
          static TYPE_FLUID = 0x3;
          static TYPE_POWDER = 0x4;  // not wet, can turn into wet
          static TYPE_POWDER_WET = 0x5;  // wet
          // reserved: 0x6 TYPE_STRUCTURE?
          static TYPE_STATIC = 0x7;

          static FIELD_TYPE_MODIFIERS_SIZE = 5;  // bits

          static FIELD_BEHAVIOUR_SIZE = 4;  // bits
          static BEHAVIOUR_NONE = 0x0;
          static BEHAVIOUR_SOIL = 0x1;
          static BEHAVIOUR_GRASS = 0x2;
          static BEHAVIOUR_FISH = 0x3;
          static BEHAVIOUR_FISH_BODY = 0x4;
          static BEHAVIOUR_TREE = 0x5;
          static BEHAVIOUR_TREE_ROOT = 0x6;
          static BEHAVIOUR_TREE_TRUNK = 0x7;
          static BEHAVIOUR_TREE_LEAF = 0x8;
          static BEHAVIOUR_FIRE = 0x9;
          static BEHAVIOUR_FIRE_SOURCE = 0xA;
          static BEHAVIOUR_METEOR = 0xB;

          static FIELD_SPECIAL_SIZE = 4;  // bits

          // how hard it is to ignite this element
          static FIELD_FLAMMABLE_TYPE_SIZE = 2;  // bits
          static FLAMMABLE_TYPE_NONE = 0x00;
          static FLAMMABLE_TYPE_SLOW = 0x01;
          static FLAMMABLE_TYPE_MEDIUM = 0x02;
          static FLAMMABLE_TYPE_FAST = 0x03;

          // how much heat this element produces while burning
          static FIELD_FLAME_HEAT_TYPE_SIZE = 2;  // bits
          static FLAME_HEAT_TYPE_NONE = 0x00;
          static FLAME_HEAT_TYPE_MEDIUM = 0x01;
          static FLAME_HEAT_TYPE_HIGH = 0x02;
          static FLAME_HEAT_TYPE_EXTREME = 0x03;

          // how hard it is to burn down this element
          static FIELD_BURNABLE_TYPE_SIZE = 2;  // bits
          static BURNABLE_TYPE_NEVER = 0x00;
          static BURNABLE_TYPE_SLOW = 0x01;
          static BURNABLE_TYPE_MEDIUM = 0x02;
          static BURNABLE_TYPE_FAST = 0x03;

          static FIELD_T_CONDUCTIVITY_TYPE_SIZE = 2;  // bits
          // TODO

          static FIELD_TEMPERATURE_SIZE = 8;  // bits


          static of(type8, behaviour8 = 0,
                  flammableType = 0, flameHeatType = 0, burnableType = 0, meltableType = 0,
                  temperature = 0) {

              let value = temperature << 2;
              value = (value | meltableType) << 2;
              value = (value | burnableType) << 2;
              value = (value | flameHeatType) << 2;
              value = (value | flammableType) << 8;
              value = (value | behaviour8) << 8;
              value = value | type8;
              return value;
          }

          static type8(typeClass, typeModifiers = 0) {
              return typeClass | (typeModifiers << 3);
          }

          static type8Powder(typeClass, momentum = 0, sliding = 0, direction = 0) {
              let value = momentum << 1;
              value = (value | direction) << 1;
              value = (value | sliding) << 3;
              value = value | typeClass;
              return value;
          }

          // TODO TYPE_FLUID: density, step size, ? viscosity, ? pressure
          static type8Fluid(typeClass) {
              return typeClass;
          }

          static behaviour8(behaviour, special = 0) {
              return behaviour | (special << 4);
          }

          // get methods

          static getType(elementHead) {
              return elementHead & 0x000000FF;
          }

          static getTypeClass(elementHead) {
              return elementHead & 0x00000007;
          }

          static getTypeModifierPowderSliding(elementHead) {
              return (elementHead >> 3) & 0x00000001;
          }

          static getTypeModifierPowderDirection(elementHead) {
              return (elementHead >> 4) & 0x00000001;
          }

          static getTypeModifierPowderMomentum(elementHead) {
              return (elementHead >> 5) & 0x00000007;
          }

          static getBehaviour(elementHead) {
              return (elementHead >> 8) & 0x0000000F;
          }

          static getSpecial(elementHead) {
              return (elementHead >> 12) & 0x0000000F;
          }

          static getFlammableType(elementHead) {
              return (elementHead >> 16) & 0x00000003;
          }

          static getFlameHeatType(elementHead) {
              return (elementHead >> 18) & 0x00000003;
          }

          static getBurnableType(elementHead) {
              return (elementHead >> 20) & 0x00000003;
          }

          static getConductivityType(elementHead) {
              return (elementHead >> 22) & 0x00000003;
          }

          static getTemperature(elementHead) {
              return (elementHead >> 24) & 0x000000FF;
          }

          // set methods

          static setType(elementHead, type) {
              return (elementHead & 0xFFFFFF00) | type;
          }

          static setTypeClass(elementHead, type) {
              return (elementHead & 0xFFFFFFF8) | type;
          }

          static setTypeModifierPowderSliding(elementHead, val) {
              return (elementHead & 0xFFFFFFF7) | (val << 3);
          }

          static setTypeModifierPowderDirection(elementHead, val) {
              return (elementHead & 0xFFFFFFEF) | (val << 4);
          }

          static setTypeModifierPowderMomentum(elementHead, val) {
              return (elementHead & 0xFFFFFF1F) | (val << 5);
          }

          static setBehaviour(elementHead, behaviour) {
              return (elementHead & 0xFFFFF0FF) | (behaviour << 8);
          }

          static setSpecial(elementHead, special) {
              return (elementHead & 0xFFFF0FFF) | (special << 12);
          }

          static setTemperature(elementHead, temperature) {
              return (elementHead & 0x00FFFFFF) | (temperature << 24);
          }
      }

      /**
       * @interface
       *
       * @author Patrik Harag
       * @version 2023-02-20
       */
      class Brush {

          /**
           *
           * @param x
           * @param y
           * @param random {DeterministicRandom}
           * @param oldElement {Element}
           * @return {Element}
           */
          apply(x, y, random = undefined, oldElement = undefined) {
              throw 'Not implemented'
          }


          // static factory methods

          /**
           *
           * @param elements {Element[]}
           * @returns {Brush}
           */
          static random(elements) {
              return new RandomBrush(elements);
          }

          static randomFromHeadAndTails(elementHead, elementTails) {
              let elements = [];
              for (let elementTail of elementTails) {
                  elements.push(new Element(elementHead, elementTail));
              }
              return new RandomBrush(elements);
          }

          static textureBrush(innerBrush, base64) {
              return new TextureBrush(innerBrush, base64);
          }

          /**
           *
           * @param func {function(x: number, y: number, random: DeterministicRandom, oldElement: Element)}
           * @returns {Brush}
           */
          static custom(func) {
              return new CustomBrush(func);
          }

          /**
           *
           * @param brush {Brush}
           * @param intensity {number} 0..1
           * @returns {Brush}
           */
          static withIntensity(brush, intensity) {
              return Brush.custom((x, y, random, oldElement) => {
                  let rnd = (random) ? random.next() : Math.random();
                  if (rnd < intensity) {
                      return brush.apply(x, y, random, oldElement);
                  }
                  return null;
              });
          }

          /**
           * Brush will not paint over other elements.
           *
           * @param brush {Brush}
           */
          static gentle(brush) {
              return Brush.custom((x, y, random, oldElement) => {
                  if (ElementHead.getTypeClass(oldElement.elementHead) === ElementHead.TYPE_AIR) {
                      return brush.apply(x, y, random, oldElement);
                  }
                  return null;
              });
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-02-20
       */
      class RandomBrush extends Brush {

          /** @type Element[] */
          #elements;

          constructor(elements) {
              super();
              this.#elements = elements;
          }

          apply(x, y, random, oldElement) {
              if (this.#elements.length > 1) {
                  let i;
                  if (random) {
                      i = random.nextInt(this.#elements.length);
                  } else {
                      i = Math.trunc(Math.random() * this.#elements.length);
                  }
                  return this.#elements[i];
              } else {
                  return this.#elements[0];
              }
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-02-20
       */
      class TextureBrush extends Brush {

          /** @type Brush */
          #innerBrush;

          /** @type ImageData|null */
          #imageData = null;

          constructor(innerBrush, base64) {
              super();
              this.#innerBrush = innerBrush;

              Assets.asImageData(base64).then(imageData => this.#imageData = imageData);
          }

          apply(x, y, random, oldElement) {
              const element = this.#innerBrush.apply(x, y, random);

              if (this.#imageData != null) {
                  const cx = x % this.#imageData.width;
                  const cy = y % this.#imageData.height;
                  const index = (cy * this.#imageData.width + cx) * 4;

                  const red = this.#imageData.data[index];
                  const green = this.#imageData.data[index + 1];
                  const blue = this.#imageData.data[index + 2];
                  // const alpha = this.#imageData.data[index + 3];

                  element.elementTail = ElementTail.setColor(element.elementTail, red, green, blue);
              }
              return element;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-02-20
       */
      class CustomBrush extends Brush {

          /** @type function(x: number, y: number, random: DeterministicRandom, oldElement: Element) */
          #func;

          constructor(func) {
              super();
              this.#func = func;
          }

          apply(x, y, random, oldElement) {
              return this.#func(x, y, random, oldElement);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-10-11
       */
      class ElementArea {

          /**
           * This element is used for templates etc.
           * @type {Element}
           */
          static TRANSPARENT_ELEMENT = new Element(0xFFFFFFFF, 0xFFFFFFFF);

          static LITTLE_ENDIAN = true;

          static create(width, height, defaultElement) {
              let bufferHeads = new DataView(new ArrayBuffer(width * height * 4));
              let bufferTails = new DataView(new ArrayBuffer(width * height * 4));
              let instance = new ElementArea(width, height, bufferHeads, bufferTails);

              // set default elements
              for (let y = 0; y < instance.#height; y++) {
                  for (let x = 0; x < instance.#width; x++) {
                      instance.setElement(x, y, defaultElement);
                  }
              }
              return instance;
          }

          /**
           *
           * @param width
           * @param height
           * @param dataHeads {ArrayBuffer}
           * @param dataTails {ArrayBuffer}
           * @returns {ElementArea}
           */
          static from(width, height, dataHeads, dataTails) {
              return new ElementArea(width, height, new DataView(dataHeads), new DataView(dataTails));
          }


          /** @type number */
          #width;

          /** @type number */
          #height;

          /** @type DataView */
          #bufferHeads;

          /** @type DataView */
          #bufferTails;

          constructor(width, height, bufferHeads, bufferTails) {
              this.#width = width;
              this.#height = height;
              this.#bufferHeads = bufferHeads;
              this.#bufferTails = bufferTails;
          }

          isValidPosition(x, y) {
              if (x < 0 || y < 0) {
                  return false;
              }
              if (x >= this.#width || y >= this.#height) {
                  return false;
              }
              return true;
          }

          setElement(x, y, element) {
              if (element !== null) {
                  this.setElementHeadAndTail(x, y, element.elementHead, element.elementTail);
              }
              // brushes can produce nulls
          }

          setElementHeadAndTail(x, y, elementHead, elementTail) {
              const byteOffset = (this.#width * y + x) * 4;
              this.#bufferHeads.setUint32(byteOffset, elementHead, ElementArea.LITTLE_ENDIAN);
              this.#bufferTails.setUint32(byteOffset, elementTail, ElementArea.LITTLE_ENDIAN);
          }

          setElementHead(x, y, elementHead) {
              const byteOffset = (this.#width * y + x) * 4;
              this.#bufferHeads.setUint32(byteOffset, elementHead, ElementArea.LITTLE_ENDIAN);
          }

          setElementTail(x, y, elementTail) {
              const byteOffset = (this.#width * y + x) * 4;
              this.#bufferTails.setUint32(byteOffset, elementTail, ElementArea.LITTLE_ENDIAN);
          }

          getElement(x, y) {
              const byteOffset = (this.#width * y + x) * 4;
              const elementHead = this.#bufferHeads.getUint32(byteOffset, ElementArea.LITTLE_ENDIAN);
              const elementTail = this.#bufferTails.getUint32(byteOffset, ElementArea.LITTLE_ENDIAN);
              return new Element(elementHead, elementTail);
          }

          getElementHead(x, y) {
              const byteOffset = (this.#width * y + x) * 4;
              return this.#bufferHeads.getUint32(byteOffset, ElementArea.LITTLE_ENDIAN);
          }

          getElementHeadOrNull(x, y) {
              if (this.isValidPosition(x, y)) {
                  return this.getElementHead(x, y);
              }
              return null;
          }

          getElementTail(x, y) {
              const byteOffset = (this.#width * y + x) * 4;
              return this.#bufferTails.getUint32(byteOffset, ElementArea.LITTLE_ENDIAN);
          }

          getElementTailOrNull(x, y) {
              if (this.isValidPosition(x, y)) {
                  return this.getElementTail(x, y);
              }
              return null;
          }

          swap(x, y, x2, y2) {
              const elementHead = this.getElementHead(x, y);
              const elementHead2 = this.getElementHead(x2, y2);
              this.setElementHead(x2, y2, elementHead);
              this.setElementHead(x, y, elementHead2);

              const elementTail = this.getElementTail(x, y);
              const elementTail2 = this.getElementTail(x2, y2);
              this.setElementTail(x2, y2, elementTail);
              this.setElementTail(x, y, elementTail2);
          }

          /**
           *
           * @return {ArrayBuffer}
           */
          getDataHeads() {
              return this.#bufferHeads.buffer;
          }

          /**
           *
           * @return {ArrayBuffer}
           */
          getDataTails() {
              return this.#bufferTails.buffer;
          }

          /**
           *
           * @return {number}
           */
          getWidth() {
              return this.#width;
          }

          /**
           *
           * @return {number}
           */
          getHeight() {
              return this.#height;
          }
      }

      /**
       * @interface
       *
       * @author Patrik Harag
       * @version 2023-05-04
       */
      class CursorDefinition {

          /**
           *
           * @return {number}
           */
          getWidth() {
              throw 'Not implemented';
          }

          /**
           *
           * @return {number}
           */
          getHeight() {
              throw 'Not implemented';
          }
      }

      /**
       * @author Patrik Harag
       * @version 2023-05-04
       */
      class CursorDefinitionElementArea extends CursorDefinition {

          /** @type ElementArea */
          #elementArea;

          constructor(elementArea) {
              super();
              this.#elementArea = elementArea;
          }

          getWidth() {
              return this.#elementArea.getWidth();
          }

          getHeight() {
              return this.#elementArea.getHeight();
          }

          getElementArea() {
              return this.#elementArea;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-18
       */
      class VisualEffects {

          static isVisualBurnApplicable(elementHead) {
              const type = ElementHead.getTypeClass(elementHead);
              return type > ElementHead.TYPE_FLUID || type === ElementHead.TYPE_POWDER_FLOATING;
          }

          static visualBurn(elementTail, force = 1, maxBurntLevel = 3) {
              const burntLevel = ElementTail.getBurntLevel(elementTail);
              if (burntLevel > 2) {
                  return elementTail;
              }

              let newTail = elementTail;

              let newBurntLevel = burntLevel + force;
              newBurntLevel = Math.min(newBurntLevel, maxBurntLevel);
              newBurntLevel = Math.max(newBurntLevel, 0);

              const appliedForce = newBurntLevel - burntLevel;
              if (appliedForce > 0) {
                  newTail = ElementTail.setBurntLevel(newTail, newBurntLevel);

                  let red = ElementTail.getColorRed(elementTail);
                  let green = ElementTail.getColorGreen(elementTail);
                  let blue = ElementTail.getColorBlue(elementTail);

                  let divisor = 1.8 - (Math.random() * 0.5);
                  if (appliedForce > 1) {
                      divisor = divisor * (1.8 - (Math.random() * 0.5));
                  }
                  if (appliedForce > 2) {
                      divisor = divisor * (1.8 - (Math.random() * 0.5));
                  }

                  red = Math.trunc(red / divisor);
                  green = Math.trunc(green / divisor);
                  blue = Math.trunc(blue / divisor);

                  newTail = ElementTail.setColor(newTail, red, green, blue);
              }

              return newTail;
          }
      }

      var img$l = "data:image/png;base64,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";
      var img$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAKFJREFUOE9jvHG06T+fmB7Dz28vGUDg55eXDCj8ry8Z+EQR8l/f32UQkraCq2fEZgBIwdePdyEGUmoAuo0EXQBSIKbgBncBugZ0F2F4AZsByAYSNAAUiMhhgG4gUQYgxwLVDSAYiOjpgORYIMsAlISDJSUKSSESFlYvoIc6clIFhTqyAVhjAa8BaNFKsQEEYwEj6RLInViTMnoYIGdndC8AAKMLhKB4CiI3AAAAAElFTkSuQmCC"
      var img$3 ="data:image/png;base64,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"
      var img$4 ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAACCRJREFUeF7tXdF12zoMpbqAN1C8QDZQlUWySaeLm0HqbJAFqh7QpiszUkLiIgIkQT/Ne0cUQeASoHlBsOm6bgjM5/X1NbyEl9D3/f8vpD9PzI9WNDudTuEpPIWu626tDodD/Pv9/b3iS7xXtzD+5vHxsQoAScH0Lyn594/fIYzsH1WZG18SDKkv+vcUws+/P0OSKZkxN74kGLY2/moAJCUnRUQA5I+kwecm5xUIBID8kTT4XPdbGT8bAKQYUkIEwBIGn7JEf/EASxh8qvstjN8BwAv/sZUDwD3A6j0g5AHI9Z6PZ7UQcA7n8Nw9q4WALYzfAQCEAAeAe4DVe0DYA5zeTuEhPADziN+UQkDf9h/2AfhfrGtJHmDt43cA1Nn87m0HwAZmAGD/uPh0D+AhYNUhkB0C0u4bzQB6ll4HUPynh9YAaVMGmc21bbcy/mIA5Nutb29vUWfEBk4BQBoQyeDJUOm/iQ2kp23bOxvmBFGtgfP3tzr+pm3bKjZwrBgCAQFA2tilxiIQEABy45e2R9/bwviboR/YAED5eAt8egwjK81nkNBfM4RKAFTy8bnrtManXxYSmS8wlM/w3fqrB0DSFcjHW+HTJ8PAEvS2Ef3xAXCdOQgfb4FOjQBYwuBTSAPzGST05wBwAFSuAcZINoBgaCW/YALrpJwG9Ad5AJSPt0CnPvQPaiHAgv4cAA4AfgiwgGAkBJD87gFq9wFGGkf5eA8BWD6DBBsJhwAkIcMB4ABQT6nSDgHoBELzEdwDKC8CVwsAlI9Pe9zaaeUWPAAtq2rpa6l8hGIPgPLxc3z60A+qv8O1AXAMx6J8hu/KR2j+hD9sOhjl44lPdwAc2fkMEvkIzUt4GTT58Ni3EhljYR8g/pRWzEe4JIQo8uGabJwFAMQQpKj/6YygJWbkeNBL9DexZWgGALlsS+jjqv8LAJbocIYPdw+gR0aR53EAKO8DaP4KcQAYIIN2DQAzMVgpBFoYv2oIsKAAzRloYfwOgB2vAQiAcSdQ82QP/Qrw/vXqKzgAdg5AB4ADwEPAnkPQjQ1cWgk5vez9L7sOSPqPbODUQkzaIHP5BGmHOO/P+5cFxJz+IwCklV2aqp2E8v5ljV2jfygfAK0PUCro3HsS5+MRGWj8SH0BC/r7Oh8g3yatrA9ACpKs5r26+gLG9cfPBwDPtyMzb5xEqX1fAbu+gBH9YVvB4OlWCRBo31cA5TMY0J8DAEEherzcAYBo38aFDbv2AOjpYMz8l8Xlmg+WWNAfFAIsDMABwJ9GNIEcAHz9BTShw8IEgthAtD4AoPvYVOJ8PCIDupPpAEC07wAAtXeZQO4BADW6B/ArWyJ8uGSWmRDAGQRaHwCYeLf4T39o31eQxlELgqQ/7WvvivMB0PoAUgZP37FyX8EcAHJAzOnvV/dLlCyr0XNcAyD5AGh9gBphp96VOB+PyCCxBjABAM3z6WQAbv8W+HS6MAORXx0AJuoDfHY+3jifHtlIUH7JfIkaj/Z/JzBvtcRZuVxpYxlK+jfCp7PzEUby6wOgROE10Cp9dwN0KpSPoEwHw1xAqZ1n33MABOTCDVT/DgBQg/CNHXv3AFtg0xA62sROoGaNIAfAOajvBDoA+HEAzUgy4QHWXB9g7fkIFuSH6GD+3Lm0lNhKRapto/KjCSkOgOsN4LVMWjKcBQUi9fotyO8eAHADm/EAnHwAQG937h/l0ykE0FNbbx+VH63XbyWfojgfAFUYWh9g7fkIVuWH8gGkQIGsAZ7CE7vePio/mo9gIZ9i+nRwoWYkzscj+QCFYs6+hsqv3b+E/MVXxtwGm9UHiP8f4MO/bE8vSLKVtfJr9/9FPgSqv3oAJCQI8fmTs0jS4HPTFJUfnf5o/2j7q/x8AIxnPtdgKB0sZQSu/Nr9C+jPASDt4mtAgRoQbR/owgjg7uBb7OfOIIEB1Oj7w7tr719AfggAEnTu3su1I+NH9U8TwgGw4nLxDgDI/1/YSGQGgt3D/UvID3sAUgKyk4e01zaARP/I+FE6XSQEaA8AMYLEDEL719afewDlNYADAAghyOyjtu4BgF8BOb1Zuw5A20sYP84+Ax6A4wWk9FccAr6Lz0+G1LovQPv28rmFXGl9AVR/txtDODMKXYWi7Tkyj9vEnDzl6+tjGAq8+wIk9NeEEIau6256SalVS5xYtVDv3wIAuPUF0AlA+QRN13VDnk+XG18SDCbr/XO5DNACt0XoZ/kU0mRVlg8RAZCPQ9LgczpKQGCfrweVf5fEog2AfCxLyHMFQgTAEgafshd8ulYKBEsofEJW7Z+h8fp4B4BwylkFKB0Ah0OAKmxUKHvyVQE+HRFh9wBAT9ciyreyE6i9EaUaAhwA+nS0A0B5K9g9wPEsm/dfERckdtIquvvwqvYagPrfvQfgEDGI0fOtaPcA7gFUPaB7gJ3nIzgArj6Zy8hxw8Ft/aG8CN09AEr5eK6hU7u5fAptNtIBAPDxEqBwACgvAo/hGDTzIYZ+8EWg6Pn/imlJbpkqdarnQyiykbsPAQQA9XwIB0DFtBV8NXmAveZD+E7gNQQ4AN7fBedV+acssIGa1bq1M6LcAyh7AAsTwBeB3bPqxY3IhRPlvnb6TfcA7gFC07bth3MBKLJK26PFlkv7mXsvngxq+8XrDCd5LIzfAeAAcA+wdKVx9wBXDVhwgR4C2jYeDVt6FqD19iXiP31jrfcNSI0/ng6mj7Vte/dNaUDku21Uap0eun2bHq36AFRufs/jjwDIjY+iq7Q9Wm+/tJ/PfgWs+b4BifH/AyLrkBCXCCRdAAAAAElFTkSuQmCC"
      var img$a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAALhJREFUWEdj/LPQ5j/DAAJGsAM+PSLohD8fnzKwyFoyEKMWZBgx6kFqRh0wGgLgEPjz+DjBREiOAlCiJWQ2JAoGEDD+mSyH4QBishDMzcSoxadm1AGMP1qYsaYBYhIQLBqIUYtLzSBIhETWBcSW76QmTqJLwlEHDO8QIFReI5fUxGQ5UrLnIMiGo3XBiA+B0cqI2I4JcllAaSsIucIiqTIitaYj1JMiqWc0GgI0DQFSKiNSKhpiKi4AJC3G9LKZja0AAAAASUVORK5CYIIA";

      // TODO: create some abstraction for brushes that are needed in core processing and move this into /def

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-20
       */
      class Brushes {

          // TEST brushes
          // bright color for testing purposes

          static _TEST_SOLID = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC),
                  ElementTail.of(255, 0, 125))
          ]);

          static _TEST_AIR = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_AIR),
                  ElementTail.of(255, 0, 125))
          ]);

          static _TEST_FLAMMABLE_SOLID_M = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, 0,
                      ElementHead.FLAMMABLE_TYPE_FAST, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_NEVER),
                  ElementTail.of(25, 52, 56))
          ]);

          static _TEST_FLAMMABLE_SOLID_H = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, 0,
                      ElementHead.FLAMMABLE_TYPE_FAST, ElementHead.FLAME_HEAT_TYPE_HIGH, ElementHead.BURNABLE_TYPE_NEVER),
                  ElementTail.of(25, 56, 49))
          ]);

          static _TEST_FLAMMABLE_SOLID_E = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, 0,
                      ElementHead.FLAMMABLE_TYPE_FAST, ElementHead.FLAME_HEAT_TYPE_EXTREME, ElementHead.BURNABLE_TYPE_NEVER),
                  ElementTail.of(25, 33, 56))
          ]);

          // ---

          static AIR = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_AIR),
                  ElementTail.of(255, 255, 255, ElementTail.BLUR_TYPE_BACKGROUND))
          ]);

          static WALL = Brush.textureBrush(
              Brush.random([new Element(ElementHead.of(ElementHead.TYPE_STATIC), 0)]),
              img$a); 

          static GLITCH = Brush.textureBrush(
              Brush.random([new Element(ElementHead.of(ElementHead.TYPE_STATIC), 0)]),
              img$4); 

          static ROCK = Brush.textureBrush(
              Brush.random([new Element(ElementHead.of(ElementHead.TYPE_STATIC), 0)]),
              img$l);

          static WAX = Brush.textureBrush(
              Brush.random([new Element(ElementHead.of(ElementHead.TYPE_STATIC), 0)]),
              img$3);

          static WOOD = Brush.textureBrush(
              Brush.random([new Element(ElementHead.of(ElementHead.TYPE_STATIC,ElementHead.FLAMMABLE_TYPE_SLOW, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_SLOW), 0)]),
              img$2);
          static SAND = Brush.custom((x, y, random) => {
              const type = random.nextInt(100) < 60 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
              const elementHead = ElementHead.of(ElementHead.type8Powder(type, 6));

              let elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1);
              const colors = [
                  [228,211,162], [233,220,181], [239,229,199], [244,237,218],
                  [250,246,236]
              ];
              const [r, g, b] = colors[Math.trunc(random.nextInt(colors.length))];
              elementTail = ElementTail.setColor(elementTail, r, g, b);

              return new Element(elementHead, elementTail);
          });

          static RED_SAND = Brush.custom((x, y, random) => {
              const type = random.nextInt(100) < 60 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
              const elementHead = ElementHead.of(ElementHead.type8Powder(type, 6));

              let elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1);
              const colors = [
                  [136,33,33], [161,39,39], [186,45,45], [207,55,55],
                  [213,80,80], [217,181,181],[201,148,148],[201,165,165]
              ];
              const [r, g, b] = colors[Math.trunc(random.nextInt(colors.length))];
              elementTail = ElementTail.setColor(elementTail, r, g, b);

              return new Element(elementHead, elementTail);
          });

          static SOIL = Brush.custom((x, y, random) => {
              const type = random.nextInt(100) < 40 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
              const elementHead = ElementHead.of(
                      ElementHead.type8Powder(type, 5), ElementHead.behaviour8(ElementHead.BEHAVIOUR_SOIL));

              let elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1);
              const colors = [
                   [249,192,46], [249,176,46]
              ];
              const [r, g, b] = colors[Math.trunc(random.nextInt(colors.length))];
              elementTail = ElementTail.setColor(elementTail, r, g, b);

              return new Element(elementHead, elementTail);
          });

          static STONE = Brush.custom((x, y, random) => {
              const type = random.nextInt(100) < 20 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
              const elementHead = ElementHead.of(ElementHead.type8Powder(type, 3));

              let elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1);
              const colors = [
                 [229,172,26], [229,156,26],
                [238,211,172], [253,230,191], 
              ];
              const [r, g, b] = colors[Math.trunc(random.nextInt(colors.length))];
              elementTail = ElementTail.setColor(elementTail, r, g, b);

              return new Element(elementHead, elementTail);
          });

          static BLUE_STONE = Brush.custom((x, y, random) => {
              const type = random.nextInt(100) < 20 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
              const elementHead = ElementHead.of(ElementHead.type8Powder(type, 3));

              let elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1);
              const colors = [
                 [217,205,181], [201,195,165],
                [201,181,148], [ 62,102,141], [154,167,180],
              ];
              const [r, g, b] = colors[Math.trunc(random.nextInt(colors.length))];
              elementTail = ElementTail.setColor(elementTail, r, g, b);

              return new Element(elementHead, elementTail);
          });

          static WATER = Brush.randomFromHeadAndTails(ElementHead.of(ElementHead.type8Fluid(ElementHead.TYPE_FLUID)), [
              ElementTail.of(255, 166, 0, ElementTail.BLUR_TYPE_1),
              ElementTail.of(255, 160,0, ElementTail.BLUR_TYPE_1)
          ]);
          static SAUCE = Brush.randomFromHeadAndTails(ElementHead.of(ElementHead.type8Fluid(ElementHead.TYPE_FLUID)), [
              ElementTail.of(238, 196, 96, ElementTail.BLUR_TYPE_1),
              ElementTail.of(218, 176, 76, ElementTail.BLUR_TYPE_1)
          ]);

          static GRASS = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.type8Powder(ElementHead.TYPE_POWDER, 0),
                      ElementHead.behaviour8(ElementHead.BEHAVIOUR_GRASS, 5),
                      ElementHead.FLAMMABLE_TYPE_MEDIUM, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_FAST),
                  ElementTail.of(218, 116, 3, ElementTail.BLUR_TYPE_1)),
              new Element(
                  ElementHead.of(ElementHead.type8Powder(ElementHead.TYPE_POWDER, 0),
                      ElementHead.behaviour8(ElementHead.BEHAVIOUR_GRASS, 3),
                      ElementHead.FLAMMABLE_TYPE_MEDIUM, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_FAST),
                  ElementTail.of(238, 136, 23, ElementTail.BLUR_TYPE_1)),
              new Element(
                  ElementHead.of(ElementHead.type8Powder(ElementHead.TYPE_POWDER, 0),
                      ElementHead.behaviour8(ElementHead.BEHAVIOUR_GRASS, 4),
                      ElementHead.FLAMMABLE_TYPE_MEDIUM, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_FAST),
                  ElementTail.of(228, 126, 13 ,ElementTail.BLUR_TYPE_1))
          ]);

          static FISH = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_FISH, 0)),
                  ElementTail.of(152, 88, 29)),
          ]);

          static FISH_BODY = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_FISH_BODY, 0)),
                  ElementTail.of(152, 88, 29)),
          ]);

          static FISH_CORPSE = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.type8Powder(ElementHead.TYPE_POWDER, 2)),
                  ElementTail.of(50, 44, 12)),
          ]);

          static TREE = Brush.custom((x, y, random) => {
              let treeType = random.nextInt(17);
              return new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE, treeType),
                      ElementHead.FLAMMABLE_TYPE_SLOW, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_SLOW),
                  ElementTail.of(221,180,117));
          });

          static TREE_ROOT = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_ROOT, 8),
                      ElementHead.FLAMMABLE_TYPE_SLOW, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_SLOW),
                  ElementTail.of(193,150,80)),
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_ROOT, 5),
                      ElementHead.FLAMMABLE_TYPE_SLOW, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_SLOW),
                  ElementTail.of(213,165,93))
          ]);

          static TREE_WOOD = Brush.randomFromHeadAndTails(
              ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_TRUNK, 0),
                  ElementHead.FLAMMABLE_TYPE_SLOW, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_SLOW), [
                  ElementTail.of(221,180,117),
                  ElementTail.of(227,203,156)
          ]);


          static TREE_LEAF_LIGHTER = Brush.randomFromHeadAndTails(
              ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_LEAF, 0),
                  ElementHead.FLAMMABLE_TYPE_MEDIUM, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_MEDIUM), [
                  ElementTail.of(251,219,101),
          ]);

          static TREE_LEAF_DARKER = Brush.randomFromHeadAndTails(
              ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_LEAF, 0),
                  ElementHead.FLAMMABLE_TYPE_MEDIUM, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_MEDIUM), [
                  ElementTail.of(251,219,101),
          ]);

          static TREE_LEAF_DEAD = Brush.randomFromHeadAndTails(
              ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_TREE_LEAF, 15),
                  ElementHead.FLAMMABLE_TYPE_FAST, ElementHead.FLAME_HEAT_TYPE_MEDIUM, ElementHead.BURNABLE_TYPE_MEDIUM), [
                  ElementTail.of(248,132, 2),
                  ElementTail.of(185, 99, 75),
                  ElementTail.of(212, 161, 60),
          ]);

          static #FIRE_ELEMENT_HEAD = ElementHead.of(ElementHead.TYPE_EFFECT, ElementHead.behaviour8(ElementHead.BEHAVIOUR_FIRE, 0));
          static FIRE = Brush.random([
              new Element(ElementHead.setTemperature(Brushes.#FIRE_ELEMENT_HEAD, 255), ElementTail.of(252, 147, 30)),
              new Element(ElementHead.setTemperature(Brushes.#FIRE_ELEMENT_HEAD, 255), ElementTail.of(252, 147, 30)),
              new Element(ElementHead.setTemperature(Brushes.#FIRE_ELEMENT_HEAD, 120), ElementTail.of(252, 147, 30))
          ]);

          static ASH = Brush.custom((x, y, random) => {
              const type = random.nextInt(100) < 80 ? ElementHead.TYPE_POWDER : ElementHead.TYPE_POWDER_WET;
              const elementHead = ElementHead.of(ElementHead.type8Powder(type, 6));

              let elementTail = ElementTail.of(0, 0, 0, ElementTail.BLUR_TYPE_1);
              const colors = [
                  [188, 127, 21],
                  [189, 128, 22],
                  [190, 129, 23],
                  [191, 130, 24],
                  [192, 131, 25],
                  [193, 132, 26],
                  [194, 133, 27],
              ];
              const [r, g, b] = colors[Math.trunc(random.nextInt(colors.length))];
              elementTail = ElementTail.setColor(elementTail, r, g, b);

              return new Element(elementHead, elementTail);
          });

          static METEOR = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_METEOR, 0)),
                  ElementTail.of(252, 147, 30))
          ]);

          static METEOR_FROM_LEFT = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_METEOR, 1 << 1)),
                  ElementTail.of(252, 147, 30))
          ]);

          static METEOR_FROM_RIGHT = Brush.random([
              new Element(
                  ElementHead.of(ElementHead.TYPE_STATIC, ElementHead.behaviour8(ElementHead.BEHAVIOUR_METEOR, 2 << 1)),
                  ElementTail.of(252, 147, 30))
          ]);

          static EFFECT_BURNT = Brush.custom((x, y, random, oldElement) => {
              if (VisualEffects.isVisualBurnApplicable(oldElement.elementHead)) {
                  const burntLevel = ElementTail.getBurntLevel(oldElement.elementTail);
                  if (burntLevel < 3) {
                      return new Element(oldElement.elementHead, VisualEffects.visualBurn(oldElement.elementTail, 1));
                  }
              }
              return null;
          });

          // --- SEARCH

          static LIST = [
              { codeName: 'air', brush: Brushes.AIR },
              { codeName: 'ash', brush: Brushes.ASH },
              { codeName: 'sand', brush: Brushes.SAND },
              { codeName: 'red_sand', brush: Brushes.RED_SAND },
              { codeName: 'soil', brush: Brushes.SOIL },
              { codeName: 'gravel', brush: Brushes.STONE },
              { codeName: 'blue_stone', brush: Brushes.BLUE_STONE },
              { codeName: 'wall', brush: Brushes.WALL },
              { codeName: 'glitch', brush: Brushes.GLITCH },
              { codeName: 'rock', brush: Brushes.ROCK },
              { codeName: 'wax', brush: Brushes.WAX },
              { codeName: 'fish', brush: Brushes.FISH },
              { codeName: 'tree', brush: Brushes.TREE },
              { codeName: 'wood', brush: Brushes.TREE_WOOD },
              { codeName: 'real_wood', brush: Brushes.WOOD },
              { codeName: 'water', brush: Brushes.WATER },
              { codeName: 'sauce', brush: Brushes.SAUCE },
              { codeName: 'fire', brush: Brushes.FIRE },
              { codeName: 'meteor', brush: Brushes.METEOR },
              { codeName: 'meteor_l', brush: Brushes.METEOR_FROM_LEFT },
              { codeName: 'meteor_r', brush: Brushes.METEOR_FROM_RIGHT },
          ]

          static byCodeName(codeName) {
              for (let brushEntry of Brushes.LIST) {
                  if (brushEntry.codeName === codeName) {
                      return brushEntry.brush;
                  }
              }
              return null;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-07-23
       */
      class Tool {

          /** @type string */
          #category;

          /** @type string */
          #codeName;

          /** @type string */
          #displayName;

          constructor(category, codeName, displayName) {
              this.#category = category;
              this.#codeName = codeName;
              this.#displayName = displayName;
          }

          /**
           *
           * @return {string}
           */
          getCategory() {
              return this.#category;
          }

          /**
           *
           * @return {string}
           */
          getDisplayName() {
              return this.#displayName;
          }

          /**
           *
           * @return {string}
           */
          getCodeName() {
              return this.#codeName;
          }

          isStrokeEnabled() {
              return false;
          }

          isSelectionEnabled() {
              return false;
          }

          /**
           * @return {CursorDefinition|null}
           */
          createCursor() {
              // default cursor
              return null;
          }

          /**
           *
           * @param x {number}
           * @param y {number}
           * @param graphics {SandGameGraphics}
           * @param altModifier {boolean}
           * @return {void}
           */
          applyPoint(x, y, graphics, altModifier) {
              throw 'Not implemented';
          }

          /**
           *
           * @param x1 {number}
           * @param y1 {number}
           * @param x2 {number}
           * @param y2 {number}
           * @param graphics {SandGameGraphics}
           * @param altModifier {boolean}
           * @return {void}
           */
          applyStroke(x1, y1, x2, y2, graphics, altModifier) {
              // no action by default
          }

          /**
           *
           * @param x1 {number}
           * @param y1 {number}
           * @param x2 {number}
           * @param y2 {number}
           * @param graphics {SandGameGraphics}
           * @param altModifier {boolean}
           * @return {void}
           */
          applyArea(x1, y1, x2, y2, graphics, altModifier) {
              // no action by default
          }

          /**
           *
           * @param x {number}
           * @param y {number}
           * @param graphics {SandGameGraphics}
           * @param altModifier {boolean}
           * @return {void}
           */
          applySpecial(x, y, graphics, altModifier) {
              // no action by default
          }


          // static factory methods

          static rectangleBrushTool(category, codeName, displayName, brush, size) {
              return new RectangleBrushTool(category, codeName, displayName, brush, size);
          }

          static pointBrushTool(category, codeName, displayName, brush) {
              return new PointBrushTool(category, codeName, displayName, brush);
          }

          static meteorTool(category, codeName, displayName) {
              return new MeteorTool(category, codeName, displayName);
          }

          static insertElementAreaTool(category, codeName, displayName, scenes, handler) {
              if (scenes.length === 1) {
                  return new InsertSceneTool(category, codeName, displayName, scenes[0], handler);
              } else {
                  return new InsertRandomSceneTool(category, codeName, displayName, scenes, handler);
              }
          }

          static actionTool(category, codeName, displayName, handler) {
              return new ActionTool(category, codeName, displayName, handler);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-07-23
       */
      class RectangleBrushTool extends Tool {

          /** @type Brush */
          #brush;

          /** @type Brush */
          #altBrush;

          /** @type number */
          #size;

          constructor(category, codeName, displayName, brush, size) {
              super(category, codeName, displayName);
              this.#brush = brush;
              this.#altBrush = Brush.gentle(brush);
              this.#size = size;
          }

          getBrush() {
              return this.#brush;
          }

          isStrokeEnabled() {
              return true;
          }

          isSelectionEnabled() {
              return true;
          }

          applyPoint(x, y, graphics, altModifier) {
              this.applyStroke(x, y, x, y, graphics, altModifier);
          }

          applyStroke(x1, y1, x2, y2, graphics, altModifier) {
              const brush = altModifier ? this.#altBrush : this.#brush;
              graphics.drawLine(x1, y1, x2, y2, this.#size, brush, true);
          }

          applyArea(x1, y1, x2, y2, graphics, altModifier) {
              const brush = altModifier ? this.#altBrush : this.#brush;
              graphics.drawRectangle(x1, y1, x2, y2, brush);
          }

          applySpecial(x, y, graphics, altModifier) {
              const brush = altModifier ? this.#altBrush : this.#brush;
              graphics.floodFill(x, y, brush, 1);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-04-15
       */
      class PointBrushTool extends Tool {

          /** @type Brush */
          #brush;

          constructor(category, codeName, displayName, brush) {
              super(category, codeName, displayName);
              this.#brush = brush;
          }

          applyPoint(x, y, graphics, aldModifier) {
              graphics.draw(x, y, this.#brush);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-10
       */
      class MeteorTool extends Tool {

          constructor(category, codeName, displayName) {
              super(category, codeName, displayName);
          }

          applyPoint(x, y, graphics, aldModifier) {
              const diffSlope4 = Math.trunc(y / 4);
              if (x < diffSlope4 + 10) {
                  // right only
                  graphics.draw(x + diffSlope4, 0, Brushes.METEOR_FROM_RIGHT);
                  return;
              }
              if (x > graphics.getWidth() - diffSlope4 - 10) {
                  // left only
                  graphics.draw(x - diffSlope4, 0, Brushes.METEOR_FROM_LEFT);
                  return;
              }

              if (x < graphics.getWidth() / 2) {
                  if (Math.random() < 0.8) {
                      graphics.draw(x + diffSlope4, 0, Brushes.METEOR_FROM_RIGHT);
                  } else {
                      graphics.draw(x, 0, Brushes.METEOR);
                  }
              } else {
                  if (Math.random() < 0.8) {
                      graphics.draw(x - diffSlope4, 0, Brushes.METEOR_FROM_LEFT);
                  } else {
                      graphics.draw(x, 0, Brushes.METEOR);
                  }
              }
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-05-16
       */
      class InsertSceneTool extends Tool {

          static DEFAULT_W = 30;
          static DEFAULT_H = 30;

          /** @type ElementArea */
          #elementArea;
          /** @type function */
          #onInsertHandler;

          constructor(category, codeName, displayName, scene, onInsertHandler) {
              super(category, codeName, displayName);

              this.#elementArea = scene.createElementArea(
                      InsertSceneTool.DEFAULT_W, InsertSceneTool.DEFAULT_H, ElementArea.TRANSPARENT_ELEMENT);

              this.#onInsertHandler = onInsertHandler;
          }

          applyPoint(x, y, graphics, aldModifier) {
              const elementArea = this.#elementArea;
              const offsetX = x - Math.trunc(elementArea.getWidth() / 2);
              const offsetY = y - Math.trunc(elementArea.getHeight() / 2);

              let brush = Brush.custom((tx, ty) => {
                  const element = elementArea.getElement(tx - offsetX, ty - offsetY);
                  if (element.elementHead !== ElementArea.TRANSPARENT_ELEMENT.elementHead
                          && element.elementTail !== ElementArea.TRANSPARENT_ELEMENT.elementTail) {

                      return element;
                  }
                  return null;
              });
              if (aldModifier) {
                  brush = Brush.gentle(brush);
              }

              for (let i = 0; i < elementArea.getWidth() && offsetX + i < graphics.getWidth(); i++) {
                  const tx = offsetX + i;
                  if (tx < 0) {
                      continue;
                  }

                  for (let j = 0; j < elementArea.getHeight() && offsetY + j < graphics.getHeight(); j++) {
                      const ty = offsetY + j;
                      if (ty < 0) {
                          continue;
                      }

                      graphics.draw(tx, ty, brush);
                  }
              }

              if (this.#onInsertHandler !== undefined) {
                  this.#onInsertHandler();
              }
          }

          createCursor() {
              return new CursorDefinitionElementArea(this.#elementArea);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-07-23
       */
      class InsertRandomSceneTool extends Tool {

          /** @type Scene[] */
          #scenes;

          #currentTool;

          /** @type function */
          #onInsertHandler;

          constructor(category, codeName, displayName, scenes, onInsertHandler) {
              super(category, codeName, displayName);
              this.#scenes = scenes;
              this.#onInsertHandler = onInsertHandler;
              this.#initRandomTool();
          }

          #initRandomTool() {
              if (this.#scenes.length === undefined || this.#scenes.length === 0) {
                  throw 'Scenes not set';
              }

              const i = Math.trunc(Math.random() * this.#scenes.length);
              const scene = this.#scenes[i];
              this.#currentTool = new InsertSceneTool(this.getCategory(), this.getCodeName(), this.getDisplayName(),
                      scene, this.#onInsertHandler);
          }

          applyPoint(x, y, graphics, aldModifier) {
              this.#currentTool.applyPoint(x, y, graphics, aldModifier);
              this.#initRandomTool();
          }

          createCursor() {
              return this.#currentTool.createCursor();
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-04-29
       */
      class ActionTool extends Tool {

          /** @type function */
          #handler;

          constructor(category, codeName, displayName, handler) {
              super(category, codeName, displayName);
              this.#handler = handler;
          }

          applyPoint(x, y, graphics, aldModifier) {
              this.#handler();
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-20
       */
      class Tools {

          static DEFAULT_SIZE = 5;

          static CATEGORY_BRUSH = 'brush';
          static CATEGORY_TEMPLATE = 'Place';

          /** @type Tool[] */
          static DEFAULT_TOOLS = [
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'air', 'Eat', Brushes.AIR, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'sand', 'Parmesan', Brushes.SAND, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'soil', 'Cheese', Brushes.SOIL, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'gravel', 'Moteray Jack', Brushes.STONE,Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'wood', 'Natural Pasta', Brushes.TREE_WOOD, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'real_wood', 'Pasta', Brushes.WOOD, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'rock', 'Medium Cheddar', Brushes.ROCK, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'wall', 'Cheese Bricks', Brushes.WALL, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'water', 'Velveta', Brushes.WATER, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'sauce', 'Cheese Sauce', Brushes.SAUCE, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'grass', 'mac and cheese', Brushes.GRASS, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'blue_stone', 'Blue Cheese', Brushes.BLUE_STONE,Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'red_sand', 'Red Cheese', Brushes.RED_SAND, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'wax', 'Red Pesto', Brushes.WAX, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'glitch', 'Error Cheese', Brushes.GLITCH, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'tree', 'Mac and Tree', Brush.gentle(Brushes.TREE), Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'fish', 'Dead Fishies', Brushes.FISH, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'fire', 'Molten Cheese', Brush.gentle(Brushes.FIRE), Tools.DEFAULT_SIZE),
              Tool.meteorTool(Tools.CATEGORY_BRUSH, 'meteor', 'Falling Molten Cheese'),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'effect_burnt', 'Burnt', Brushes.EFFECT_BURNT, Tools.DEFAULT_SIZE),
              Tool.rectangleBrushTool(Tools.CATEGORY_BRUSH, 'ash', 'Ash', Brushes.ASH, Tools.DEFAULT_SIZE),
          ];

          /** @type Tool[] */
          static TEST_TOOLS = [
          ];

          static byCodeName(codeName) {
              for (let tool of this.DEFAULT_TOOLS) {
                  if (tool.getCodeName() === codeName) {
                      return tool;
                  }
              }
              return null;
          }
      }

      /**
       *
       * @version 2023-07-23
       * @author Patrik Harag
       */
      class Analytics {

          static EVENT_NAME = 'app_sand_game_js';
          static FEATURE_APP_INITIALIZED = 'initialized';

          // options bar
          static FEATURE_PAUSE = 'pause';
          static FEATURE_DRAW_PRIMARY = 'draw_primary';
          static FEATURE_DRAW_SECONDARY = 'draw_secondary';
          static FEATURE_DRAW_TERTIARY = 'draw_tertiary';
          static FEATURE_DRAW_LINE = 'draw_line';
          static FEATURE_DRAW_RECT = 'draw_rect';
          static FEATURE_DRAW_FLOOD = 'draw_flood';
          static FEATURE_STATUS_DISPLAYED = 'status_displayed';
          static FEATURE_OPTIONS_DISPLAYED = 'options_displayed';
          static FEATURE_RENDERER_PIXELATED = 'renderer_pixelated';
          static FEATURE_RENDERER_SHOW_CHUNKS = 'renderer_show_chunks';
          static FEATURE_RENDERER_SHOW_HEATMAP = 'renderer_show_heatmap';
          static FEATURE_CANVAS_SIZE_CHANGE = 'canvas_size_change';
          static FEATURE_SWITCH_SCENE = 'switch_scene';
          static FEATURE_RESTART_SCENE = 'restart_scene';
          static FEATURE_SWITCH_SCALE = 'switch_scale';
          static FEATURE_IO_EXPORT = 'io_export';
          static FEATURE_IO_IMPORT = 'io_import';
          static FEATURE_IO_IMAGE_TEMPLATE = 'io_image_template';

          static #USED_FEATURES = new Set();


          static triggerToolUsed(tool) {
              const category = tool.getCategory();
              if (category === Tools.CATEGORY_BRUSH) {
                  const feature = 'brush_' + tool.getCodeName();
                  Analytics.triggerFeatureUsed(feature);
              } else if (category === Tools.CATEGORY_TEMPLATE) {
                  Analytics.triggerFeatureUsed('brush_template');
              }
          }

          static triggerFeatureUsed(feature) {
              if (!Analytics.#USED_FEATURES.has(feature)) {
                  // report only the first usage
                  Analytics.#USED_FEATURES.add(feature);
                  Analytics.#report({
                      'app_sand_game_js_feature': feature
                  });
              }
          }

          static #report(properties) {
              if (typeof gtag === 'function') {
                  gtag('event', Analytics.EVENT_NAME, properties);
              }
              // console.log('event: ' + Analytics.EVENT_NAME + ' = ' + JSON.stringify(properties));
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2022-09-25
       */
      class Counter {

          #currentValue = 0;
          #lastValue = 0;
          #start = 0;

          tick(currentTimeMillis) {
              this.#currentValue++;
              if (currentTimeMillis - this.#start >= 1000) {
                  this.#lastValue = this.#currentValue;
                  this.#currentValue = 0;
                  this.#start = currentTimeMillis;
              }
          }

          getValue() {
              return this.#lastValue;
          }

          clear() {
              this.#lastValue = 0;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2022-11-04
       */
      class DeterministicRandom {
          /** @type number */
          #last;

          constructor(seed) {
              this.#last = seed;
          }

          next() {
              // Mulberry32
              // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript/47593316#47593316
              let t = this.#last += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
          }

          nextInt(max) {
              return Math.trunc(this.next() * max);
          }

          getState() {
              return this.#last;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-05-16
       */
      class ProcessorContext {

          static OPT_CYCLES_PER_SECOND = 120;
          static OPT_FRAMES_PER_SECOND = 60;


          /**
           * @returns number
           */
          getIteration() {
              throw 'Not implemented';
          }

          /**
           * @returns Element
           */
          getDefaultElement() {
              throw 'Not implemented';
          }

          trigger(x, y) {
              throw 'Not implemented';
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ProcessorModuleFire {

          static #FIRE_MIN_TEMPERATURE = 34;

          static createFireElementHead(temperature) {
              let elementHead = ElementHead.of(ElementHead.TYPE_EFFECT, ElementHead.BEHAVIOUR_FIRE);
              elementHead = ElementHead.setTemperature(elementHead, temperature);
              return elementHead;
          }

          static createFireElementTail(temperature) {
              let elementTail = ElementTail.of(0, 0, 0);

              if (temperature > 213)
                  elementTail = ElementTail.setColor(elementTail, 158, 84, 3);
              else if (temperature > 170)
                  elementTail = ElementTail.setColor(elementTail, 188, 100,  3);
              else if (temperature > 128)
                  elementTail = ElementTail.setColor(elementTail, 218, 116, 3 );
              else if (temperature > 85)
                  elementTail = ElementTail.setColor(elementTail, 248,   132,  3 );
              else if (temperature > 80)
                  elementTail = ElementTail.setColor(elementTail, 252,  147,  30);
              else if (temperature > 75)
                  elementTail = ElementTail.setColor(elementTail,  252, 161,  60);
              else
                  elementTail = ElementTail.setColor(elementTail, 252, 176,  90);

              return elementTail;
          }

          static #asFlameHeat(flameHeatType) {
              return [0, 165, 220, 255][flameHeatType];  // none .. very hot
          }

          static #asBurnDownChangeTo10000(burnableType) {
              return [0, 2, 100, 1000][burnableType];  // none .. fast
          }

          static #asFlammableChangeTo10000(flammableType) {
              return [0, 100, 4500, 10000][flammableType];  // never .. quickly
          }


          /** @type ElementArea */
          #elementArea;

          /** @type DeterministicRandom */
          #random;

          /** @type Element */
          #defaultElement;

          constructor(elementArea, random, defaultElement) {
              this.#elementArea = elementArea;
              this.#random = random;
              this.#defaultElement = defaultElement;
          }

          // FIRE

          behaviourFire(elementHead, x, y) {
              if (this.#random.nextInt(4) !== 0) {
                  return;  // it would disappear too quickly...
              }

              // count new temperature
              const temperature = ElementHead.getTemperature(elementHead);
              const newTemperature = this.#countNewTemperature(x, y, temperature);
              if (newTemperature < ProcessorModuleFire.#FIRE_MIN_TEMPERATURE) {
                  // the fire will disappear
                  this.#elementArea.setElement(x, y, this.#defaultElement);
                  return;
              }

              // spread or update
              const elementHeadAbove = this.#elementArea.getElementHeadOrNull(x, y - 1);
              if (elementHeadAbove !== null && this.#couldBeReplacedByFire(elementHeadAbove)) {
                  this.#elementArea.setElementHead(x, y - 1, ProcessorModuleFire.createFireElementHead(newTemperature));
                  this.#elementArea.setElementTail(x, y - 1, ProcessorModuleFire.createFireElementTail(newTemperature));
              } else {
                  this.#elementArea.setElementHead(x, y, ElementHead.setTemperature(elementHead, newTemperature));
                  this.#elementArea.setElementTail(x, y, ProcessorModuleFire.createFireElementTail(newTemperature));
              }

              // affect near elements:
              //   # #
              //   #O#
              //    #
              this.#fireEffect(x + 1, y - 1, newTemperature);
              this.#fireEffect(x - 1, y - 1, newTemperature);
              this.#fireEffect(x + 1, y, newTemperature);
              this.#fireEffect(x - 1, y, newTemperature);
              this.#fireEffect(x, y + 1, newTemperature);
          }

          #countNewTemperature(x, y, currentTemperature) {
              let newTemperature = currentTemperature
                      + this.#getTemperatureAt(x, y + 1)          // under
                      + this.#getTemperatureAt(x + 1, y + 1)   // under right
                      + this.#getTemperatureAt(x - 1, y + 1);  // under left

              newTemperature = newTemperature / 4;

              if (newTemperature < 76) {
                  if (this.#random.nextInt(2) === 0) {
                      newTemperature -= this.#random.nextInt(10);
                  }
              } else {
                  if (this.#random.nextInt(2) === 0) {
                      newTemperature -= this.#random.nextInt(50);
                  }
              }
              if (newTemperature < 0) {
                  newTemperature = 0;
              }
              return newTemperature;
          }

          #getTemperatureAt(x, y) {
              const elementHead = this.#elementArea.getElementHeadOrNull(x, y);
              if (elementHead !== null) {
                  return ElementHead.getTemperature(elementHead);
              }
              return null;
          }

          #couldBeReplacedByFire(elementHead) {
              return ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_AIR;
          }

          #fireEffect(x, y, temperature) {
              const elementHead = this.#elementArea.getElementHeadOrNull(x, y);
              if (elementHead == null) {
                  return;
              }

              if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_FIRE) {
                  // affect fire
                  const otherTemperature = ElementHead.getTemperature(elementHead);
                  if (otherTemperature < temperature) {
                      const newTemperature = Math.trunc((temperature - otherTemperature) / 2);
                      if (newTemperature > ProcessorModuleFire.#FIRE_MIN_TEMPERATURE) {
                          this.#elementArea.setElementHead(x, y, ProcessorModuleFire.createFireElementHead(newTemperature));
                          this.#elementArea.setElementTail(x, y, ProcessorModuleFire.createFireElementTail(newTemperature));
                      }
                  }
                  return;
              }

              // for air elements...
              if (ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_AIR) {
                  // spreading
                  const newTemperature = Math.trunc(temperature * 0.7);
                  if (newTemperature > ProcessorModuleFire.#FIRE_MIN_TEMPERATURE) {
                      this.#elementArea.setElementHead(x, y, ProcessorModuleFire.createFireElementHead(newTemperature));
                      this.#elementArea.setElementTail(x, y, ProcessorModuleFire.createFireElementTail(newTemperature));
                  }
                  return;
              }

              // for flammable elements...
              const flammableType = ElementHead.getFlammableType(elementHead);
              if (flammableType !== ElementHead.FLAME_HEAT_TYPE_NONE) {
                  if (ElementHead.getBehaviour(elementHead) === ElementHead.BEHAVIOUR_FIRE_SOURCE) {
                      // already in fire
                      return;
                  }

                  const random = this.#random.nextInt(10000);
                  if (random < ProcessorModuleFire.#asFlammableChangeTo10000(flammableType)) {
                      // ignite
                      let modifiedElementHead = ElementHead.setBehaviour(elementHead, ElementHead.BEHAVIOUR_FIRE_SOURCE);
                      modifiedElementHead = ElementHead.setTemperature(modifiedElementHead,
                              ProcessorModuleFire.#asFlameHeat(ElementHead.getFlameHeatType(elementHead)));
                      this.#elementArea.setElementHead(x, y, modifiedElementHead);
                      // change visual
                      const elementTail = this.#elementArea.getElementTail(x, y);
                      this.#elementArea.setElementTail(x, y, VisualEffects.visualBurn(elementTail, 2));
                      return;
                  }
              }

              // visual change
              if (VisualEffects.isVisualBurnApplicable(elementHead)) {
                  if (this.#random.nextInt(10) === 0) {
                      const elementTail = this.#elementArea.getElementTail(x, y);
                      this.#elementArea.setElementTail(x, y, VisualEffects.visualBurn(elementTail, 1, 2));
                  }
              }
          }

          // FIRE SOURCE

          behaviourFireSource(elementHead, x, y) {
              const flameHeat = ProcessorModuleFire.#asFlameHeat(ElementHead.getFlameHeatType(elementHead));

              const burnDownChange = ProcessorModuleFire.#asBurnDownChangeTo10000(ElementHead.getBurnableType(elementHead));
              if (this.#random.nextInt(10000) < burnDownChange) {
                  // burned down
                  if (this.#random.nextInt(100) < 8) {
                      // turn into ash
                      let ashElement = Brushes.ASH.apply(x, y, this.#random);
                      this.#elementArea.setElement(x, y, ashElement);
                      // TODO: keep temperature
                  } else {
                      // turn into fire element
                      this.#elementArea.setElementHead(x, y, ProcessorModuleFire.createFireElementHead(flameHeat));
                      this.#elementArea.setElementTail(x, y, ProcessorModuleFire.createFireElementTail(flameHeat));
                  }
                  return;
              }

              // affect others
              const airFound = this.#fireSourceEffect(x, y + 1, flameHeat)
                      | this.#fireSourceEffect(x, y - 1, flameHeat)
                      | this.#fireSourceEffect(x - 1, y, flameHeat)
                      | this.#fireSourceEffect(x + 1, y, flameHeat);

              if (!airFound) {
                  // extinguish
                  this.#elementArea.setElementHead(x, y, ElementHead.setBehaviour(elementHead, ElementHead.BEHAVIOUR_NONE));
                  return;
              }

              if (ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_STATIC) {
                  // occasionally a falling piece...
                  if (this.#random.nextInt(10000) < 2) {
                      const type = ElementHead.type8Powder(ElementHead.TYPE_POWDER, 5, 1, this.#random.nextInt(2));
                      this.#elementArea.setElementHead(x, y, ElementHead.setType(elementHead, type));
                      return;
                  }
              }

              // update temperature
              this.#elementArea.setElementHead(x, y, ElementHead.setTemperature(elementHead, flameHeat));
          }

          #fireSourceEffect(x, y, temperature) {
              const elementHead = this.#elementArea.getElementHeadOrNull(x, y);
              if (elementHead == null) {
                  return false;
              }

              // air => spawn fire
              if (ElementHead.getTypeClass(elementHead) <= ElementHead.TYPE_EFFECT) {
                  // air found
                  const actualTemperature = this.#random.nextInt(temperature);
                  if (actualTemperature < ProcessorModuleFire.#FIRE_MIN_TEMPERATURE) {
                      return true;
                  }

                  this.#elementArea.setElementHead(x, y, ProcessorModuleFire.createFireElementHead(actualTemperature));
                  this.#elementArea.setElementTail(x, y, ProcessorModuleFire.createFireElementTail(actualTemperature));
                  return true;
              }

              // visual change
              if (VisualEffects.isVisualBurnApplicable(elementHead)) {
                  if (this.#random.nextInt(1000) === 0) {
                      const elementTail = this.#elementArea.getElementTail(x, y);
                      this.#elementArea.setElementTail(x, y, VisualEffects.visualBurn(elementTail, 1, 2));
                  }
              }

              return false;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-07-23
       */
      class CircleIterator {

          // This may look ugly but it's all I need

          // BLUEPRINT_3 and BLUEPRINT_4 are not needed, but they are used frequently

          static BLUEPRINT_3 = [
              '  333',
              ' 32223',
              '3211123',
              '3210123',
              '3211123',
              ' 32223',
              '  333',
          ];

          static BLUEPRINT_4 = [
              '   444   ',
              '  43334',
              ' 4322234',
              '432111234',
              '432101234',
              '432111234',
              ' 4322234',
              '  43334',
              '   444'
          ];

          static BLUEPRINT_9 = [
              '       99999       ',
              '     998888899',
              '   9988777778899',
              '  998776666677899',
              '  987665555566789',
              ' 98766554445566789',
              ' 98765543334556789',
              '9876554322234556789',
              '9876543211123456789',
              '9876543210123456789',
              '9876543211123456789',
              '9876554322234556789',
              ' 98765543334556789',
              ' 98766554445566789',
              '  987665555566789',
              '  998776666677899',
              '   9988777778899',
              '     998888899',
              '       99999'
          ];

          /**
           *
           * @param blueprint {string[]}
           * @param handler {function(dx: number, dy: number, level: number)}
           */
          static iterate(blueprint, handler) {
              const w = blueprint[0].length;
              const h = blueprint.length;
              const offsetX = Math.trunc(w / 2);
              const offsetY = Math.trunc(h / 2);

              for (let i = 0; i < blueprint.length; i++) {
                  const row = blueprint[i];
                  for (let j = 0; j < row.length; j++) {
                      const char = row.charAt(j);
                      if (char !== ' ') {
                          handler(j - offsetX, i - offsetY, +char);
                      }
                  }
              }
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-10
       */
      class ProcessorModuleMeteor {

          // TODO: radius of heat
          // TODO: leave some burning elements behind...
          // TODO: leave some metal behind...
          // TODO: when water hit?
          // TODO: add randomness to destruction

          static EXPLOSION_HEAT = 200;

          static DIRECTION_FROM_TOP = 0;
          static DIRECTION_FROM_LEFT = 1;
          static DIRECTION_FROM_RIGHT = 2;


          /** @type ElementArea */
          #elementArea;

          /** @type DeterministicRandom */
          #random;

          /** @type Element */
          #defaultElement;

          constructor(elementArea, random, defaultElement) {
              this.#elementArea = elementArea;
              this.#random = random;
              this.#defaultElement = defaultElement;
          }

          behaviourMeteor(elementHead, x, y) {
              this.#spawnFire(elementHead, x, y);

              const special = ElementHead.getSpecial(elementHead);
              const move = special & 0x1;
              let newSpecial = special ^ (!move);
              elementHead = ElementHead.setSpecial(elementHead, newSpecial);
              this.#elementArea.setElementHead(x, y, elementHead);
              if (!move) {
                  return;  // move only once per simulation iteration
              }

              // resolve direction
              const slope = 4;
              const direction = (special & (~0x1)) >> 1;
              let tx, ty;
              if (direction === ProcessorModuleMeteor.DIRECTION_FROM_TOP) {
                  ty = y + 1;
                  tx = x;
              } else if (direction === ProcessorModuleMeteor.DIRECTION_FROM_LEFT) {
                  ty = y + 1;
                  tx = x + (ty % slope === 0 ? 1 : 0);
              } else if (direction === ProcessorModuleMeteor.DIRECTION_FROM_RIGHT) {
                  ty = y + 1;
                  tx = x - (ty % slope === 0 ? 1 : 0);
              } else {
                  // unknown direction
                  ty = y + 1;
                  tx = x;
              }

              if (this.#elementArea.isValidPosition(tx, ty)) {
                  let targetElementHead = this.#elementArea.getElementHead(tx, ty);
                  if (ElementHead.getTypeClass(targetElementHead) <= ElementHead.TYPE_EFFECT) {
                      // move
                      this.#elementArea.swap(x, y, tx, ty);
                  } else {
                     this.#explode(elementHead, x, y);
                  }
              } else {
                  this.#explode(elementHead, x, y);
              }
          }

          #spawnFire(elementHead, x, y) {
              CircleIterator.iterate(CircleIterator.BLUEPRINT_4, (dx, dy, level) => {
                  if (level === 0) {
                      return;  // ignore center
                  }

                  const tx = x + dx;
                  const ty = y + dy;
                  if (this.#elementArea.isValidPosition(tx, ty)) {
                      let targetElementHead = this.#elementArea.getElementHead(tx, ty);
                      if (ElementHead.getTypeClass(targetElementHead) <= ElementHead.TYPE_EFFECT) {
                          this.#elementArea.setElement(tx, ty, Brushes.FIRE.apply(tx, ty, this.#random));
                      }
                  }
              });
          }

          #explode(elementHead, x, y) {
              CircleIterator.iterate(CircleIterator.BLUEPRINT_9, (dx, dy, level) => {
                  const tx = x + dx;
                  const ty = y + dy;
                  if (this.#elementArea.isValidPosition(tx, ty)) {
                      let targetElementHead = this.#elementArea.getElementHead(tx, ty);
                      if (level !== 0 && ElementHead.getBehaviour(targetElementHead) === ElementHead.BEHAVIOUR_METEOR) {
                          // do not destroy other meteors
                          return;
                      }

                      if (level <= 7) {
                          // destroy elements & spawn fire
                          this.#elementArea.setElement(tx, ty, Brushes.FIRE.apply(tx, ty, this.#random));
                      } else {
                          // set temperature, apply visual changes, break solid elements

                          // TODO
                          // targetElementHead = ElementHead.setTemperature(targetElementHead, ProcessorModuleMeteor.EXPLOSION_HEAT);

                          // visual burnt effect (color)
                          if (VisualEffects.isVisualBurnApplicable(targetElementHead)) {
                              let targetElementTail = this.#elementArea.getElementTail(tx, ty);
                              if (level === 8) {
                                  targetElementTail = VisualEffects.visualBurn(targetElementTail, 2);
                              } else {
                                  targetElementTail = VisualEffects.visualBurn(targetElementTail, 1);
                              }
                              this.#elementArea.setElementTail(tx, ty, targetElementTail);
                          }

                          // turn some solid elements into fragments
                          if (ElementHead.getTypeClass(targetElementHead) === ElementHead.TYPE_STATIC) {
                              if (level === 8 || (level === 9 && this.#random.nextInt(10) < 3)) {
                                  const type = ElementHead.type8Powder(ElementHead.TYPE_POWDER, 5);
                                  targetElementHead = ElementHead.setType(targetElementHead, type);
                              }
                          }

                          this.#elementArea.setElementHead(tx, ty, targetElementHead);
                      }
                  }
              });
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-02-25
       */
      class ProcessorModuleGrass {

          static canGrowUpHere(elementArea, x, y) {
              if (x < 0 || y - 1 < 0) {
                  return false;
              }
              if (x >= elementArea.getWidth() || y + 1 >= elementArea.getHeight()) {
                  return false;
              }
              let e1 = elementArea.getElementHead(x, y);
              if (ElementHead.getTypeClass(e1) !== ElementHead.TYPE_AIR) {
                  return false;
              }
              let e2 = elementArea.getElementHead(x, y + 1);
              if (ElementHead.getBehaviour(e2) !== ElementHead.BEHAVIOUR_SOIL) {
                  return false;
              }
              let e3 = elementArea.getElementHead(x, y - 1);
              if (ElementHead.getTypeClass(e3) !== ElementHead.TYPE_AIR) {
                  return false;
              }
              return true;
          }

          static spawnHere(elementArea, x, y, brush, random) {
              let element = brush.apply(x, y, random);
              let offset = 0;
              for (let i = ElementHead.getSpecial(element.elementHead); i >= 0; i--) {
                  if (y - offset < 0) {
                      break;
                  }
                  elementArea.setElementHead(x, y - offset, ElementHead.setSpecial(element.elementHead, i));
                  elementArea.setElementTail(x, y - offset, element.elementTail);
                  offset++;
              }
          }


          /** @type ElementArea */
          #elementArea;

          /** @type DeterministicRandom */
          #random;

          /** @type Element */
          #defaultElement;

          constructor(elementArea, random, defaultElement) {
              this.#elementArea = elementArea;
              this.#random = random;
              this.#defaultElement = defaultElement;
          }

          behaviourGrass(elementHead, x, y) {
              let random = this.#random.nextInt(100);
              if (random < 3) {
                  // check above
                  if (y > 0) {
                      let above1 = this.#elementArea.getElementHead(x, y - 1);
                      if (ElementHead.getBehaviour(above1) !== ElementHead.BEHAVIOUR_GRASS) {
                          let typeAbove1 = ElementHead.getTypeClass(above1);
                          if (typeAbove1 > ElementHead.TYPE_FLUID
                                  || (typeAbove1 === ElementHead.TYPE_FLUID && this.#random.nextInt(100) === 0)) {
                              // note: it takes longer for water to suffocate the grass
                              // remove grass
                              this.#elementArea.setElement(x, y, this.#defaultElement);
                              return;
                          }
                      }
                  }

                  if (random === 0) {
                      // grow up
                      let growIndex = ElementHead.getSpecial(elementHead);
                      if (growIndex === 0) {
                          // maximum height
                          if (this.#random.nextInt(5) === 0) {
                              // remove top element to create some movement
                              this.#elementArea.setElement(x, y, this.#defaultElement);
                          }
                          return;
                      }
                      if (y === 0) {
                          return;
                      }
                      let above1 = this.#elementArea.getElementHead(x, y - 1);
                      if (ElementHead.getTypeClass(above1) !== ElementHead.TYPE_AIR) {
                          return;
                      }
                      if (y > 1) {
                          let above2 = this.#elementArea.getElementHead(x, y - 2);
                          if (ElementHead.getTypeClass(above2) !== ElementHead.TYPE_AIR) {
                              return;
                          }
                      }
                      this.#elementArea.setElementHead(x, y - 1, ElementHead.setSpecial(elementHead, growIndex - 1));
                      this.#elementArea.setElementTail(x, y - 1, this.#elementArea.getElementTail(x, y));
                  } else if (random === 1) {
                      // grow right
                      if (ProcessorModuleGrass.canGrowUpHere(this.#elementArea, x + 1, y + 1)) {
                          this.#elementArea.setElement(x + 1, y + 1, Brushes.GRASS.apply(x, y, this.#random));
                      }
                  } else if (random === 2) {
                      // grow left
                      if (ProcessorModuleGrass.canGrowUpHere(this.#elementArea, x - 1, y + 1)) {
                          this.#elementArea.setElement(x - 1, y + 1, Brushes.GRASS.apply(x, y, this.#random));
                      }
                  }
              }
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-02-24
       */
      class ProcessorModuleFish {

          /** @type ElementArea */
          #elementArea;

          /** @type DeterministicRandom */
          #random;

          /** @type Element */
          #defaultElement;

          constructor(elementArea, random, defaultElement) {
              this.#elementArea = elementArea;
              this.#random = random;
              this.#defaultElement = defaultElement;
          }

          behaviourFish(elementHead, x, y) {
              // check has body
              if (x === this.#elementArea.getWidth() - 1
                  || ElementHead.getBehaviour(this.#elementArea.getElementHead(x + 1, y)) !== ElementHead.BEHAVIOUR_FISH_BODY) {
                  // => turn into corpse
                  this.#elementArea.setElement(x, y, Brushes.FISH_CORPSE.apply(x, y, this.#random));
              }

              // move down if flying
              if (y < this.#elementArea.getHeight() - 1) {
                  if (ElementHead.getTypeClass(this.#elementArea.getElementHead(x, y + 1)) < ElementHead.TYPE_POWDER_FLOATING
                          && ElementHead.getTypeClass(this.#elementArea.getElementHead(x + 1, y + 1)) < ElementHead.TYPE_POWDER_FLOATING) {
                      this.#elementArea.swap(x, y, x, y + 1);
                      this.#elementArea.swap(x + 1, y, x + 1, y + 1);
                      return;
                  }
              }

              // once a while check if there is a water
              // once a while move

              const action = this.#random.nextInt(ProcessorContext.OPT_CYCLES_PER_SECOND);
              if (action === 0) {
                  let w = 0;
                  w += this.#isWaterEnvironment(x - 1, y) ? 1 : 0;
                  w += this.#isWaterEnvironment(x + 2, y) ? 1 : 0;
                  w += this.#isWaterEnvironment(x, y + 1) ? 1 : 0;
                  w += this.#isWaterEnvironment(x, y - 1) ? 1 : 0;
                  if (w < 4) {
                      w += this.#isWaterEnvironment(x + 1, y + 1) ? 1 : 0;
                      w += this.#isWaterEnvironment(x + 1, y - 1) ? 1 : 0;
                  }

                  let dried = ElementHead.getSpecial(elementHead);
                  if (w >= 4) {
                      // enough water
                      if (dried > 0) {
                          // reset counter
                          this.#elementArea.setElementHead(x, y, ElementHead.setSpecial(elementHead, 0));
                      }
                  } else {
                      // not enough water
                      dried++;
                      if (dried > 5) {
                          // turn into corpse
                          this.#elementArea.setElement(x, y, Brushes.FISH_CORPSE.apply(x, y, this.#random));
                      } else {
                          this.#elementArea.setElementHead(x, y, ElementHead.setSpecial(elementHead, dried));
                      }
                  }
              } else if (action < ProcessorContext.OPT_CYCLES_PER_SECOND / 10) {
                  const rx = this.#random.nextInt(3) - 1;
                  const ry = this.#random.nextInt(3) - 1;
                  if (rx === 0 && ry === 0) {
                      return;
                  }
                  // move fish and it's body
                  if (this.#isWater(rx + x, ry + y) && this.#isWater(rx + x + 1, ry + y)) {
                      this.#elementArea.swap(x, y, rx + x, ry + y);
                      this.#elementArea.swap(x + 1, y, rx + x + 1, ry + y);
                  }
              }
          }

          behaviourFishBody(elementHead, x, y) {
              if (x === 0 || ElementHead.getBehaviour(this.#elementArea.getElementHead(x - 1, y)) !== ElementHead.BEHAVIOUR_FISH) {
                  // the fish lost it's head :(
                  // => turn into corpse
                  this.#elementArea.setElement(x, y, Brushes.FISH_CORPSE.apply(x, y, this.#random));
              }
          }

          #isWater(x, y) {
              if (!this.#elementArea.isValidPosition(x, y)) {
                  return false;
              }
              let targetElementHead = this.#elementArea.getElementHead(x, y);
              if (ElementHead.getTypeClass(targetElementHead) !== ElementHead.TYPE_FLUID) {
                  return false;
              }
              return true;
          }

          #isWaterEnvironment(x, y) {
              if (!this.#elementArea.isValidPosition(x, y)) {
                  return false;
              }
              let targetElementHead = this.#elementArea.getElementHead(x, y);
              if (ElementHead.getTypeClass(targetElementHead) === ElementHead.TYPE_FLUID) {
                  return true;
              }
              let behaviour = ElementHead.getBehaviour(targetElementHead);
              if (behaviour === ElementHead.BEHAVIOUR_FISH || behaviour === ElementHead.BEHAVIOUR_FISH_BODY) {
                  return true;
              }
              return false;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-02-25
       */
      class ProcessorModuleTree {

          static spawnHere(elementArea, x, y, type, brush, random, processorContext) {
              type = type % (1 << ElementHead.FIELD_SPECIAL_SIZE);

              const element = brush.apply(x, y, random);
              element.elementHead = ElementHead.setSpecial(element.elementHead, type);  // override tree type
              elementArea.setElement(x, y, element);

              // tree fast grow
              const template = TreeTemplates.getTemplate(type);
              const treeModule = new ProcessorModuleTree(elementArea, random, processorContext);
              treeModule.#treeGrow(element.elementHead, x, y, template, true);

              // roots fast grow
              for (let i = 1; i < 10; i++) {
                  for (let j = 0; j < 9; j++) {
                      const tx = x + j - 4;
                      const ty = y + i;

                      if (!elementArea.isValidPosition(tx, ty)) {
                          continue;
                      }
                      const targetElement = elementArea.getElementHead(tx, ty);
                      if (ElementHead.getBehaviour(targetElement) !== ElementHead.BEHAVIOUR_TREE_ROOT) {
                          continue;
                      }
                      const growIndex = ElementHead.getSpecial(targetElement);
                      if (growIndex === 0) {
                          continue;
                      }

                      const direction = random.nextInt(10);
                      treeModule.#treeRootGrow(tx, ty, targetElement, growIndex, direction);
                  }
              }
          }


          /** @type ElementArea */
          #elementArea;

          /** @type DeterministicRandom */
          #random;

          /** @type ProcessorContext */
          #processorContext;

          constructor(elementArea, random, processorContext) {
              this.#elementArea = elementArea;
              this.#random = random;
              this.#processorContext = processorContext;
          }

          behaviourTree(elementHead, x, y) {
              const random = this.#random.nextInt(ProcessorContext.OPT_CYCLES_PER_SECOND);
              if (random === 0) {
                  const template = TreeTemplates.getTemplate(ElementHead.getSpecial(elementHead));
                  const level = this.#treeGrow(elementHead, x, y, template, false);
                  this.#treeCheckStatus(x, y, level, template);
              }
          }

          #treeGrow(elementHead, x, y, template, fullGrow) {
              let level = 0;
              let stack = [];
              for (let child of template.root.children) {
                  stack.push(child);
              }

              while (stack.length > 0) {
                  let node = stack.pop();

                  let nx = x + node.x;
                  let ny = y + node.y;
                  if (this.#elementArea.isValidPosition(nx, ny)) {
                      let isHereAlready = false;
                      let canGrowHere = false;

                      const currentElementHead = this.#elementArea.getElementHead(nx, ny);
                      const currentElementBehaviour = ElementHead.getBehaviour(currentElementHead);

                      switch (node.type) {
                          case TreeTemplateNode.TYPE_TRUNK:
                          case TreeTemplateNode.TYPE_ROOT:
                              if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_TRUNK) {
                                  isHereAlready = true;
                              } else if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_LEAF) {
                                  canGrowHere = true;
                              } else if (ElementHead.getTypeClass(currentElementHead) === ElementHead.TYPE_AIR) {
                                  canGrowHere = true;
                              } else if (currentElementBehaviour === ElementHead.BEHAVIOUR_SOIL) {
                                  canGrowHere = true;
                              } else if (currentElementBehaviour === ElementHead.BEHAVIOUR_GRASS) {
                                  canGrowHere = true;
                              } else if (node.y > Math.min(-4, -7 + Math.abs(node.x))) {
                                  // roots & bottom trunk only...
                                  if (ElementHead.getTypeClass(currentElementHead) !== ElementHead.TYPE_STATIC) {
                                      canGrowHere = true;
                                  }
                              }
                              break;
                          case TreeTemplateNode.TYPE_LEAF:
                              if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_LEAF) {
                                  isHereAlready = true;
                                  // update leaf vitality (if not dead already)
                                  if (ElementHead.getSpecial(currentElementHead) < 15) {
                                      this.#elementArea.setElementHead(nx, ny, ElementHead.setSpecial(currentElementHead, 0));
                                  }
                              } else if (currentElementBehaviour === ElementHead.BEHAVIOUR_TREE_TRUNK) {
                                  isHereAlready = true;
                              } else if (ElementHead.getTypeClass(currentElementHead) === ElementHead.TYPE_AIR) {
                                  canGrowHere = true;
                              }
                              break;
                          default:
                              throw 'Unknown type: ' + node.type;
                      }

                      if (canGrowHere || isHereAlready) {
                          level++;
                      }

                      if (canGrowHere) {
                          this.#elementArea.setElement(nx, ny, node.brush.apply(nx, ny, this.#random));
                          this.#processorContext.trigger(nx, ny);
                      }

                      if (fullGrow || isHereAlready) {
                          for (let child of node.children) {
                              stack.push(child);
                          }
                      }
                  }
              }
              return level;
          }

          #treeCheckStatus(x, y, level, template) {
              // check tree status
              // - last tree status is carried by tree trunk above
              if (y > 0) {
                  let carrierElementHead = this.#elementArea.getElementHead(x, y - 1);
                  if (ElementHead.getBehaviour(carrierElementHead) === ElementHead.BEHAVIOUR_TREE_TRUNK) {
                      const maxStage = 15;
                      let lastStage = ElementHead.getSpecial(carrierElementHead);
                      let currentStage = Math.trunc(level / template.nodes * maxStage);
                      if (lastStage - currentStage > 5) {
                          // too big damage taken => kill tree
                          this.#elementArea.setElementHead(x, y - 1, ElementHead.setSpecial(carrierElementHead, 0));
                          this.#elementArea.setElement(x, y, Brushes.TREE_WOOD.apply(x, y, this.#random));
                      } else {
                          // update stage
                          this.#elementArea.setElementHead(x, y - 1, ElementHead.setSpecial(carrierElementHead, currentStage));
                      }
                  }
              }
          }

          behaviourTreeRoot(elementHead, x, y) {
              let growIndex = ElementHead.getSpecial(elementHead);
              if (growIndex === 0) {
                  // maximum size
                  if (this.#processorContext.getIteration() % 1000 === 0) {
                      this.#treeRootHardenSurroundingElements(x, y);
                  }
                  return;
              }

              let random = this.#random.nextInt(ProcessorContext.OPT_CYCLES_PER_SECOND * 10);
              if (random < 10) {
                  this.#treeRootGrow(x, y, elementHead, growIndex, random);
              }
          }

          #treeRootHardenSurroundingElements(x, y) {
              const targetX = x + this.#random.nextInt(3) - 1;
              const targetY = y + this.#random.nextInt(3) - 1;

              if (this.#elementArea.isValidPosition(targetX, targetY)) {
                  let targetElementHead = this.#elementArea.getElementHead(targetX, targetY);
                  let type = ElementHead.getTypeClass(targetElementHead);
                  if (type === ElementHead.TYPE_POWDER || type === ElementHead.TYPE_POWDER_WET || type === ElementHead.TYPE_POWDER_FLOATING) {
                      let modifiedElementHead = ElementHead.setType(targetElementHead, ElementHead.TYPE_STATIC);
                      this.#elementArea.setElementHead(targetX, targetY, modifiedElementHead);
                  }
              }
          }

          #treeRootGrow(x, y, elementHead, growIndex, direction) {
              let doGrow = (nx, ny) => {
                  this.#elementArea.setElementHead(x, y, ElementHead.setSpecial(elementHead, 0));

                  let element = Brushes.TREE_ROOT.apply(nx, ny, this.#random);
                  let modifiedHead = ElementHead.setSpecial(element.elementHead, growIndex - 1);
                  this.#elementArea.setElementHead(nx, ny, modifiedHead);
                  this.#elementArea.setElementTail(nx, ny, element.elementTail);
              };

              // grow down first if there is a free space
              if (y < this.#elementArea.getHeight() - 1) {
                  let targetElementHead = this.#elementArea.getElementHead(x, y + 1);
                  if (ElementHead.getTypeClass(targetElementHead) === ElementHead.TYPE_AIR) {
                      doGrow(x, y + 1);
                      return;
                  }
              }

              // grow in random way
              let nx = x;
              let ny = y;
              if (direction === 9 || direction === 8 || direction === 7) {
                  nx += 1;
                  ny += 1;
              } else if (direction === 6 || direction === 5 || direction === 4) {
                  nx += -1;
                  ny += 1;
              } else {
                  ny += 1;
              }

              if (this.#elementArea.isValidPosition(nx, ny)) {
                  let targetElementHead = this.#elementArea.getElementHead(nx, ny);
                  if (ElementHead.getTypeClass(targetElementHead) !== ElementHead.TYPE_STATIC) {
                      doGrow(nx, ny);
                  }
              }
          }

          behaviourTreeLeaf(elementHead, x, y) {
              // decrement vitality (if not dead already)
              let vitality = ElementHead.getSpecial(elementHead);
              if (vitality < 15) {
                  if (this.#processorContext.getIteration() % 32 === 0) {
                      if (this.#random.nextInt(10) === 0) {
                          vitality++;
                          if (vitality >= 15) {
                              this.#elementArea.setElement(x, y, Brushes.TREE_LEAF_DEAD.apply(x, y, this.#random));
                              return;
                          } else {
                              elementHead = ElementHead.setSpecial(elementHead, vitality);
                              this.#elementArea.setElementHead(x, y, elementHead);
                          }
                      }
                  }
              }

              // approx one times per 5 seconds... check if it's not buried or levitating
              if (this.#processorContext.getIteration() % ProcessorContext.OPT_CYCLES_PER_SECOND === 0) {
                  const random = this.#random.nextInt(5);

                  if (random === 0) {
                      // - check if it's not buried

                      const directions = [[0, -1], [-1, -1], [1, -1], [-1, 0], [1, 0]];
                      const randomDirection = directions[this.#random.nextInt(directions.length)];
                      const targetX = x + randomDirection[0];
                      const targetY = y + randomDirection[1];

                      if (this.#elementArea.isValidPosition(targetX, targetY)) {
                          const elementHeadAbove = this.#elementArea.getElementHead(targetX, targetY);
                          if (ElementHead.getTypeClass(elementHeadAbove) !== ElementHead.TYPE_STATIC
                                  && ElementHead.getTypeClass(elementHeadAbove) >= ElementHead.TYPE_FLUID) {
                              this.#elementArea.setElement(x, y, this.#processorContext.getDefaultElement());
                          }
                      }
                  }
              }
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-05-04
       */
      class TreeTemplates {
          static TEMPLATES = [];

          /**
           *
           * @param id {number} template id
           * @returns {TreeTemplate} template
           */
          static getTemplate(id) {
              let template = TreeTemplates.TEMPLATES[id];
              if (!template) {
                  let root = TreeTemplates.#generate(id);
                  let count = TreeTemplates.#countNodes(root);
                  template = new TreeTemplate(root, count);
                  TreeTemplates.TEMPLATES[id] = template;
              }
              return template;
          }

          static #generate(id) {
              let random = new DeterministicRandom(id);
              let root = new TreeTemplateNode(0, 0, TreeTemplateNode.TYPE_TRUNK, Brushes.TREE_WOOD);
              root.children.push(new TreeTemplateNode(0, 1, TreeTemplateNode.TYPE_ROOT, Brushes.TREE_ROOT));

              let size = [20, 37, 35, 42][(id & 0b1100) >> 2];
              let firstSplit = ((id & 0b0010) !== 0) ? 1 : -1;
              let firstIncrement = ((id & 0b0001) !== 0) ? 1 : -1;

              let splits = [15, 19, 22, 25, 29, 32, 35];
              if (size < 25) {
                  splits.unshift(12);  // small trees
              }
              let splitDirection = firstSplit;

              let incrementWidth = [12, 20, 28, 32];
              let incrementX = [1, -1, 2, -2, 3, -3].map(v => v * firstIncrement);
              let incrementNext = 0;

              let centerTrunkNodes = [root];

              for (let i = 1; i <= size; i++) {
                  const remainingSize = size - i;

                  // increment trunk size
                  if (incrementWidth.includes(i)) {
                      let nx = incrementX[incrementNext++];
                      let node = new TreeTemplateNode(nx, 0, TreeTemplateNode.TYPE_TRUNK, Brushes.TREE_WOOD);
                      node.children.push(new TreeTemplateNode(nx, 1, TreeTemplateNode.TYPE_ROOT, Brushes.TREE_ROOT));

                      centerTrunkNodes[0].children.push(node);
                      centerTrunkNodes.push(node);
                  }

                  // add split
                  if (splits.includes(i)) {
                      let branchLength = 12;
                      if (remainingSize < 10) {
                          branchLength = 8;
                      }
                      if (remainingSize < 6) {
                          branchLength = 5;
                      }

                      let branchRoot = this.#generateBranch(branchLength, splitDirection, i, remainingSize, random);
                      centerTrunkNodes[0].children.push(branchRoot);

                      splitDirection = splitDirection * -1;
                  }

                  // add next trunk level
                  for (let j = 0; j < centerTrunkNodes.length; j++) {
                      let last = centerTrunkNodes[j];

                      let node = (j !== 0 || remainingSize > 3)
                          ? new TreeTemplateNode(last.x, last.y - 1, TreeTemplateNode.TYPE_TRUNK, Brushes.TREE_WOOD)
                          : new TreeTemplateNode(last.x, last.y - 1, TreeTemplateNode.TYPE_LEAF, Brushes.TREE_LEAF_DARKER);

                      last.children.push(node);
                      centerTrunkNodes[j] = node;
                  }

                  // add trunk leaves
                  if (i > 20) {
                      let brush = (remainingSize > 3) ? Brushes.TREE_LEAF_DARKER : Brushes.TREE_LEAF_LIGHTER;

                      let leafR = new TreeTemplateNode(1, -i, TreeTemplateNode.TYPE_LEAF, brush);
                      centerTrunkNodes[0].children.push(leafR);
                      let leafL = new TreeTemplateNode(-1, -i, TreeTemplateNode.TYPE_LEAF, brush);
                      centerTrunkNodes[0].children.push(leafL);

                      if (remainingSize > 1) {
                          leafR.children.push(new TreeTemplateNode(2, -i, TreeTemplateNode.TYPE_LEAF, Brushes.TREE_LEAF_LIGHTER));
                          leafL.children.push(new TreeTemplateNode(-2, -i, TreeTemplateNode.TYPE_LEAF, Brushes.TREE_LEAF_LIGHTER));
                      }
                  }
              }
              return root;
          }

          static #generateBranch(branchLength, splitDirection, i, remainingSize, random) {
              let shift = 0;
              let branchRoot = null;
              let branchLast = null;

              for (let j = 1; j <= branchLength; j++) {
                  const remainingBranchSize = branchLength - j;

                  if (j > 3 && random.next() < 0.2) {
                      shift++;
                  }
                  let nx = splitDirection * j;
                  let ny = -i - shift;

                  let next = (remainingSize > 3 && remainingBranchSize > 1)
                      ? new TreeTemplateNode(nx, ny, TreeTemplateNode.TYPE_TRUNK, Brushes.TREE_WOOD)
                      : new TreeTemplateNode(nx, ny, TreeTemplateNode.TYPE_LEAF, Brushes.TREE_LEAF_LIGHTER);

                  if (branchRoot === null) {
                      branchRoot = next;
                  }

                  if (branchLast !== null) {
                      branchLast.children.push(next);
                  }
                  branchLast = next;

                  // generate branch leaves

                  let leafAbove = new TreeTemplateNode(nx, ny - 1, TreeTemplateNode.TYPE_LEAF, Brushes.TREE_LEAF_LIGHTER);
                  let leafBelow = new TreeTemplateNode(nx, ny + 1, TreeTemplateNode.TYPE_LEAF,
                      (remainingBranchSize > 3) ? Brushes.TREE_LEAF_DARKER : Brushes.TREE_LEAF_LIGHTER);

                  if (remainingBranchSize > 3) {
                      leafAbove.children.push(new TreeTemplateNode(nx, ny - 2, TreeTemplateNode.TYPE_LEAF, Brushes.TREE_LEAF_LIGHTER));
                      leafBelow.children.push(new TreeTemplateNode(nx, ny + 2, TreeTemplateNode.TYPE_LEAF, Brushes.TREE_LEAF_LIGHTER));
                  }

                  next.children.push(leafAbove);
                  next.children.push(leafBelow);
              }
              return branchRoot;
          }

          static #countNodes(root) {
              let count = 0;

              let stack = [root];
              while (stack.length > 0) {
                  let node = stack.pop();
                  count++;
                  for (let child of node.children) {
                      stack.push(child);
                  }
              }
              return count;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2022-10-01
       */
      class TreeTemplate {

          /** @type TreeTemplateNode */
          root;

          /** @type number */
          nodes;

          constructor(root, nodes) {
              this.root = root;
              this.nodes = nodes;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2022-09-29
       */
      class TreeTemplateNode {
          static TYPE_TRUNK = 1;
          static TYPE_LEAF = 2;
          static TYPE_ROOT = 3;


          /** @type number */
          x;

          /** @type number */
          y;

          /** @type number */
          type;

          /** @type Brush */
          brush;

          /** @type TreeTemplateNode[] */
          children = [];

          constructor(x, y, type, brush) {
              this.x = x;
              this.y = y;
              this.type = type;
              this.brush = brush;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class Processor extends ProcessorContext {

          /** @type ElementArea */
          #elementArea;

          /** @type number */
          #width;
          /** @type number */
          #height;

          /** @type number */
          #chunkSize;
          /** @type number */
          #horChunkCount;
          /** @type number */
          #verChunkCount;

          /** @type boolean[] */
          #activeChunks
          /** @type boolean[] */
          #changedChunks
          /** @type number[] */
          #chunkLastFullTest;

          /** @type number */
          #iteration = 0;

          /** @type DeterministicRandom */
          #random;

          /** @type boolean */
          #fallThroughEnabled = false;
          /** @type boolean */
          #erasingEnabled = false;

          /** @type Element */
          #defaultElement;

          static RANDOM_DATA_COUNT = 32;

          /** @type Uint32Array[] */
          #rndChunkOrder = [];
          /** @type Uint32Array[] */
          #rndChunkXRnd = [];
          /** @type Uint32Array[] */
          #rndChunkXOrder = [];

          /** @type ProcessorModuleFire */
          #moduleFire;
          /** @type ProcessorModuleMeteor */
          #moduleMeteor;
          /** @type ProcessorModuleGrass */
          #moduleGrass;
          /** @type ProcessorModuleFish */
          #moduleFish;
          /** @type ProcessorModuleTree */
          #moduleTree;

          constructor(elementArea, chunkSize, random, defaultElement, sceneMetadata) {
              super();
              this.#elementArea = elementArea;
              this.#width = elementArea.getWidth();
              this.#height = elementArea.getHeight();

              this.#chunkSize = chunkSize;
              if (this.#chunkSize > 255) {
                  throw 'Chunk size limit: 255';
              }
              this.#horChunkCount = Math.ceil(this.#width / this.#chunkSize);
              this.#verChunkCount = Math.ceil(this.#height / this.#chunkSize);
              this.#activeChunks = new Array(this.#horChunkCount * this.#verChunkCount).fill(true);
              this.#changedChunks = new Array(this.#horChunkCount * this.#verChunkCount).fill(true);
              this.#chunkLastFullTest = new Array(this.#horChunkCount * this.#verChunkCount).fill(-1);

              let rndDataRandom = new DeterministicRandom(0);
              this.#rndChunkOrder = Processor.#generateArrayOfOrderData(
                  Processor.RANDOM_DATA_COUNT, this.#horChunkCount, rndDataRandom);
              this.#rndChunkXRnd = Processor.#generateArrayOfRandomData(
                  Processor.RANDOM_DATA_COUNT, this.#chunkSize, this.#chunkSize, rndDataRandom);
              this.#rndChunkXOrder = Processor.#generateArrayOfOrderData(
                  Processor.RANDOM_DATA_COUNT, this.#chunkSize, rndDataRandom);

              this.#random = random;
              this.#defaultElement = defaultElement;

              this.#moduleFire = new ProcessorModuleFire(elementArea, random, defaultElement);
              this.#moduleMeteor = new ProcessorModuleMeteor(elementArea, random, defaultElement);
              this.#moduleGrass = new ProcessorModuleGrass(elementArea, random, defaultElement);
              this.#moduleFish = new ProcessorModuleFish(elementArea, random, defaultElement);
              this.#moduleTree = new ProcessorModuleTree(elementArea, random, this);

              if (sceneMetadata) {
                  this.#iteration = sceneMetadata.iteration;
                  this.#fallThroughEnabled = sceneMetadata.fallThroughEnabled;
                  this.#erasingEnabled = sceneMetadata.erasingEnabled;
              }
          }

          static #shuffle(array, iterations, random) {
              for (let i = 0; i < iterations; i++) {
                  let a = random.nextInt(array.length);
                  let b = random.nextInt(array.length);
                  [array[a], array[b]] = [array[b], array[a]];
              }
          }

          static #generateArrayOfOrderData(arrayLength, count, random) {
              let data = Processor.#generateOrderData(count);
              Processor.#shuffle(data, arrayLength, random);

              let array = Array(arrayLength);
              for (let i = 0; i < arrayLength; i++) {
                  Processor.#shuffle(data, Math.ceil(arrayLength / 4), random);
                  array[i] = new Uint8Array(data);
              }
              return array;
          }

          static #generateOrderData(count) {
              let array = new Uint8Array(count);
              for (let i = 0; i < count; i++) {
                  array[i] = i;
              }
              return array;
          }

          static #generateArrayOfRandomData(arrayLength, count, max, random) {
              let array = Array(arrayLength);
              for (let i = 0; i < arrayLength; i++) {
                  array[i] = Processor.#generateRandomData(count, max, random);
              }
              return array;
          }

          static #generateRandomData(count, max, random) {
              let array = new Uint8Array(count);
              for (let i = 0; i < count; i++) {
                  array[i] = random.nextInt(max);
              }
              return array;
          }

          getIteration() {
              return this.#iteration;
          }

          getDefaultElement() {
              return this.#defaultElement;
          }

          setFallThroughEnabled(enabled) {
              this.#fallThroughEnabled = enabled;
          }

          setErasingEnabled(enabled) {
              this.#erasingEnabled = enabled;
          }

          isFallThroughEnabled() {
              return this.#fallThroughEnabled;
          }

          isErasingEnabled() {
              return this.#erasingEnabled;
          }

          trigger(x, y) {
              const cx = Math.floor(x / this.#chunkSize);
              const cy = Math.floor(y / this.#chunkSize);
              const chunkIndex = cy * this.#horChunkCount + cx;
              this.#activeChunks[chunkIndex] = true;
              // this.#changedChunks[chunkIndex] = true;
          }

          getActiveChunks() {
              return this.#activeChunks;
          }

          getChangedChunks() {
              return this.#changedChunks;
          }

          cleanChangedChunks() {
              this.#changedChunks.fill(false);
          }

          next() {
              const activeChunks = Array.from(this.#activeChunks);
              this.#activeChunks.fill(false);

              for (let cy = this.#verChunkCount - 1; cy >= 0; cy--) {
                  const cyTop = cy * this.#chunkSize;
                  const cyBottom = Math.min((cy + 1) * this.#chunkSize - 1, this.#height - 1);

                  const chunkOrder = this.#rndChunkOrder[this.#random.nextInt(Processor.RANDOM_DATA_COUNT)];
                  const fullChunkLoop = this.#random.nextInt(2) === 0;

                  const chunkActiveElements = new Uint16Array(this.#horChunkCount);

                  for (let y = cyBottom; y >= cyTop; y--) {
                      for (let i = 0; i < this.#horChunkCount; i++) {
                          const cx = chunkOrder[i];
                          const chunkIndex = cy * this.#horChunkCount + cx;

                          const idx = this.#random.nextInt(Processor.RANDOM_DATA_COUNT);
                          const chunkXOder = (fullChunkLoop) ? this.#rndChunkXOrder[idx] : this.#rndChunkXRnd[idx];

                          if (activeChunks[chunkIndex]) {
                              // standard iteration
                              let activeElements = chunkActiveElements[cx];
                              for (let j = 0; j < this.#chunkSize; j++) {
                                  let x = cx * this.#chunkSize + chunkXOder[j];
                                  if (x < this.#width) {
                                      let activeElement = this.#nextPoint(x, y);
                                      if (activeElement) {
                                          activeElements++;
                                      }
                                  }
                              }
                              chunkActiveElements[cx] = activeElements;
                          }
                      }
                  }

                  // fast check deactivated chunks (borders only - if they have active neighbours)
                  for (let cx = 0; cx < this.#horChunkCount; cx++) {
                      const chunkIndex = cy * this.#horChunkCount + cx;
                      if (!activeChunks[chunkIndex]) {
                          if (this.#fastTest(cx, cy, activeChunks)) {
                              // wake up chunk
                              activeChunks[chunkIndex] = true;
                              chunkActiveElements[cx] = 1;
                          }
                      }
                  }

                  // deactivate chunks if possible
                  if (fullChunkLoop) {
                      for (let cx = 0; cx < this.#horChunkCount; cx++) {
                          const chunkIndex = cy * this.#horChunkCount + cx;
                          if (activeChunks[chunkIndex] && chunkActiveElements[cx] === 0) {
                              // full test before deactivation

                              // this test is quite expensive, so we don't want to perform it every time
                              const lastFullTest = this.#chunkLastFullTest[chunkIndex];
                              if (lastFullTest === -1 || this.#iteration - lastFullTest >= 10) {
                                  if (!this.#fullTest(cx, cy)) {
                                      activeChunks[chunkIndex] = false;
                                      this.#changedChunks[chunkIndex] = true;  // last repaint
                                      this.#chunkLastFullTest[chunkIndex] = this.#iteration;
                                  }
                              }
                          }
                      }
                  }
              }

              // erasing mode
              if (this.#erasingEnabled) {
                  for (let x = 0; x < this.#width; x++) {
                      this.#elementArea.setElement(x, 0, this.#defaultElement);
                      this.#elementArea.setElement(x, this.#height - 1, this.#defaultElement);
                  }
                  for (let y = 1; y < this.#height - 1; y++) {
                      this.#elementArea.setElement(0, y, this.#defaultElement);
                      this.#elementArea.setElement(this.#width - 1, y, this.#defaultElement);
                  }
              }

              // merge active chunks
              for (let i = 0; i < this.#horChunkCount * this.#verChunkCount; i++) {
                  let active = activeChunks[i];
                  if (active) {
                      this.#activeChunks[i] = true;
                      this.#changedChunks[i] = true;
                  }
              }

              this.#iteration++;
          }

          #fastTest(cx, cy, activeChunks) {
              // left
              if (cx > 0 && activeChunks[(cy * this.#horChunkCount) + cx - 1]) {
                  const x = cx * this.#chunkSize;
                  const my = Math.min((cy + 1) * this.#chunkSize, this.#height);
                  for (let y = cy * this.#chunkSize; y < my; y++) {
                      if (this.#testPoint(x, y)) {
                          return true;
                      }
                  }
              }

              // right
              if (cx < (this.#horChunkCount - 1) && activeChunks[(cy * this.#horChunkCount) + cx + 1]) {
                  const x = Math.min(((cx + 1) * this.#chunkSize) - 1, this.#width - 1);
                  const my = Math.min((cy + 1) * this.#chunkSize, this.#height);
                  for (let y = cy * this.#chunkSize; y < my; y++) {
                      if (this.#testPoint(x, y)) {
                          return true;
                      }
                  }
              }

              // top
              if ((cy > 0) && activeChunks[((cy - 1) * this.#horChunkCount) + cx]
                  || (this.#fallThroughEnabled
                      && cy === 0
                      && activeChunks[((this.#verChunkCount - 1) * this.#horChunkCount) + cx])) {

                  const y = cy * this.#chunkSize;
                  const mx = Math.min((cx + 1) * this.#chunkSize, this.#width);
                  for (let x = cx * this.#chunkSize; x < mx; x++) {
                      if (this.#testPoint(x, y)) {
                          return true;
                      }
                  }
              }

              // bottom
              if (cy < (this.#verChunkCount - 1) && activeChunks[((cy + 1) * this.#horChunkCount) + cx]) {
                  const y = (cy + 1) * this.#chunkSize - 1;
                  const mx = Math.min((cx + 1) * this.#chunkSize, this.#width);
                  for (let x = cx * this.#chunkSize; x < mx; x++) {
                      if (this.#testPoint(x, y)) {
                          return true;
                      }
                  }
              }
          }

          #fullTest(cx, cy) {
              const mx = Math.min((cx + 1) * this.#chunkSize, this.#width);
              const my = Math.min((cy + 1) * this.#chunkSize, this.#height);
              for (let y = cy * this.#chunkSize; y < my; y++) {
                  for (let x = cx * this.#chunkSize; x < mx; x++) {
                      if (this.#testPoint(x, y)) {
                          return true;
                      }
                  }
              }
              return false;
          }

          #testPoint(x, y) {
              const elementHead = this.#elementArea.getElementHead(x, y);

              if (this.#testMovingBehaviour(elementHead, x, y)) {
                  return true;
              }

              const behaviour = ElementHead.getBehaviour(elementHead);
              switch (behaviour) {
                  case ElementHead.BEHAVIOUR_NONE:
                  case ElementHead.BEHAVIOUR_SOIL:
                  case ElementHead.BEHAVIOUR_TREE_TRUNK:
                      break;
                  default:
                      return true;
              }
              return false;
          }

          /**
           *
           * @param elementHead
           * @param x {number}
           * @param y {number}
           * @returns {boolean}
           */
          #testMovingBehaviour(elementHead, x, y) {
              const type = ElementHead.getTypeClass(elementHead);
              switch (type) {
                  case ElementHead.TYPE_AIR:
                  case ElementHead.TYPE_STATIC:
                      // no action
                      return false;

                  case ElementHead.TYPE_POWDER:
                  case ElementHead.TYPE_POWDER_FLOATING:
                  case ElementHead.TYPE_POWDER_WET:
                      if (ElementHead.getTypeModifierPowderSliding(elementHead)) {
                          return true;
                      } else {
                          return this.#testMove(elementHead, x, y, x, y + 1);
                      }

                  case ElementHead.TYPE_FLUID:
                      return this.#testMove(elementHead, x, y, x, y + 1)
                              || this.#testMove(elementHead, x, y, x + 1, y)
                              || this.#testMove(elementHead, x, y, x - 1, y);
                  default:
                      return true;
              }
              throw "Unknown element type: " + type;
          }

          #testMove(elementHead, x, y, x2, y2) {
              if (!this.#elementArea.isValidPosition(x2, y2)) {
                  if (this.#fallThroughEnabled && y === this.#height - 1) {
                      // try fall through
                      y2 = 0;
                      if (!this.#elementArea.isValidPosition(x2, y2)) {
                          return false;
                      }
                      // continue move...
                  } else {
                      return false;
                  }
              }

              let elementHead2 = this.#elementArea.getElementHead(x2, y2);
              return this.#canMove(elementHead, elementHead2);
          }

          /**
           *
           * @param x {number}
           * @param y {number}
           * @return {boolean} active
           */
          #nextPoint(x, y) {
              const elementHead = this.#elementArea.getElementHead(x, y);
              const moved = this.#performMovingBehaviour(elementHead, x, y);

              if (moved) {
                  return true;
              }

              const behaviour = ElementHead.getBehaviour(elementHead);
              let activeBehaviour = false;
              switch (behaviour) {
                  case ElementHead.BEHAVIOUR_NONE:
                  case ElementHead.BEHAVIOUR_SOIL:
                      break;
                  case ElementHead.BEHAVIOUR_FIRE:
                      this.#moduleFire.behaviourFire(elementHead, x, y);
                      activeBehaviour = true;
                      break;
                  case ElementHead.BEHAVIOUR_GRASS:
                      this.#moduleGrass.behaviourGrass(elementHead, x, y);
                      activeBehaviour = true;
                      break;
                  case ElementHead.BEHAVIOUR_TREE:
                      this.#moduleTree.behaviourTree(elementHead, x, y);
                      activeBehaviour = true;
                      break;
                  case ElementHead.BEHAVIOUR_TREE_LEAF:
                      this.#moduleTree.behaviourTreeLeaf(elementHead, x, y);
                      activeBehaviour = true;
                      break;
                  case ElementHead.BEHAVIOUR_TREE_TRUNK:
                      break;
                  case ElementHead.BEHAVIOUR_TREE_ROOT:
                      this.#moduleTree.behaviourTreeRoot(elementHead, x, y);
                      activeBehaviour = true;
                      break;
                  case ElementHead.BEHAVIOUR_FIRE_SOURCE:
                      this.#moduleFire.behaviourFireSource(elementHead, x, y);
                      activeBehaviour = true;
                      break;
                  case ElementHead.BEHAVIOUR_METEOR:
                      this.#moduleMeteor.behaviourMeteor(elementHead, x, y);
                      activeBehaviour = true;
                      break;
                  case ElementHead.BEHAVIOUR_FISH:
                      this.#moduleFish.behaviourFish(elementHead, x, y);
                      activeBehaviour = true;
                      break;
                  case ElementHead.BEHAVIOUR_FISH_BODY:
                      this.#moduleFish.behaviourFishBody(elementHead, x, y);
                      activeBehaviour = true;
                      break;
                  default:
                      throw "Unknown element behaviour: " + behaviour;
              }

              return activeBehaviour;
          }

          /**
           *
           * @param elementHead
           * @param x {number}
           * @param y {number}
           * @returns {boolean}
           */
          #performMovingBehaviour(elementHead, x, y) {
              const type = ElementHead.getTypeClass(elementHead);
              switch (type) {
                  case ElementHead.TYPE_AIR:
                      // no action
                      return false;

                  case ElementHead.TYPE_POWDER:
                  case ElementHead.TYPE_POWDER_WET:
                  case ElementHead.TYPE_POWDER_FLOATING:
                      if (this.#move(elementHead, x, y, x, y + 1)) {
                          // moved down

                          if (y % 2 === 0) {
                              this.#wake(x - 1, y + 1, 0);
                          } else {
                              this.#wake(x + 1, y + 1, 1);
                          }

                          this.#wake(x, y + 1, y % 2);

                          if (y % 2 === 0) {
                              this.#wake(x + 1, y, 0);
                          } else {
                              this.#wake(x - 1, y, 1);
                          }

                          return true;
                      } else {
                          if (ElementHead.getTypeModifierPowderSliding(elementHead) === 1) {
                              const momentum = ElementHead.getTypeModifierPowderMomentum(elementHead);

                              const r = this.#random.nextInt(1000000);
                              if (r > Processor.#asMomentumMoveInMillion(momentum)) {
                                  // stop - lost momentum
                                  this.#elementArea.setElementHead(x, y, ElementHead.setTypeModifierPowderSliding(elementHead, 0));
                                  return false;
                              }

                              const direction = ElementHead.getTypeModifierPowderDirection(elementHead);
                              this.#wake(x, y + 1, direction);

                              const directionX = (direction === 0) ? -1 : 1;
                              if (this.#move(elementHead, x, y, x + directionX, y)) {
                                  // moved horizontally
                                  this.#wake(x + directionX, y + 1, direction);
                                  this.#wake(x - directionX, y, direction);
                                  return true;
                              } else {
                                  // stop - nowhere to go
                                  this.#wake(x + directionX, y + 1, direction);
                                  this.#elementArea.setElementHead(x, y, ElementHead.setTypeModifierPowderSliding(elementHead, 0));
                                  return false;
                              }
                          }
                          return false;
                      }

                  case ElementHead.TYPE_FLUID:
                      // slow moving fluid
                      // if (!this.#move(elementHead, x, y, x, y + 1)) {
                      //     let rnd = this.#random.nextInt(2);
                      //     if (rnd === 0) {
                      //         return this.#move(elementHead, x, y, x + 1, y)
                      //     } else {
                      //         return this.#move(elementHead, x, y, x - 1, y)
                      //     }
                      // }
                      // return true;

                      // fast moving fluid (it can move by 3)
                      if (!this.#move(elementHead, x, y, x, y + 1)) {
                          let rnd = this.#random.nextInt(2);
                          if (rnd === 0) {
                              if (this.#move(elementHead, x, y, x + 1, y)) {
                                  this.#wake(x + 1, y + 1, 1);
                                  if (this.#move(elementHead, x + 1, y, x + 2, y)) {
                                      if (this.#move(elementHead, x + 2, y, x + 3, y)) {
                                          this.trigger(x + 3, y);
                                      } else {
                                          this.trigger(x + 2, y);
                                      }
                                  }
                                  return true;
                              }
                              return false;
                          } else {
                              if (this.#move(elementHead, x, y, x - 1, y)) {
                                  this.#wake(x - 1, y + 1, 0);
                                  if (this.#move(elementHead, x - 1, y, x - 2, y)) {
                                      if (this.#move(elementHead, x - 2, y, x - 3, y)) {
                                          this.trigger(x - 3, y);
                                      } else {
                                          this.trigger(x - 2, y);
                                      }
                                  }
                                  return true;
                              }
                              return false;
                          }
                      }
                      return true;

                  case ElementHead.TYPE_STATIC:
                  case ElementHead.TYPE_EFFECT:
                      // no action
                      return false;
              }
              throw "Unknown element type: " + type;
          }

          #move(elementHead, x, y, x2, y2) {
              if (!this.#elementArea.isValidPosition(x2, y2)) {
                  if (this.#fallThroughEnabled && y === this.#height - 1) {
                      // try fall through
                      y2 = 0;
                      if (!this.#elementArea.isValidPosition(x2, y2)) {
                          return false;
                      }
                      // continue move...
                  } else {
                      return false;
                  }
              }

              const elementHead2 = this.#elementArea.getElementHead(x2, y2);
              const elementType2 = ElementHead.getTypeClass(elementHead2);
              if (elementType2 === ElementHead.TYPE_POWDER_FLOATING || elementType2 === ElementHead.TYPE_POWDER) {
                  return false;
              }

              const elementType1 = ElementHead.getTypeClass(elementHead);
              if (elementType1 > elementType2) {
                  // move

                  if (elementType1 === ElementHead.TYPE_POWDER && elementType2 === ElementHead.TYPE_FLUID) {
                      // element may cover element2

                      const elementHeadWithAbsorbedFluid = ElementHead.setTypeClass(elementHead, ElementHead.TYPE_POWDER_WET);
                      const elementTail = this.#elementArea.getElementTail(x, y);

                      // sometimes element2 will not be covered - it looks better
                      if (this.#random.nextInt(100) > 9) {
                          this.#elementArea.setElement(x, y, this.#defaultElement);
                      } else {
                          const elementTail2 = this.#elementArea.getElementTail(x2, y2);
                          this.#elementArea.setElementHead(x, y, elementHead2);
                          this.#elementArea.setElementTail(x, y, elementTail2);
                      }
                      this.#elementArea.setElementHead(x2, y2, elementHeadWithAbsorbedFluid);
                      this.#elementArea.setElementTail(x2, y2, elementTail);

                  } else {
                      // swap

                      const elementTail = this.#elementArea.getElementTail(x, y);
                      const elementTail2 = this.#elementArea.getElementTail(x2, y2);

                      this.#elementArea.setElementHead(x2, y2, elementHead);
                      this.#elementArea.setElementHead(x, y, elementHead2);
                      this.#elementArea.setElementTail(x2, y2, elementTail);
                      this.#elementArea.setElementTail(x, y, elementTail2);
                  }
                  return true;
              }
              return false;
          }

          #canMove(elementHead1, elementHead2) {
              const elementType2 = ElementHead.getTypeClass(elementHead2);
              if (elementType2 === ElementHead.TYPE_POWDER_FLOATING || elementType2 === ElementHead.TYPE_POWDER) {
                  return false;
              }

              const elementType1 = ElementHead.getTypeClass(elementHead1);
              return elementType1 > elementType2;
          }

          #wake(x, y, direction) {
              if (this.#elementArea.isValidPosition(x, y)) {
                  let elementHead = this.#elementArea.getElementHead(x, y);
                  const type = ElementHead.getTypeClass(elementHead);
                  if (type === ElementHead.TYPE_POWDER
                          || type === ElementHead.TYPE_POWDER_WET
                          || type === ElementHead.TYPE_POWDER_FLOATING) {

                      const momentum = ElementHead.getTypeModifierPowderMomentum(elementHead);
                      if (momentum === 0) {
                          return;  // never wake up
                      }

                      const directionX = (direction === 0) ? -1 : 1;
                      if (this.#elementArea.isValidPosition(x + directionX, y)) {
                          const nextElementHead = this.#elementArea.getElementHead(x + directionX, y);
                          if (!this.#canMove(elementHead, nextElementHead)) {
                              return;  // target element has no space to move
                          }
                      }

                      const r = this.#random.nextInt(1000000);
                      if (r > Processor.#asMomentumWakeupInMillion(momentum)) {
                          return;  // not this time
                      }

                      elementHead = ElementHead.setTypeModifierPowderSliding(elementHead, 1);
                      elementHead = ElementHead.setTypeModifierPowderDirection(elementHead, direction);
                      this.#elementArea.setElementHead(x, y, elementHead);
                  }
              }
          }


          static #asMomentumMoveInMillion(momentum) {
              return [0, 400000, 600000, 700000, 700000, 800000, 950000, 950000][momentum];  // none .. almost always
          }

          static #asMomentumWakeupInMillion(momentum) {
              return [0, 400000, 400000, 400000, 600000, 600000, 850000, 900000][momentum];  // never .. almost always
          }
      }

      /**
       * @interface
       *
       * @author Patrik Harag
       * @version 2023-08-27
       */
      class Renderer {

          trigger(x, y) {
              throw 'Not implemented';
          }

          /**
           *
           * @param changedChunks {boolean[]}
           * @return {void}
           */
          render(changedChunks) {
              throw 'Not implemented';
          }
      }

      /**
       * @author Patrik Harag
       * @version 2023-02-18
       */
      class RenderingMode {

          /**
           * Element rendering function.
           *
           * Default implementation:
           * <pre>
           *     data[dataIndex] = ElementTail.getColorRed(elementTail);
           *     data[dataIndex + 1] = ElementTail.getColorGreen(elementTail);
           *     data[dataIndex + 2] = ElementTail.getColorBlue(elementTail);
           * </pre>
           *
           * @param data
           * @param dataIndex
           * @param elementHead
           * @param elementTail
           */
          apply(data, dataIndex, elementHead, elementTail) {
              throw 'Not implemented'
          }
      }

      /**
       * Double buffered renderer. With motion blur.
       *
       * @author Patrik Harag
       * @version 2023-08-27
       */
      class Renderer2D extends Renderer {

          /**
           *
           * @param elementArea {ElementArea}
           * @param context {CanvasRenderingContext2D}
           * @param alpha 0x00 = fully transparent, 0xFF = fully opaque
           */
          static renderPreview(elementArea, context, alpha=0xFF) {
              const w = elementArea.getWidth();
              const h = elementArea.getHeight();

              const buffer = context.createImageData(w, h);
              const data = buffer.data;

              for (let x = 0; x < w; x++) {
                  for (let y = 0; y < h; y++) {
                      const pixelIndex = w * y + x;
                      const dataIndex = pixelIndex * 4;

                      const elementTail = elementArea.getElementTail(x, y);

                      if (elementTail === ElementArea.TRANSPARENT_ELEMENT.elementTail
                              && elementArea.getElementHead(x, y) === ElementArea.TRANSPARENT_ELEMENT.elementHead) {

                          // transparent
                          data[dataIndex + 3] = 0;
                      } else {
                          data[dataIndex] = ElementTail.getColorRed(elementTail);
                          data[dataIndex + 1] = ElementTail.getColorGreen(elementTail);
                          data[dataIndex + 2] = ElementTail.getColorBlue(elementTail);
                          data[dataIndex + 3] = alpha;
                      }
                  }
              }

              context.putImageData(buffer, 0, 0, 0, 0, w, h);
          }


          /** @type CanvasRenderingContext2D */
          #context;

          /** @type RenderingMode|null */
          #mode = null;

          /** @type ElementArea */
          #elementArea;

          /** @type number */
          #width;
          /** @type number */
          #height;

          /** @type number */
          #chunkSize;
          /** @type number */
          #horChunkCount;
          /** @type number */
          #verChunkCount;

          /** @type boolean[] */
          #triggeredChunks

          /** @type ImageData */
          #buffer;

          /** @type boolean[] */
          #blur;

          /** @type boolean[] */
          #canBeBlurred;

          constructor(elementArea, chunkSize, context) {
              super();
              this.#context = context;
              this.#elementArea = elementArea;
              this.#width = elementArea.getWidth();
              this.#height = elementArea.getHeight();

              this.#chunkSize = chunkSize;
              this.#horChunkCount = Math.ceil(this.#width / this.#chunkSize);
              this.#verChunkCount = Math.ceil(this.#height / this.#chunkSize);
              this.#triggeredChunks = new Array(this.#horChunkCount * this.#verChunkCount).fill(true);

              this.#buffer = this.#context.createImageData(this.#width, this.#height);
              // set up alpha color component
              const data = this.#buffer.data;
              for (let y = 0; y < this.#height; y++) {
                  for (let x = 0; x < this.#width; x++) {
                      let index = 4 * (this.#width * y + x);
                      data[index + 3] = 0xFF;
                  }
              }

              this.#blur = new Array(this.#width * this.#height).fill(false);
              this.#canBeBlurred = new Array(this.#width * this.#height).fill(false);
          }

          trigger(x, y) {
              const cx = Math.trunc(x / this.#chunkSize);
              const cy = Math.trunc(y / this.#chunkSize);
              const chunkIndex = cy * this.#horChunkCount + cx;
              this.#triggeredChunks[chunkIndex] = true;
          }

          triggerChunk(cx, cy) {
              const chunkIndex = cy * this.#horChunkCount + cx;
              this.#triggeredChunks[chunkIndex] = true;
          }

          triggerChunks(activeChunks) {
              if (activeChunks.length !== this.#triggeredChunks.length) {
                  throw 'Array must be of the same size';
              }
              for (let i = 0; i < activeChunks.length; i++) {
                  const active = activeChunks[i];
                  if (active) {
                      this.#triggeredChunks[i] = active;
                  }
              }
          }

          setMode(mode) {
              this.#mode = mode;
              // ensure repaint
              this.#triggeredChunks.fill(true);
              this.#blur.fill(false);
              this.#canBeBlurred.fill(false);
          }

          /**
           *
           * @param changedChunks {boolean[]}
           * @return {void}
           */
          render(changedChunks) {
              for (let cy = 0; cy < this.#verChunkCount; cy++) {
                  for (let cx = 0; cx < this.#horChunkCount; cx++) {
                      const chunkIndex = cy * this.#horChunkCount + cx;

                      const triggered = this.#triggeredChunks[chunkIndex];
                      if (triggered) {
                          // unset
                          this.#triggeredChunks[chunkIndex] = false;
                      }

                      const changed = changedChunks[chunkIndex];
                      if (changed) {
                          // repaint at least once
                          this.#triggeredChunks[chunkIndex] = true;
                      }

                      if (triggered || changed) {

                          // neighbours can be changed without triggering
                          let includeRowUnder = false;
                          if (cy + 1 < this.#horChunkCount) {
                              const chunkIndexUnder = (cy + 1) * this.#horChunkCount + cx;
                              if (!this.#triggeredChunks[chunkIndexUnder] && !changedChunks[chunkIndexUnder]) {
                                  includeRowUnder = true;
                              }
                          }

                          this.#renderChunk(cx, cy, includeRowUnder);
                      }
                  }
              }

              // TODO: ? multiple partial putImageData
              this.#context.putImageData(this.#buffer, 0, 0, 0, 0, this.#width, this.#height);
          }

          #renderChunk(cx, cy, includeRowUnder) {
              const mx = Math.min((cx + 1) * this.#chunkSize, this.#width);
              const my = Math.min((cy + 1) * this.#chunkSize + (includeRowUnder ? 1 : 0), this.#height);
              for (let y = cy * this.#chunkSize; y < my; y++) {
                  for (let x = cx * this.#chunkSize; x < mx; x++) {
                      this.#renderPixel(x, y, this.#buffer.data);
                  }
              }
          }

          #renderPixel(x, y, data) {
              const elementTail = this.#elementArea.getElementTail(x, y);

              const pixelIndex = this.#width * y + x;
              const dataIndex = pixelIndex * 4;

              const blurBehaviour = ElementTail.getBlurType(elementTail);

              if (blurBehaviour === ElementTail.BLUR_TYPE_BACKGROUND) {
                  // motion blur

                  if (this.#canBeBlurred[pixelIndex] && Renderer2D.#isWhite(elementTail)) {
                      // init fading here

                      this.#blur[pixelIndex] = true;
                      this.#canBeBlurred[pixelIndex] = false;
                  }

                  if (this.#blur[pixelIndex]) {
                      // paint - continue fading

                      const r = data[dataIndex];
                      const g = data[dataIndex + 1];
                      const b = data[dataIndex + 2];

                      const alpha = 0.875 + (Math.random() * 0.1 - 0.05);
                      const whiteBackground = 255 * (1.0 - alpha);

                      const nr = Math.trunc((r * alpha) + whiteBackground);
                      const ng = Math.trunc((g * alpha) + whiteBackground);
                      const nb = Math.trunc((b * alpha) + whiteBackground);

                      if (r === nr && g === ng && b === nb) {
                          // no change => fading completed
                          this.#blur[pixelIndex] = false;
                          data[dataIndex] = 0xFF;
                          data[dataIndex + 1] = 0xFF;
                          data[dataIndex + 2] = 0xFF;
                      } else {
                          data[dataIndex] = nr;
                          data[dataIndex + 1] = ng;
                          data[dataIndex + 2] = nb;
                          this.trigger(x, y);  // request next repaint
                      }
                      return;
                  }
              }

              // paint - no blur
              if (this.#mode === null) {
                  data[dataIndex] = ElementTail.getColorRed(elementTail);
                  data[dataIndex + 1] = ElementTail.getColorGreen(elementTail);
                  data[dataIndex + 2] = ElementTail.getColorBlue(elementTail);
                  this.#canBeBlurred[pixelIndex] = (blurBehaviour === ElementTail.BLUR_TYPE_1);
                  this.#blur[pixelIndex] = false;
              } else {
                  // custom rendering mode
                  let elementHead = this.#elementArea.getElementHead(x, y);
                  this.#mode.apply(data, dataIndex, elementHead, elementTail);
              }
          }

          static #isWhite(element) {
              return ElementTail.getColorRed(element) === 255
                  && ElementTail.getColorGreen(element) === 255
                  && ElementTail.getColorBlue(element) === 255;
          }
      }

      var img$k = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAABCAIAAACnnMvDAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTUlEQVQ4T22QUZIjMQhDHzhH32PHYj/UZoiTLlcXloQQfsE/AF6QsM6/i4CABa9T5Kj5RPqfkL9s29y2l6e75lBff33Nx2h6AcfGxxP6ykjU+Exkw5m3YxqfbnPRucfPSFev1+p64rbqrm9NAif2xfYiPc5UCz5sixRLZLF2poDMylSmcilcLxkBMhShpBIlCirZiwoEGDz4U/tqxPqg1oMrqcEqkak2sW2g9WlrK2DiBsfQJ1JQi90ZAuLIEnmdwbrwXg+42ImggvpK8mQ+UTvMh//Fdh6D/Xrt1uITqc77/C2SUlRFKaVUpSpFbFKECAEgEGwo2CCog3Bwawy6qNNrZOJumV3XiIu98I4xRztMt7Smz1zkW3YtcmnMXtTPqK35yZ4RJd4bQELiLarYG4m9nwltsMe61/COY6rgfWa+x8xmO1FbWd91P5Lr/2afRpQBYZvbAAAAAElFTkSuQmCC";

      /**
       * @author Patrik Harag
       * @version 2023-08-14
       */
      class RenderingModeHeatmap extends RenderingMode {

          /** @type ImageData */
          #gradientImageData = null;

          constructor() {
              super();
              Assets.asImageData(img$k).then(d => this.#gradientImageData = d);
          }

          apply(data, dataIndex, elementHead, elementTail) {
              if (this.#gradientImageData === null) {
                  // not loaded yet
                  return;
              }

              if (elementHead === 0x00) {
                  // background
                  data[dataIndex] = 0x00;
                  data[dataIndex + 1] = 0x00;
                  data[dataIndex + 2] = 0x00;
              } else {
                  const temperature = ElementHead.getTemperature(elementHead);
                  const x = Math.trunc(temperature / (1 << ElementHead.FIELD_TEMPERATURE_SIZE) * this.#gradientImageData.width);
                  const gradIndex = x * 4;
                  data[dataIndex] = this.#gradientImageData.data[gradIndex];
                  data[dataIndex + 1] = this.#gradientImageData.data[gradIndex + 1];
                  data[dataIndex + 2] = this.#gradientImageData.data[gradIndex + 2];
              }
          }
      }

      /**
       * @author Patrik Harag
       * @version 2023-08-18
       */
      class RenderingModeElementType extends RenderingMode {

          constructor() {
              super();
          }

          #asColor(elementHead) {
              switch (ElementHead.getTypeClass(elementHead)) {
                  case ElementHead.TYPE_AIR: return [255, 255, 255];
                  case ElementHead.TYPE_STATIC: return [0, 0, 0];
                  case ElementHead.TYPE_FLUID: return [0, 0, 255];
                  case ElementHead.TYPE_POWDER:
                  case ElementHead.TYPE_POWDER_WET:
                  case ElementHead.TYPE_POWDER_FLOATING:
                      if (ElementHead.getTypeModifierPowderSliding(elementHead) === 1) {
                          if (ElementHead.getTypeModifierPowderDirection(elementHead) === 1) {
                              return [232, 137, 70];
                          } else {
                              return [255, 0, 0];
                          }
                      }
                      switch (ElementHead.getTypeClass(elementHead)) {
                          case ElementHead.TYPE_POWDER: return [36, 163, 57];
                          case ElementHead.TYPE_POWDER_WET: return [44, 122, 57];
                          case ElementHead.TYPE_POWDER_FLOATING: return [16, 194, 45];
                      }
                      // fallthrough
                  default: return [255, 0, 125];
              }
          }

          apply(data, dataIndex, elementHead, elementTail) {
              const [r, g, b] = this.#asColor(elementHead);

              data[dataIndex] = r;
              data[dataIndex + 1] = g;
              data[dataIndex + 2] = b;

              return false;
          }
      }

      // TODO: Currently element tail bytes are stored as floats (0..1) in texture and then transformed back to integers
      //       My attempts to use integer texture with texelFetch has failed
      //       But at least current solution does not require WebGL 2

      /**
       * WebGL renderer.
       *
       * @author Patrik Harag
       * @version 2023-10-14
       */
      class RendererWebGL extends Renderer {

          /** @type WebGLRenderingContext */
          #context;

          /** @type ElementArea */
          #elementArea;

          /** @type number */
          #width;
          /** @type number */
          #height;

          #doRendering;

          constructor(elementArea, chunkSize, context) {
              super();
              this.#context = context;
              this.#elementArea = elementArea;
              this.#width = elementArea.getWidth();
              this.#height = elementArea.getHeight();

              const gl = this.#context;

              // --- build programs

              const vertexShaderBlur = `
              attribute vec4 a_position;

              varying vec2 v_texcoord;

              void main() {
                gl_Position = a_position;
                v_texcoord = a_position.xy * vec2(0.5, 0.5) + 0.5;
              }
          `;

              const fragmentShaderBlur = `
              precision mediump float;

              varying vec2 v_texcoord;

              uniform sampler2D u_element_tails;
              uniform sampler2D u_blur;

              float rand(vec2 co) {
                  return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
              }

              void main() {
                  vec4 elementTail = texture2D(u_element_tails, v_texcoord);
                  int flags = int(floor(elementTail[3] * 255.0 + 0.5));

                  if (flags == 0x00) {  // == BLUR_TYPE_NONE
                      // do not render non-blurrable elements
                      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);

                  } else if (flags == 0x01) {  // == BLUR_TYPE_BACKGROUND
                      // fade out...

                      vec4 blurElementTail = texture2D(u_blur, v_texcoord);
                      float r = blurElementTail[0];  // 0..1
                      float g = blurElementTail[1];
                      float b = blurElementTail[2];

                      float alpha;  // dynamic alpha
                      float m = max(r, max(g, b));
                      if (m > 0.9) {
                          alpha = 0.875 + (rand(v_texcoord.xy) * 0.1 - 0.05);
                      } else {
                          alpha = 0.775 + (rand(v_texcoord.xy) * 0.04 - 0.02);
                      }
                      float whiteBackground = 1.0 - alpha;

                      float nr = (r * alpha) + whiteBackground;
                      float ng = (g * alpha) + whiteBackground;
                      float nb = (b * alpha) + whiteBackground;

                      if (int(nr * 255.0) == int(r * 255.0)
                              && int(ng * 255.0) == int(g * 255.0)
                              && int(nb * 255.0) == int(b * 255.0)) {

                          // no change - delete blur (otherwise there could be visible remains)
                          gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);

                      } else {
                          gl_FragColor = vec4(nr, ng, nb, 1.0);
                      }

                  } else {  // == BLUR_TYPE_1
                      // render element
                      float r = elementTail[2];  // 0..1
                      float g = elementTail[1];
                      float b = elementTail[0];
                      gl_FragColor = vec4(r, g, b, 1.0);
                  }
              }
          `;

              const blurProgram = this.#loadProgram(gl, vertexShaderBlur, fragmentShaderBlur);
              const blurProgramLocationElementTails = gl.getUniformLocation(blurProgram, "u_element_tails");
              const blurProgramLocationBlur = gl.getUniformLocation(blurProgram, "u_blur");

              const vertexShaderMerging = `
              attribute vec4 a_position;

              varying vec2 v_texcoord;

              void main() {
                gl_Position = a_position;

                // Flip Y though so we get the top at 0
                v_texcoord = a_position.xy * vec2(0.5, -0.5) + 0.5;
              }
          `;

              const fragmentShaderMerging = `
              precision mediump float;

              varying vec2 v_texcoord;

              uniform sampler2D u_element_tails;
              uniform sampler2D u_blur;

              void main() {
                  vec4 elementTail = texture2D(u_element_tails, v_texcoord);
                  int flags = int(floor(elementTail[3] * 255.0 + 0.5));

                  if (flags == 0x00) {  // == BLUR_TYPE_NONE
                      // render element
                      float r = elementTail[2];  // 0..1
                      float g = elementTail[1];
                      float b = elementTail[0];
                      gl_FragColor = vec4(r, g, b, 1.0);

                  } else {
                      gl_FragColor = texture2D(u_blur, v_texcoord);
                  }
              }
          `;

              const mergeProgram = this.#loadProgram(gl, vertexShaderMerging, fragmentShaderMerging);
              const mergeProgramLocationElementTails = gl.getUniformLocation(mergeProgram, "u_element_tails");
              const mergeProgramLocationBlur = gl.getUniformLocation(mergeProgram, "u_blur");

              // --- setup a unit quad

              const positions = [
                  1,  1,
                  -1,  1,
                  -1, -1,
                  1,  1,
                  -1, -1,
                  1, -1,
              ];
              const vertBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
              gl.enableVertexAttribArray(0);
              gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

              // --- prepare texture and associated frame buffer for motion blur
              // it is not possible to sample a texture and render to that same texture at the same time
              // two textures needs to be used - "ping-pong" approach

              const createTextureAndFrameBuffer = (textureId) => {
                  const motionBlurData = new Uint8Array(this.#elementArea.getDataTails().byteLength).fill(0xFF);
                  const motionBlurTexture = gl.createTexture();
                  gl.activeTexture(textureId);
                  gl.bindTexture(gl.TEXTURE_2D, motionBlurTexture);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.#width, this.#height, 0, gl.RGBA, gl.UNSIGNED_BYTE, motionBlurData);

                  const motionBlurFrameBuffer = gl.createFramebuffer();
                  gl.bindFramebuffer(gl.FRAMEBUFFER, motionBlurFrameBuffer);
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, motionBlurTexture, 0);

                  return motionBlurFrameBuffer;
              };

              const motionBlurFrameBuffer1 = createTextureAndFrameBuffer(gl.TEXTURE1);
              const motionBlurFrameBuffer2 = createTextureAndFrameBuffer(gl.TEXTURE2);

              // --- prepare element tails texture - TEXTURE0
              // move the texture definition into rendering loop to create a memory leak - to test WebGL failure recovery

              const elementTailsTexture = gl.createTexture();
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, elementTailsTexture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

              // ---

              let blurTexture = 1;  // "ping-pong" approach - see above
              this.#doRendering = () => {

                  // update element tails texture
                  const elementTails = new Uint8Array(this.#elementArea.getDataTails());
                  gl.bindTexture(gl.TEXTURE_2D, elementTailsTexture);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.#width, this.#height, 0, gl.RGBA, gl.UNSIGNED_BYTE, elementTails);

                  // render blurrable elements and blur into a texture
                  // - reduce blur from previous iterations (fading out) and render blurrable elements over
                  gl.bindFramebuffer(gl.FRAMEBUFFER, blurTexture === 1 ? motionBlurFrameBuffer1 : motionBlurFrameBuffer2);

                  gl.useProgram(blurProgram);
                  gl.uniform1i(blurProgramLocationElementTails, 0);  // texture 0
                  gl.uniform1i(blurProgramLocationBlur, (blurTexture === 1) ? 2 : 1);  // texture 2 or 1

                  gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);

                  // render to canvas
                  // - blurrable elements and blur will be merged with elements that cannot be blurred
                  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                  gl.useProgram(mergeProgram);
                  gl.uniform1i(mergeProgramLocationElementTails, 0);  // texture 0
                  gl.uniform1i(mergeProgramLocationBlur, blurTexture);  // texture 1 or 2

                  gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);

                  blurTexture = (blurTexture === 1) ? 2 : 1;
              };
          }

          trigger(x, y) {
              // ignore
          }

          /**
           *
           * @param changedChunks {boolean[]}
           * @return {void}
           */
          render(changedChunks) {
              this.#doRendering();
          }

          /**
           *
           * @param gl {WebGLRenderingContext} The WebGLRenderingContext to use.
           * @param vertexShader {string} vertex shader code
           * @param fragmentShader {string} fragment shader code
           * @return {WebGLProgram}
           */
          #loadProgram(gl, vertexShader, fragmentShader) {
              const program = gl.createProgram();

              gl.attachShader(program, this.#loadShader(gl, vertexShader, gl.VERTEX_SHADER));
              gl.bindAttribLocation(program, 0, "a_position");

              gl.attachShader(program, this.#loadShader(gl, fragmentShader, gl.FRAGMENT_SHADER));

              gl.linkProgram(program);
              this.#checkLinkStatus(gl, program);

              return program;
          }

          /**
           *
           * @param gl {WebGLRenderingContext} The WebGLRenderingContext to use.
           * @param shaderSource {string} The shader source.
           * @param shaderType {number} The type of shader.
           * @return {WebGLShader}
           */
          #loadShader(gl, shaderSource, shaderType) {
              // Create the shader object
              const shader = gl.createShader(shaderType);

              // Load the shader source
              gl.shaderSource(shader, shaderSource);

              // Compile the shader
              gl.compileShader(shader);

              // Check the compile status
              const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
              if (!compiled) {
                  // Something went wrong during compilation; get the error
                  const lastError = gl.getShaderInfoLog(shader);
                  throw `Error compiling shader: ${lastError}`;
              }

              return shader;
          }

          #checkLinkStatus(gl, program) {
              const linked = gl.getProgramParameter(program, gl.LINK_STATUS);
              if (!linked) {
                  // something went wrong with the link
                  const lastError = gl.getProgramInfoLog(program);
                  throw `Error in program linking: ${lastError}`;
              }
          }
      }

      /**
       * Null renderer. For testing purposes - to measure effects of rendering...
       *
       * @author Patrik Harag
       * @version 2023-10-11
       */
      class RendererNull extends Renderer {

          constructor() {
              super();
          }

          trigger(x, y) {
              // ignore
          }

          render(changedChunks) {
              // ignore
          }
      }

      /**
       * @interface
       *
       * @author Patrik Harag
       * @version 2023-10-11
       */
      class RendererInitializer {

          getContextType() {
              throw 'Not implemented'
          }

          /**
           *
           * @param elementArea
           * @param chunkSize
           * @param context
           * @return {Renderer}
           */
          initialize(elementArea, chunkSize, context) {
              throw 'Not implemented'
          }

          // static factory methods

          static canvas2d() {
              return new RendererInitializer2D(null);
          }

          static canvas2dHeatmap() {
              return new RendererInitializer2D(new RenderingModeHeatmap());
          }

          static canvas2dElementType() {
              return new RendererInitializer2D(new RenderingModeElementType())
          }

          static canvasWebGL() {
              return new RendererInitializerWebGL();
          }

          static nullRenderer() {
              return new RendererInitializerNull();
          }
      }

      class RendererInitializer2D extends RendererInitializer {

          #mode;

          constructor(mode) {
              super();
              this.#mode = mode;
          }

          getContextType() {
              return '2d';
          }

          initialize(elementArea, chunkSize, context) {
              let renderer = new Renderer2D(elementArea, chunkSize, context);
              if (this.#mode !== null) {
                  renderer.setMode(this.#mode);
              }
              return renderer;
          }
      }

      class RendererInitializerWebGL extends RendererInitializer {

          getContextType() {
              return 'webgl';
          }

          initialize(elementArea, chunkSize, context) {
              return new RendererWebGL(elementArea, chunkSize, context);
          }
      }

      class RendererInitializerNull extends RendererInitializer {

          constructor() {
              super();
          }

          getContextType() {
              return '2d';
          }

          initialize(elementArea, chunkSize, context) {
              return new RendererNull();
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-20
       */
      class FloodFillPainter {

          static NEIGHBOURHOOD_VON_NEUMANN = 0;
          static NEIGHBOURHOOD_MOORE = 1;


          /** @type ElementArea */
          #elementArea;

          /** @type SandGameGraphics */
          #graphics;

          #neighbourhood;

          /**
           *
           * @param elementArea {ElementArea}
           * @param neighbourhood
           * @param graphics {SandGameGraphics}
           */
          constructor(elementArea, neighbourhood = FloodFillPainter.NEIGHBOURHOOD_VON_NEUMANN, graphics) {
              this.#elementArea = elementArea;
              this.#neighbourhood = neighbourhood;
              this.#graphics = graphics;
          }

          /**
           *
           * @param x {number}
           * @param y {number}
           * @param brush {Brush}
           */
          paint(x, y, brush) {
              const pattern = 0b1111_11100111;  // TODO: different for fluid, powder-like...
              const matcher = this.#normalize(this.#elementArea.getElementHead(x, y)) & pattern;

              const w = this.#elementArea.getWidth();

              const pointSet = new Set();
              const queue = [];

              let point = x + y * w;
              do {
                  let x = point % w;
                  let y = Math.trunc(point / w);

                  if (pointSet.has(point)) {
                      continue;  // already completed
                  }

                  this.#graphics.draw(x, y, brush);
                  pointSet.add(point);

                  // add neighbours
                  this.#tryAdd(x, y - 1, pattern, matcher, pointSet, queue);
                  this.#tryAdd(x + 1, y, pattern, matcher, pointSet, queue);
                  this.#tryAdd(x, y + 1, pattern, matcher, pointSet, queue);
                  this.#tryAdd(x - 1, y, pattern, matcher, pointSet, queue);

                  if (this.#neighbourhood === FloodFillPainter.NEIGHBOURHOOD_MOORE) {
                      this.#tryAdd(x + 1, y + 1, pattern, matcher, pointSet, queue);
                      this.#tryAdd(x + 1, y - 1, pattern, matcher, pointSet, queue);
                      this.#tryAdd(x - 1, y + 1, pattern, matcher, pointSet, queue);
                      this.#tryAdd(x - 1, y - 1, pattern, matcher, pointSet, queue);
                  }

              } while ((point = queue.pop()) != null);
          }

          #tryAdd(x, y, pattern, matcher, pointSet, queue) {
              const w = this.#elementArea.getWidth();
              const h = this.#elementArea.getHeight();

              if (x < 0 || y < 0) {
                  return;
              }
              if (x >= w || y >= h) {
                  return;
              }

              if (!this.#equals(x, y, pattern, matcher)) {
                  return;
              }

              const point = x + y * w;
              if (pointSet.has(point)) {
                  return;
              }

              queue.push(point);
          }

          #equals(x, y, pattern, matcher) {
              let elementHead = this.#elementArea.getElementHead(x, y);
              elementHead = this.#normalize(elementHead);
              return (elementHead & pattern) === matcher;
          }

          #normalize(elementHead) {
              // wetness is ignored
              if (ElementHead.getTypeClass(elementHead) === ElementHead.TYPE_POWDER_WET) {
                  elementHead = ElementHead.setTypeClass(elementHead, ElementHead.TYPE_POWDER);
              }
              return elementHead;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-07-23
       */
      class SandGameGraphics {

          /** @type ElementArea */
          #elementArea;

          /** @type DeterministicRandom */
          #random;

          /** @type function(number, number) */
          #triggerFunction;

          constructor(elementArea, random, triggerFunction) {
              this.#elementArea = elementArea;
              this.#random = random;
              this.#triggerFunction = triggerFunction;
          }

          /**
           *
           * @param aX {number}
           * @param aY {number}
           * @param bX {number}
           * @param bY {number}
           */
          swap(aX, aY, bX, bY) {
              if (this.#elementArea.isValidPosition(aX, aY) && this.#elementArea.isValidPosition(bX, bY)) {
                  this.#elementArea.swap(aX, aY, bX, bY);
              }
          }

          /**
           *
           * @param x {number}
           * @param y {number}
           * @param brushOrElement {Brush|Element}
           */
          draw(x, y, brushOrElement) {
              if (this.#elementArea.isValidPosition(x, y)) {
                  if (brushOrElement instanceof Element) {
                      this.#elementArea.setElement(x, y, brushOrElement);
                      this.#triggerFunction(x, y);
                  } else if (brushOrElement instanceof Brush) {
                      let oldElement = this.#elementArea.getElement(x, y);
                      let newElement = brushOrElement.apply(x, y, this.#random, oldElement);
                      this.#elementArea.setElement(x, y, newElement);
                      this.#triggerFunction(x, y);
                  } else {
                      throw 'Brush or Element expected';
                  }
              }
          }

          drawRectangle(x1, y1, x2, y2, brush, supportNegativeCoordinates = false) {
              if (supportNegativeCoordinates) {
                  x1 = (x1 >= 0) ? x1 : this.getWidth() + x1 + 1;
                  x2 = (x2 >= 0) ? x2 : this.getWidth() + x2 + 1;
                  y1 = (y1 >= 0) ? y1 : this.getHeight() + y1 + 1;
                  y2 = (y2 >= 0) ? y2 : this.getHeight() + y2 + 1;
              }

              x1 = Math.max(Math.min(x1, this.getWidth() - 1), 0);
              x2 = Math.max(Math.min(x2, this.getWidth() - 1), 0);
              y1 = Math.max(Math.min(y1, this.getHeight() - 1), 0);
              y2 = Math.max(Math.min(y2, this.getHeight() - 1), 0);

              for (let y = y1; y <= y2; y++) {
                  for (let x = x1; x <= x2; x++) {
                      this.draw(x, y, brush);
                  }
              }
          }

          drawLine(x1, y1, x2, y2, size, brush, round=false) {
              const d = Math.ceil(size / 2);

              let consumer;
              if (round) {
                  consumer = (x, y) => {
                      CircleIterator.iterate(CircleIterator.BLUEPRINT_3, (dx, dy, level) => {
                          this.draw(x + dx, y + dy, brush);
                      });
                  };
              } else {
                  consumer = (x, y) => {
                      this.drawRectangle(x - d, y - d, x + d, y + d, brush);
                  };
              }

              SandGameGraphics.#lineAlgorithm(x1, y1, x2, y2, consumer);
          }

          static #lineAlgorithm(x1, y1, x2, y2, consumer) {
              consumer(x1, y1);

              if ((x1 !== x2) || (y1 !== y2)) {
                  const moveX = x1 < x2 ? 1 : -1;
                  const moveY = y1 < y2 ? 1 : -1;

                  const dx = Math.abs(x2 - x1);
                  const dy = Math.abs(y2 - y1);
                  let diff = dx - dy;

                  while ((x1 !== x2) || (y1 !== y2)) {
                      const p = 2 * diff;

                      if (p > -dy) {
                          diff = diff - dy;
                          x1 = x1 + moveX;
                      }
                      if (p < dx) {
                          diff = diff + dx;
                          y1 = y1 + moveY;
                      }
                      consumer(x1, y1);
                  }
              }
          }

          fill(brush) {
              this.drawRectangle(0, 0, this.#elementArea.getWidth() - 1, this.#elementArea.getHeight() - 1, brush);
          }

          floodFill(x, y, brush, neighbourhood) {
              let floodFillPainter = new FloodFillPainter(this.#elementArea, neighbourhood, this);
              floodFillPainter.paint(x, y, brush);
          }

          replace(elementTarget, elementReplacement) {
              const width = this.getWidth();
              const height = this.getHeight();
              for (let y = 0; y < height; y++) {
                  for (let x = 0; x < width; x++) {
                      const next = this.#elementArea.getElement(x, y);
                      if (next.elementHead === elementTarget.elementHead && next.elementTail === elementTarget.elementTail) {
                          this.#elementArea.setElement(x, y, elementReplacement);
                      }
                  }
              }
          }

          getWidth() {
              return this.#elementArea.getWidth();
          }

          getHeight() {
              return this.#elementArea.getHeight();
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-10-11
       */
      class Snapshot {

          /** @type SceneMetadata */
          metadata;

          /** @type ArrayBuffer */
          dataHeads;

          /** @type ArrayBuffer */
          dataTails;
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-20
       */
      class SceneMetadata {

          static CURRENT_FORMAT_VERSION = 3;


          /** @type number */
          formatVersion;

          /** @type number|undefined */
          created;

          /** @type number|undefined */
          width;

          /** @type number|undefined */
          height;

          /** @type number|undefined */
          scale;

          /** @type number|undefined */
          random;

          /** @type number|undefined */
          iteration;

          /** @type boolean|undefined */
          fallThroughEnabled;

          /** @type boolean|undefined */
          erasingEnabled;
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-05-16
       */
      class SpawningExtensionFish {

          #elementArea;
          #random;
          #processorContext;
          #brushHead = Brushes.FISH;
          #brushBody = Brushes.FISH_BODY;

          #counterStartValue = 2;
          #counter = 2;

          constructor(elementArea, random, processorContext) {
              this.#elementArea = elementArea;
              this.#random = random;
              this.#processorContext = processorContext;
          }

          run() {
              if (this.#counter-- === 0) {
                  this.#counter = this.#counterStartValue;

                  const x = this.#random.nextInt(this.#elementArea.getWidth() - 2) + 1;
                  const y = this.#random.nextInt(this.#elementArea.getHeight() - 2) + 1;

                  if (this.#couldSpawnHere(this.#elementArea, x, y)) {
                      this.#elementArea.setElement(x, y, this.#brushHead.apply(x, y, this.#random));
                      this.#processorContext.trigger(x, y);
                      this.#elementArea.setElement(x + 1, y, this.#brushBody.apply(x + 1, y, this.#random));
                      this.#processorContext.trigger(x + 1, y);

                      // increase difficulty of spawning fish again
                      this.#counterStartValue = this.#counterStartValue << 2;
                  }
              }
          }

          #couldSpawnHere(elementArea, x, y) {
              // space around
              if (x < 1 || y < 1) {
                  return false;
              }
              if (x + 1 >= elementArea.getWidth() || y + 1 >= elementArea.getHeight()) {
                  return false;
              }

              // water around
              if (!this.#isWater(elementArea, x, y) || !this.#isWater(elementArea, x - 1, y)
                  || !this.#isWater(elementArea, x + 1, y) || !this.#isWater(elementArea, x + 2, y)
                  || !this.#isWater(elementArea, x + 1, y + 1) || !this.#isWater(elementArea, x + 2, y + 1)
                  || !this.#isWater(elementArea, x + 1, y - 1) || !this.#isWater(elementArea, x + 2, y - 1)) {
                  return false;
              }

              // sand around
              return this.#isSand(elementArea, x, y + 2)
                  || this.#isSand(elementArea, x + 1, y + 2);
          }

          #isWater(elementArea, x, y) {
              if (!elementArea.isValidPosition(x, y)) {
                  return false;
              }
              const targetElementHead = elementArea.getElementHead(x, y);
              const type = ElementHead.getTypeClass(targetElementHead);
              return type === ElementHead.TYPE_FLUID;
          }

          #isSand(elementArea, x, y) {
              if (!elementArea.isValidPosition(x, y)) {
                  return false;
              }
              const targetElementHead = elementArea.getElementHead(x, y);
              const type = ElementHead.getTypeClass(targetElementHead);
              return type === ElementHead.TYPE_POWDER || type === ElementHead.TYPE_POWDER_WET;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-05-16
       */
      class SpawningExtensionGrass {
          static MAX_COUNTER_VALUE = 2;

          #elementArea;
          #random;
          #processorContext;
          #brush = Brushes.GRASS;

          #counter = SpawningExtensionGrass.MAX_COUNTER_VALUE;

          constructor(elementArea, random, processorContext) {
              this.#elementArea = elementArea;
              this.#random = random;
              this.#processorContext = processorContext;
          }

          run() {
              if (this.#counter-- === 0) {
                  this.#counter = SpawningExtensionGrass.MAX_COUNTER_VALUE;

                  const x = this.#random.nextInt(this.#elementArea.getWidth());
                  const y = this.#random.nextInt(this.#elementArea.getHeight() - 3) + 2;

                  if (ProcessorModuleGrass.canGrowUpHere(this.#elementArea, x, y)) {
                      this.#elementArea.setElement(x, y, this.#brush.apply(x, y, this.#random));
                      this.#processorContext.trigger(x, y);
                  }
              }
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-05-16
       */
      class SpawningExtensionTree {
          static STARTING_COUNTER_VALUE = 1000;
          static MAX_COUNTER_VALUE = 4;

          #elementArea;
          #random;
          #processorContext;
          #brush = Brushes.TREE;

          #counter = SpawningExtensionTree.STARTING_COUNTER_VALUE;

          constructor(elementArea, random, processorContext) {
              this.#elementArea = elementArea;
              this.#random = random;
              this.#processorContext = processorContext;
          }

          run() {
              if (this.#counter-- === 0) {
                  this.#counter = SpawningExtensionTree.MAX_COUNTER_VALUE;

                  const x = this.#random.nextInt(this.#elementArea.getWidth() - 12) + 6;
                  const y = this.#random.nextInt(this.#elementArea.getHeight() - 16) + 15;

                  if (SpawningExtensionTree.couldGrowUpHere(this.#elementArea, x, y)) {
                      this.#elementArea.setElement(x, y, this.#brush.apply(x, y, this.#random));
                      this.#processorContext.trigger(x, y);
                  }
              }
          }

          static couldGrowUpHere(elementArea, x, y) {
              if (x < 0 || y < 12) {
                  return false;
              }
              if (x > elementArea.getWidth() - 5 || y > elementArea.getHeight() - 2) {
                  return false;
              }
              let e1 = elementArea.getElementHead(x, y);
              if (ElementHead.getBehaviour(e1) !== ElementHead.BEHAVIOUR_GRASS) {
                  return false;
              }
              let e2 = elementArea.getElementHead(x, y + 1);
              if (ElementHead.getBehaviour(e2) !== ElementHead.BEHAVIOUR_SOIL) {
                  return false;
              }

              // check space directly above
              for (let dy = 1; dy < 18; dy++) {
                  if (!SpawningExtensionTree.#isSpaceHere(elementArea, x, y - dy)) {
                      return false;
                  }
              }

              // check trees around
              for (let dx = -8; dx < 8; dx++) {
                  if (SpawningExtensionTree.#isOtherThreeThere(elementArea, x + dx, y - 4)) {
                      return false;
                  }
              }

              // check space above - left & right
              for (let dy = 10; dy < 15; dy++) {
                  if (!SpawningExtensionTree.#isSpaceHere(elementArea, x - 8, y - dy)) {
                      return false;
                  }
                  if (!SpawningExtensionTree.#isSpaceHere(elementArea, x + 8, y - dy)) {
                      return false;
                  }
              }

              return true;
          }

          static #isSpaceHere(elementArea, tx, ty) {
              let targetElementHead = elementArea.getElementHead(tx, ty);
              if (ElementHead.getTypeClass(targetElementHead) === ElementHead.TYPE_AIR) {
                  return true;
              }
              if (ElementHead.getBehaviour(targetElementHead) === ElementHead.BEHAVIOUR_GRASS) {
                  return true;
              }
              return false;
          }

          static #isOtherThreeThere(elementArea, tx, ty) {
              let targetElementHead = elementArea.getElementHead(tx, ty);
              let behaviour = ElementHead.getBehaviour(targetElementHead);
              if (behaviour === ElementHead.BEHAVIOUR_TREE_TRUNK || behaviour === ElementHead.BEHAVIOUR_TREE) {
                  return true;
              }
              return false;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2022-09-21
       */
      class TemplateBlockPainter {

          /** @type SandGameGraphics */
          #graphics;

          /** @type string|string[]|null */
          #blueprint = null;
          /** @type object|null */
          #brushes = null;

          /** @type number */
          #maxHeight = Number.MAX_SAFE_INTEGER;

          /** @type string */
          #verticalAlign = 'bottom';

          /**
           *
           * @param graphics {SandGameGraphics}
           */
          constructor(graphics) {
              this.#graphics = graphics;
          }

          /**
           *
           * @param blueprint {string|string[]}
           * @returns {TemplateBlockPainter}
           */
          withBlueprint(blueprint) {
              this.#blueprint = blueprint;
              return this;
          }

          /**
           *
           * @param brushes
           * @returns {TemplateBlockPainter}
           */
          withBrushes(brushes) {
              this.#brushes = brushes;
              return this;
          }

          /**
           *
           * @param maxHeight max template height
           * @param align {string} bottom|top
           * @returns {TemplateBlockPainter}
           */
          withMaxHeight(maxHeight, align = 'bottom') {
              this.#maxHeight = maxHeight;
              this.#verticalAlign = align;
              return this;
          }

          paint() {
              if (this.#blueprint === null || this.#blueprint.length === 0) {
                  throw 'Blueprint not set';
              }
              if (this.#brushes === null) {
                  throw 'Brushes not set';
              }

              const blueprint = (typeof this.#blueprint === 'string')
                  ? this.#blueprint.split('\n')
                  : this.#blueprint;

              const w = blueprint[0].length;
              const h = blueprint.length;

              const ww = Math.ceil(this.#graphics.getWidth() / w);
              const hh = Math.ceil(Math.min(this.#graphics.getHeight(), this.#maxHeight) / h);
              // note: rounding up is intentional - we don't want gaps, drawRectangle can handle drawing out of canvas

              const verticalOffset = (this.#verticalAlign === 'bottom' ? this.#graphics.getHeight() - (hh * h) : 0);

              for (let y = 0; y < h; y++) {
                  const line = blueprint[y];
                  for (let x = 0; x < Math.min(w, line.length); x++) {
                      const char = line.charAt(x);
                      let brush = this.#brushes[char];
                      if (brush === undefined) {
                          if (char === ' ') {
                              // let this cell empty
                              continue;
                          }
                          throw 'Brush not found: ' + char;
                      }
                      this.#graphics.drawRectangle(
                          x * ww, verticalOffset + (y * hh),
                          x * ww + ww, verticalOffset + (y * hh) + hh, brush);
                  }
              }
          }
      }

      var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

      var cubicSpline = class Spline {
        constructor(xs, ys) {
          this.xs = xs;
          this.ys = ys;
          this.ks = this.getNaturalKs(new Float64Array(this.xs.length));
        }

        getNaturalKs(ks) {
          const n = this.xs.length - 1;
          const A = zerosMat(n + 1, n + 2);

          for (
            let i = 1;
            i < n;
            i++ // rows
          ) {
            A[i][i - 1] = 1 / (this.xs[i] - this.xs[i - 1]);
            A[i][i] =
              2 *
              (1 / (this.xs[i] - this.xs[i - 1]) + 1 / (this.xs[i + 1] - this.xs[i]));
            A[i][i + 1] = 1 / (this.xs[i + 1] - this.xs[i]);
            A[i][n + 1] =
              3 *
              ((this.ys[i] - this.ys[i - 1]) /
                ((this.xs[i] - this.xs[i - 1]) * (this.xs[i] - this.xs[i - 1])) +
                (this.ys[i + 1] - this.ys[i]) /
                  ((this.xs[i + 1] - this.xs[i]) * (this.xs[i + 1] - this.xs[i])));
          }

          A[0][0] = 2 / (this.xs[1] - this.xs[0]);
          A[0][1] = 1 / (this.xs[1] - this.xs[0]);
          A[0][n + 1] =
            (3 * (this.ys[1] - this.ys[0])) /
            ((this.xs[1] - this.xs[0]) * (this.xs[1] - this.xs[0]));

          A[n][n - 1] = 1 / (this.xs[n] - this.xs[n - 1]);
          A[n][n] = 2 / (this.xs[n] - this.xs[n - 1]);
          A[n][n + 1] =
            (3 * (this.ys[n] - this.ys[n - 1])) /
            ((this.xs[n] - this.xs[n - 1]) * (this.xs[n] - this.xs[n - 1]));

          return solve(A, ks);
        }

        /**
         * inspired by https://stackoverflow.com/a/40850313/4417327
         */
        getIndexBefore(target) {
          let low = 0;
          let high = this.xs.length;
          let mid = 0;
          while (low < high) {
            mid = Math.floor((low + high) / 2);
            if (this.xs[mid] < target && mid !== low) {
              low = mid;
            } else if (this.xs[mid] >= target && mid !== high) {
              high = mid;
            } else {
              high = low;
            }
          }
          return low + 1;
        }

        at(x) {
          let i = this.getIndexBefore(x);
          const t = (x - this.xs[i - 1]) / (this.xs[i] - this.xs[i - 1]);
          const a =
            this.ks[i - 1] * (this.xs[i] - this.xs[i - 1]) -
            (this.ys[i] - this.ys[i - 1]);
          const b =
            -this.ks[i] * (this.xs[i] - this.xs[i - 1]) +
            (this.ys[i] - this.ys[i - 1]);
          const q =
            (1 - t) * this.ys[i - 1] +
            t * this.ys[i] +
            t * (1 - t) * (a * (1 - t) + b * t);
          return q;
        }
      };

      function solve(A, ks) {
        const m = A.length;
        let h = 0;
        let k = 0;
        while (h < m && k <= m) {
          let i_max = 0;
          let max = -Infinity;
          for (let i = h; i < m; i++) {
            const v = Math.abs(A[i][k]);
            if (v > max) {
              i_max = i;
              max = v;
            }
          }

          if (A[i_max][k] === 0) {
            k++;
          } else {
            swapRows(A, h, i_max);
            for (let i = h + 1; i < m; i++) {
              const f = A[i][k] / A[h][k];
              A[i][k] = 0;
              for (let j = k + 1; j <= m; j++) A[i][j] -= A[h][j] * f;
            }
            h++;
            k++;
          }
        }

        for (
          let i = m - 1;
          i >= 0;
          i-- // rows = columns
        ) {
          var v = 0;
          if (A[i][i]) {
            v = A[i][m] / A[i][i];
          }
          ks[i] = v;
          for (
            let j = i - 1;
            j >= 0;
            j-- // rows
          ) {
            A[j][m] -= A[j][i] * v;
            A[j][i] = 0;
          }
        }
        return ks;
      }

      function zerosMat(r, c) {
        const A = [];
        for (let i = 0; i < r; i++) A.push(new Float64Array(c));
        return A;
      }

      function swapRows(m, k, l) {
        let p = m[k];
        m[k] = m[l];
        m[l] = p;
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-02-25
       */
      class TemplateLayeredPainter {

          static #spline(points) {
              const xs = new Array(points.length);
              const ys = new Array(points.length);
              for (let i = 0; i < points.length; i++) {
                  xs[i] = points[i][0];
                  ys[i] = points[i][1];
              }
              const spline = new cubicSpline(xs, ys);
              return function (x) {
                  return Math.max(Math.trunc(spline.at(x)), 0);
              };
          }

          static #constant(height) {
              return function(x) {
                  return Math.trunc(height);
              };
          }


          /** @type ElementArea */
          #elementArea;

          /** @type SandGameGraphics */
          #graphics;

          /** @type DeterministicRandom */
          #random;

          /** @type ProcessorContext */
          #processorContext;

          #lastLevel;

          /**
           *
           * @param elementArea {ElementArea}
           * @param graphics {SandGameGraphics}
           * @param random {DeterministicRandom}
           * @param processorContext {ProcessorContext}
           */
          constructor(elementArea, graphics, random, processorContext) {
              this.#elementArea = elementArea;
              this.#graphics = graphics;
              this.#random = random;
              this.#processorContext = processorContext;
              this.#lastLevel = new Array(elementArea.getWidth()).fill(0);
          }

          layer(layer, relative, brush, shuffleWithLevelBelow = 0) {
              const f = (typeof layer === 'number')
                      ? TemplateLayeredPainter.#constant(layer)
                      : TemplateLayeredPainter.#spline(layer);

              for (let x = 0; x < this.#elementArea.getWidth(); x++) {
                  const lastLevel = this.#lastLevel[x];

                  const level = (relative)
                          ? lastLevel + f(x)
                          : f(x);

                  if (lastLevel < level) {
                      let count = 0;
                      for (let i = lastLevel; i < level && i < this.#elementArea.getHeight(); i++) {
                          let y = this.#elementArea.getHeight() - 1 - i;
                          this.#graphics.draw(x, y, brush);
                          count++;
                      }

                      // shuffle
                      if (shuffleWithLevelBelow > 0 && count > 0) {
                          for (let i = 0; i < shuffleWithLevelBelow; i++) {
                              const max = Math.min(Math.trunc(count / 2), 10);
                              if (max > 1) {
                                  const r = this.#random.nextInt(Math.ceil(max)) - Math.trunc(max / 2);
                                  const y1 = this.#elementArea.getHeight() - 1 - lastLevel + r;
                                  const y2 = this.#elementArea.getHeight() - 1 - lastLevel + r + 1;
                                  if (y1 < this.#elementArea.getHeight() && y2 < this.#elementArea.getHeight()) {
                                      this.#elementArea.swap(x, y1, x, y2);
                                  }
                              }
                          }
                      }

                      this.#lastLevel[x] = level;
                  }
              }
              return this;
          }

          grass() {
              for (let x = 0; x < this.#elementArea.getWidth(); x++) {
                  const lastLevel = this.#lastLevel[x];
                  const y = this.#elementArea.getHeight() - 1 - lastLevel;

                  if (ProcessorModuleGrass.canGrowUpHere(this.#elementArea, x, y)) {
                      ProcessorModuleGrass.spawnHere(this.#elementArea, x, y, Brushes.GRASS, this.#random);
                  }
              }
              return this;
          }

          tree(x, type = 0) {
              if (x <= 5 || x >= this.#elementArea.getWidth() - 5) {
                  return this;  // out of bounds
              }

              const lastLevel = this.#lastLevel[x];
              const y = this.#elementArea.getHeight() - 1 - lastLevel;

              ProcessorModuleTree.spawnHere(this.#elementArea, x, y, type, Brushes.TREE, this.#random, this.#processorContext);
              return this;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-27
       */
      class SandGame {

          /** @type ElementArea */
          #elementArea;

          /** @type number */
          #width;

          /** @type number */
          #height;

          /** @type DeterministicRandom */
          #random;

          /** @type Counter */
          #framesCounter;

          /** @type Counter */
          #iterationsCounter;

          /** @type Processor */
          #processor;

          /** @type Renderer */
          #renderer;

          /** @type number|null */
          #processorIntervalHandle = null;

          /** @type number|null */
          #rendererIntervalHandle = null;

          /** @type function[] */
          #onRendered = [];

          /** @type function[] */
          #onProcessed = [];

          /**
           *
           * @param elementArea {ElementArea}
           * @param sceneMetadata {SceneMetadata|null}
           * @param defaultElement {Element}
           * @param context {CanvasRenderingContext2D|WebGL2RenderingContext}
           * @param rendererInitializer {RendererInitializer}
           */
          constructor(elementArea, sceneMetadata, defaultElement, context, rendererInitializer) {
              this.#elementArea = elementArea;
              this.#random = new DeterministicRandom((sceneMetadata) ? sceneMetadata.random : 0);
              this.#framesCounter = new Counter();
              this.#iterationsCounter = new Counter();
              this.#processor = new Processor(this.#elementArea, 16, this.#random, defaultElement, sceneMetadata);
              this.#renderer = rendererInitializer.initialize(this.#elementArea, 16, context);
              this.#width = elementArea.getWidth();
              this.#height = elementArea.getHeight();

              let grassSpawningExt = new SpawningExtensionGrass(this.#elementArea, this.#random, this.#processor);
              this.#onProcessed.push(() => grassSpawningExt.run());
              let treeSpawningExt = new SpawningExtensionTree(this.#elementArea, this.#random, this.#processor);
              this.#onProcessed.push(() => treeSpawningExt.run());
              let fishSpawningExt = new SpawningExtensionFish(this.#elementArea, this.#random, this.#processor);
              this.#onProcessed.push(() => fishSpawningExt.run());
          }

          startProcessing() {
              if (this.#processorIntervalHandle === null) {
                  const interval = Math.trunc(1000 / Processor.OPT_CYCLES_PER_SECOND);  // ms
                  this.#processorIntervalHandle = setInterval(() => this.doProcessing(), interval);
              }
          }

          startRendering() {
              if (this.#rendererIntervalHandle === null) {
                  const interval = Math.trunc(1000 / Processor.OPT_FRAMES_PER_SECOND);  // ms
                  this.#rendererIntervalHandle = setInterval(() => this.doRendering(), interval);
              }
          }

          stopProcessing() {
              if (this.#processorIntervalHandle !== null) {
                  clearInterval(this.#processorIntervalHandle);
                  this.#processorIntervalHandle = null;
              }
              this.#iterationsCounter.clear();
          }

          stopRendering() {
              if (this.#rendererIntervalHandle !== null) {
                  clearInterval(this.#rendererIntervalHandle);
                  this.#rendererIntervalHandle = null;
              }
              this.#framesCounter.clear();
          }

          doProcessing() {
              this.#processor.next();
              const t = Date.now();
              this.#iterationsCounter.tick(t);
              for (let func of this.#onProcessed) {
                  func();
              }
          }

          doRendering() {
              const changedChunks = this.#processor.getChangedChunks();
              this.#renderer.render(changedChunks);
              const t = Date.now();
              this.#framesCounter.tick(t);
              for (let func of this.#onRendered) {
                  func(changedChunks);
              }
              this.#processor.cleanChangedChunks();
          }

          graphics() {
              return new SandGameGraphics(this.#elementArea, this.#random, (x, y) => {
                  this.#processor.trigger(x, y);
                  this.#renderer.trigger(x, y);
              });
          }

          blockTemplate() {
              return new TemplateBlockPainter(this.graphics());
          }

          layeredTemplate() {
              return new TemplateLayeredPainter(this.#elementArea, this.graphics(), this.#random, this.#processor);
          }

          setBoxedMode() {
              this.#processor.setFallThroughEnabled(false);
              this.#processor.setErasingEnabled(false);
          }

          setFallThroughMode() {
              this.#processor.setFallThroughEnabled(true);
              this.#processor.setErasingEnabled(false);
          }

          setErasingMode() {
              this.#processor.setFallThroughEnabled(false);
              this.#processor.setErasingEnabled(true);
          }

          addOnProcessed(handler) {
              this.#onProcessed.push(handler);
          }

          addOnRendered(handler) {
              this.#onRendered.push(handler);
          }

          getFramesPerSecond() {
              return this.#framesCounter.getValue();
          }

          getIterationsPerSecond() {
              return this.#iterationsCounter.getValue();
          }

          getWidth() {
              return this.#width;
          }

          getHeight() {
              return this.#height;
          }

          getChunkSize() {
              return 16;
          }

          copyStateTo(targetSandGame) {
              let sourceY0;
              let targetY0;
              if (targetSandGame.#height >= this.#height) {
                  sourceY0 = 0;
                  targetY0 = targetSandGame.#height - this.#height;
              } else {
                  sourceY0 = this.#height - targetSandGame.#height;
                  targetY0 = 0;
              }

              for (let y = 0; y < Math.min(this.#height, targetSandGame.#height); y++) {
                  for (let x = 0; x < Math.min(this.#width, targetSandGame.#width); x++) {
                      let elementHead = this.#elementArea.getElementHead(x, y + sourceY0);
                      let elementTail = this.#elementArea.getElementTail(x, y + sourceY0);
                      targetSandGame.#elementArea.setElementHead(x, targetY0 + y, elementHead);
                      targetSandGame.#elementArea.setElementTail(x, targetY0 + y, elementTail);
                  }
              }
              targetSandGame.#processor.setFallThroughEnabled(this.#processor.isFallThroughEnabled());
              targetSandGame.#processor.setErasingEnabled(this.#processor.isErasingEnabled());
          }

          /**
           * @returns {Snapshot}
           */
          createSnapshot() {
              let metadata = new SceneMetadata();
              metadata.formatVersion = SceneMetadata.CURRENT_FORMAT_VERSION;
              metadata.created = new Date().getTime();
              metadata.width = this.#width;
              metadata.height = this.#height;
              metadata.random = this.#random.getState();
              metadata.iteration = this.#processor.getIteration();
              metadata.fallThroughEnabled = this.#processor.isFallThroughEnabled();
              metadata.erasingEnabled = this.#processor.isErasingEnabled();

              let snapshot = new Snapshot();
              snapshot.metadata = metadata;
              snapshot.dataHeads = this.#elementArea.getDataHeads();
              snapshot.dataTails = this.#elementArea.getDataTails();
              return snapshot;
          }

          debugElementAt(x, y) {
              if (!this.#elementArea.isValidPosition(x, y)) {
                  return 'Out of bounds';
              }

              const elementHead = this.#elementArea.getElementHead(x, y);
              const elementTail = this.#elementArea.getElementTail(x, y);
              const json = {
                  type: {
                      'class': ElementHead.getTypeClass(elementHead)
                  },
                  behaviour: ElementHead.getBehaviour(elementHead),
                  special: ElementHead.getSpecial(elementHead),
                  flammableType: ElementHead.getFlammableType(elementHead),
                  flameHeatType: ElementHead.getFlameHeatType(elementHead),
                  burnableType: ElementHead.getBurnableType(elementHead),
                  temperature: ElementHead.getTemperature(elementHead),
                  color: [
                      ElementTail.getColorRed(elementTail),
                      ElementTail.getColorGreen(elementTail),
                      ElementTail.getColorBlue(elementTail)
                  ],
                  blurType: ElementTail.getBlurType(elementTail),
                  burntLevel: ElementTail.getBurntLevel(elementTail)
              };

              let result = JSON.stringify(json)
                      .replaceAll('"', '')
                      .replaceAll(',', ', ')
                      .replaceAll(':', '=');
              return result.substring(1, result.length - 1);  // remove {}
          }
      }

      /**
       * @interface
       *
       * @author Patrik Harag
       * @version 2023-08-27
       */
      class Scene {

          /**
           * @returns [width: number, height: number]
           */
          countSize(prefWidth, prefHeight) {
              throw 'Not implemented';
          }

          /**
           * @param prefWidth {number}
           * @param prefHeight {number}
           * @param defaultElement {Element}
           * @param context {CanvasRenderingContext2D|WebGL2RenderingContext}
           * @param rendererInitializer {RendererInitializer}
           * @returns SandGame
           */
          createSandGame(prefWidth, prefHeight, defaultElement, context, rendererInitializer) {
              throw 'Not implemented';
          }

          /**
           * @param prefWidth
           * @param prefHeight
           * @param defaultElement
           * @returns ElementArea
           */
          createElementArea(prefWidth, prefHeight, defaultElement) {
              throw 'Not implemented';
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-04-29
       */
      class SceneImplHardcoded extends Scene {

          name;
          description;

          #apply;

          constructor({name, description, apply}) {
              super();
              this.#apply = apply;
              this.name = name;
              this.description = description;
          }

          countSize(prefWidth, prefHeight) {
              return [prefWidth, prefHeight];
          }

          createSandGame(prefWidth, prefHeight, defaultElement, context, rendererInitializer) {
              let elementArea = this.createElementArea(prefWidth, prefHeight, defaultElement);
              let sandGame = new SandGame(elementArea, null, defaultElement, context, rendererInitializer);
              this.#apply(sandGame);
              return sandGame;
          }

          createElementArea(prefWidth, prefHeight, defaultElement) {
              return ElementArea.create(prefWidth, prefHeight, defaultElement);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-20
       */
      class Scenes {

          /** @type Scene */
          static SCENE_EMPTY = new SceneImplHardcoded({
              name: 'Empty',
              description: 'Boxed mode',
              apply: function (sandGame) {
                  sandGame.setBoxedMode();
                  // empty
              }
          });

          /** @type Scene */
          static SCENE_LANDSCAPE_1 = new SceneImplHardcoded({
              name: 'Landscape 1',
              description: 'Boxed mode',
              apply: function (sandGame) {
                  sandGame.setBoxedMode();
                  sandGame.blockTemplate()
                      .withMaxHeight(120)
                      .withBlueprint([
                          '          ',
                          '     ww   ',
                          '          ',
                          '   11     ',
                          ' 2 11111 2',
                          ' 222    22',
                          '222    222',
                          '2222222222',
                          '          ',
                      ])
                      .withBrushes({
                          w: Brush.withIntensity(Brushes.WATER, 0.95),
                          1: Brushes.SAND,
                          2: Brushes.SOIL,
                          3: Brushes.STONE
                      })
                      .paint();
              }
          });



          static SCENE_LANDSCAPE_2 = new SceneImplHardcoded({
              name: 'Landscape 2',
              description: 'Boxed mode',
              apply: function (sandGame) {
                  sandGame.setBoxedMode();
                  sandGame.layeredTemplate()
                      .layer([[0, 20], [50, 15], [100, 10], [150, 10], [200, 10], [250, 10], [1250, 10]],
                          true, Brushes.STONE)
                      .layer([[0, 30], [25, 31], [50, 27], [100, 15], [150, 0], [200, 5], [220, 15], [300, 35], [330, 37],
                              [370, 50], [400, 45], [500, 40], [1250, 40]],
                          true, Brushes.SOIL, 30)
                      .layer([[0, 0], [50, 0], [100, 10], [150, 10], [200, 9], [275, 0], [1250, 0]],
                          true, Brushes.SAND, 5)
                      .layer(35, false, Brushes.WATER)
                      .layer(36, false, Brush.withIntensity(Brushes.WATER, 0.33))
                      .grass()
                      .tree(16, 4)
                      .tree(28, 6)
                      .tree(45, 3)
                      .tree(309, 1)
                      .tree(336, 5)
                      .tree(361, 7);
              }
          });

          static SCENE_LANDSCAPE_3 = new SceneImplHardcoded({
              name: 'Solid Map',
              description: 'Just Cheddar Cheese',
              apply: function (sandGame) {
                  sandGame.setBoxedMode();
                  sandGame.blockTemplate()
                      .withMaxHeight(200)
                      .withBlueprint([
                          '3333333333',
                          '3333332233',
                          '3333333223',
                          '3323333333',
                          '3333333333',
                          '3333333w33',
                          '333333  33',
                          '3333333333',
                          '3333333333',
                      ])
                      .withBrushes({
                          w: Brush.withIntensity(Brushes.WATER, 0.95),
                          1: Brushes.SAND,
                          2: Brushes.WALL,
                          3: Brushes.ROCK
                      })
                      .paint();
              }
          });
          static SCENE_LANDSCAPE_4 = new SceneImplHardcoded({
              name: 'Dam Breach',
              description: 'a giant Velveta Dam',
              apply: function (sandGame) {
                  sandGame.setBoxedMode();
                  sandGame.blockTemplate()
                      .withMaxHeight(200)
                      .withBlueprint([
                          '                  4wwwwww',
                          '                  4wwwwww',
                          '                  4wwwwww',
                          '                  4wwwwww',
                          '               1114wwwwww',
                          '222   221   1111114wwwwww',
                          '                  4wwwwww',
                          '2222222222222222224      ',
                          '3333333333333333334111111',
                      ])
                      .withBrushes({
                          w: Brush.withIntensity(Brushes.WATER, 0.95),
                          1: Brushes.SAND,
                          2: Brushes.SOIL,
                          3: Brushes.STONE,
                          4: Brushes.ROCK
                      })
                      .paint();
              }
          });

          static SCENE_LANDSCAPE_5 = new SceneImplHardcoded({
              name: 'Big Pillars',
              description: 'Fallthrough with pillars',
              apply: function (sandGame) {
                  sandGame.setFallThroughMode();
                  sandGame.blockTemplate()
                      .withMaxHeight(500)
                      .withBlueprint([
                          '       666       244              555           4 5   ',
                          '66  666666        44              555           5555  ',
                          '       666      44441             555www5       6  5  ',
                          '       6w6        44              555   5       4     ',
                          '       6          44444           5555555       5     ',
                          '       6 6      w 44              555       55  6     ',
                          '       666     11144              555         5 4     ',
                          '       666        44              555        5555     ',
                          '       666   4    44         1 2 3555     555   6     ',
                          '       666    4   44              555           4     ',
                          '6666666666     4  44        5     555           5     ',
                          '       666      4 44         55555555           6     ',
                          '       666       444              555           4     ',
                          '       666        44              555           5     ',
                          '       666        44              555           6     ',
                      ])
                      .withBrushes({
                          w: Brush.withIntensity(Brushes.WATER, 0.95),
                          1: Brushes.SAND,
                          2: Brushes.SOIL,
                          3: Brushes.STONE,
                          4: Brushes.ROCK,
                          5: Brushes.TREE_WOOD,
                          6: Brushes.WALL
                      })
                      .paint();
              }
          });
          /** @type Scene */
          static SCENE_FALLTHROUGH = new SceneImplHardcoded({
              name: 'Fall-through',
              description: 'Fall-through mode',
              apply: function (sandGame) {
                  sandGame.setFallThroughMode();
                  const graphics = sandGame.graphics();
                  const xo = Math.trunc((sandGame.getWidth() - 150) / 2 - 15);
                  const yo = Math.trunc((sandGame.getHeight() - 150) / 2);
                  graphics.drawRectangle(40 + xo, 20 + yo, 60 + xo, 40 + yo, Brushes.WATER);
                  graphics.drawLine(30 + xo, 30 + yo, 30 + xo, 50 + yo, 5, Brushes.WALL, true);
                  graphics.drawLine(30 + xo, 50 + yo, 70 + xo, 80 + yo, 5, Brushes.WALL, true);
                  graphics.drawLine(65 + xo, 90 + yo, 100 + xo, 100 + yo, 5, Brushes.WALL, true);
                  graphics.drawLine(55 + xo, 140 + yo, 125 + xo, 140 + yo, 10, Brushes.WALL, false);
                  graphics.drawLine(55 + xo, 130 + yo, 55 + xo, 140 + yo, 10, Brushes.WALL, false);
                  graphics.drawLine(70 + xo, 125 + yo, 90 + xo, 125 + yo, 10, Brushes.SAND, false);
                  graphics.draw(120 + xo, 130 + yo, Brushes.SAND);
                  graphics.drawLine(150 + xo, 10 + yo, 80 + xo, 35 + yo, 5, Brushes.WALL, true);
                  graphics.drawLine(80 + xo, 35 + yo, 80 + xo, 15 + yo, 5, Brushes.WALL, true);
              }
          });

          /** @type Scene */
          static SCENE_PLATFORM = new SceneImplHardcoded({
              name: 'Platform',
              description: 'Erasing mode',
              apply: function (sandGame) {
                  sandGame.setErasingMode();
                  sandGame.blockTemplate()
                      .withBlueprint([
                          '          ',
                          '          ',
                          '        w ',
                          '        w ',
                          '          ',
                          '          ',
                          ' ssssssss ',
                          '          ',
                          '          ',
                      ])
                      .withBrushes({
                          w: Brushes.SAND,
                          s: Brushes.WALL
                      })
                      .paint();
              }
          });

          static SCENES = {
              empty: Scenes.SCENE_EMPTY,
              landscape_1: Scenes.SCENE_LANDSCAPE_1,
              landscape_2: Scenes.SCENE_LANDSCAPE_2,
              landscape_3: Scenes.SCENE_LANDSCAPE_3,
              landscape_4: Scenes.SCENE_LANDSCAPE_4,
              landscape_5: Scenes.SCENE_LANDSCAPE_5,
              fallthrough: Scenes.SCENE_FALLTHROUGH,
              platform: Scenes.SCENE_PLATFORM
          };
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-04-29
       */
      class SceneImplTmpResize extends Scene {

          /**
           * @type SandGame
           */
          #sandGame;

          constructor(sandGame) {
              super();
              this.#sandGame = sandGame;
          }

          countSize(prefWidth, prefHeight) {
              return [prefWidth, prefHeight];
          }

          createSandGame(prefWidth, prefHeight, defaultElement, context, rendererInitializer) {
              let elementArea = this.createElementArea(prefWidth, prefHeight, defaultElement);
              let sandGame = new SandGame(elementArea, null, defaultElement, context, rendererInitializer);
              this.#sandGame.copyStateTo(sandGame);
              return sandGame;
          }

          createElementArea(prefWidth, prefHeight, defaultElement) {
              return ElementArea.create(prefWidth, prefHeight, defaultElement);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-07-23
       */
      class ServiceToolManager {

          #primaryTool = Tools.byCodeName('sand');
          #secondaryTool = Tools.byCodeName('air');
          #tertiaryTool = Tools.byCodeName('meteor');

          /** @type function(Tool)[] */
          #onPrimaryToolChanged = [];

          /**
           *
           * @param tool {Tool}
           * @returns void
           */
          setPrimaryTool(tool) {
              this.#primaryTool = tool;
              for (let handler of this.#onPrimaryToolChanged) {
                  handler(tool);
              }
          }

          /**
           *
           * @param tool {Tool}
           * @returns void
           */
          setSecondaryTool(tool) {
              this.#secondaryTool = tool;
          }

          /**
           *
           * @param tool {Tool}
           * @returns void
           */
          setTertiaryTool(tool) {
              this.#tertiaryTool = tool;
          }

          /**
           * @returns {Tool}
           */
          getPrimaryTool() {
              return this.#primaryTool;
          }

          /**
           * @returns {Tool}
           */
          getSecondaryTool() {
              return this.#secondaryTool;
          }

          /**
           * @returns {Tool}
           */
          getTertiaryTool() {
              return this.#tertiaryTool;
          }

          /**
           *
           * @param handler {function(Tool)}
           */
          addOnPrimaryToolChanged(handler) {
              this.#onPrimaryToolChanged.push(handler);
          }

          createRevertAction() {
              const oldPrimary = this.getPrimaryTool();
              const oldSecondary = this.getSecondaryTool();
              const oldTertiary = this.getTertiaryTool();
              return () => {
                  this.setPrimaryTool(oldPrimary);
                  this.setSecondaryTool(oldSecondary);
                  this.setTertiaryTool(oldTertiary);
              };
          }
      }

      /**
       *
       * @version 2023-04-28
       * @author Patrik Harag
       */
      class DomBuilder {

          /**
           *
           * @param html {string}
           * @return {jQuery<HTMLElement>}
           */
          static create(html) {
              return $(html);
          }

          /**
           *
           * @param name {string}
           * @param attributes {object|null}
           * @param content {null|string|jQuery<HTMLElement>|jQuery<HTMLElement>[]}
           * @return {jQuery<HTMLElement>}
           */
          static element(name, attributes = null, content = null) {
              let element = $(`<${name}>`);
              if (attributes !== null) {
                  for (let key in attributes) {
                      element.attr(key, attributes[key]);
                  }
              }
              if (content === null) ; else if (typeof content === 'string') {
                  element.text(content);
              } else {
                  element.append(content);
              }
              return element;
          }

          /**
           *
           * @param attributes {object|null}
           * @param content {null|jQuery<HTMLElement>|jQuery<HTMLElement>[]}
           * @return {jQuery<HTMLElement>}
           */
          static div(attributes = null, content = null) {
              return DomBuilder.element('div', attributes, content);
          }

          /**
           *
           * @param attributes {object|null}
           * @param content {null|string|jQuery<HTMLElement>|jQuery<HTMLElement>[]}
           * @return {jQuery<HTMLElement>}
           */
          static par(attributes = null, content = null) {
              return DomBuilder.element('p', attributes, content);
          }

          /**
           *
           * @param text {string|null}
           * @param attributes {object|null}
           * @return {jQuery<HTMLElement>}
           */
          static span(text = null, attributes = null) {
              return DomBuilder.element('span', attributes, text);
          }

          /**
           *
           * @param text {string}
           * @param attributes {object|null}
           * @param handler {function(e)}
           * @return {jQuery<HTMLElement>}
           */
          static link(text, attributes = null, handler = null) {
              let link = DomBuilder.element('a', attributes, text);
              if (handler !== null) {
                  link.attr('href', 'javascript:void(0)');
                  link.on("click", handler);
              }
              return link;
          }

          /**
           *
           * @param label {string|jQuery<HTMLElement>|jQuery<HTMLElement>[]}
           * @param attributes {object|null}
           * @param handler {function(e)}
           * @return {jQuery<HTMLElement>}
           */
          static button(label, attributes = null, handler = null) {
              if (attributes === null) {
                  attributes = {};
              }
              attributes['type'] = 'button';

              let button = DomBuilder.element('button', attributes, label);
              if (handler !== null) {
                  button.on("click", handler);
              }
              return button;
          }
      }

      /**
       *
       * @version 2022-10-02
       * @author Patrik Harag
       */
      DomBuilder.Bootstrap = class {

          /**
           *
           * @param headerContent {string|jQuery<HTMLElement>|jQuery<HTMLElement>[]}
           * @param bodyContent {string|jQuery<HTMLElement>|jQuery<HTMLElement>[]}
           * @param attributes {object|null}
           * @return {jQuery<HTMLElement>}
           */
          static card(headerContent, bodyContent, attributes = null) {
              if (attributes === null) {
                  attributes = {};
              }
              if (attributes.class === undefined) {
                  attributes.class = 'card';
              }

              let card = DomBuilder.div(attributes);

              if (headerContent) {
                  card.append(DomBuilder.div({ class: 'card-header' }, headerContent));
              }

              card.append(DomBuilder.div({ class: 'card-body' }, bodyContent));
              return card;
          }

          /**
           *
           * @param title {string}
           * @param collapsed {boolean}
           * @param bodyContent {string|jQuery<HTMLElement>|jQuery<HTMLElement>[]}
           * @return {jQuery<HTMLElement>}
           */
          static cardCollapsable(title, collapsed, bodyContent) {
              let id = 'collapsable_' + Math.floor(Math.random() * 999_999_999);

              return DomBuilder.div({ class: 'card' }, [
                  DomBuilder.div({ class: 'card-header' }, [
                      DomBuilder.element('a', { class: 'card-link', 'data-toggle': 'collapse', href: '#' + id}, title)
                  ]),
                  DomBuilder.div({ id: id, class: (collapsed ? 'collapse' : 'collapse show') }, [
                      DomBuilder.div({ class: 'card-body' }, bodyContent)
                  ])
              ]);
          }

          /**
           *
           * @param node {jQuery<HTMLElement>}
           * @param content {string|jQuery<HTMLElement>}
           * @return {jQuery<HTMLElement>}
           */
          static initTooltip(content, node) {
              node.tooltip('dispose');  // remove old one if present

              node.attr('data-toggle', 'tooltip');
              node.attr('data-placement', 'top');
              if (typeof content === 'object') {
                  node.attr('data-html', 'true');
                  node.attr('title', content.html());
              } else {
                  node.attr('title', content);
              }
              node.tooltip();
              return node;
          }

          /**
           *
           * @param text {string}
           * @param checked {boolean}
           * @param handler {function(boolean)}
           * @return {jQuery<HTMLElement>}
           */
          static switchButton(text, checked, handler = null) {
              let id = 'switch-button_' + Math.floor(Math.random() * 999_999_999);

              let switchInput = DomBuilder.element('input', {
                  type: 'checkbox',
                  id: id,
                  class: 'custom-control-input',
                  style: 'width: min-content;'
              });
              if (checked) {
                  switchInput.attr('checked', 'true');
              }

              let control = DomBuilder.div({ class: 'custom-control custom-switch' }, [
                  switchInput,
                  DomBuilder.element('label', { class: 'custom-control-label', for: id }, text)
              ]);

              if (handler !== null) {
                  switchInput.on('click', () => {
                      let checked = switchInput.prop('checked');

                      handler(checked);
                  });
              }
              return control;
          }
      };

      /**
       *
       * @version 2022-03-18
       * @author Patrik Harag
       */
      DomBuilder.BootstrapTable = class {

          #tableBody = DomBuilder.element('tbody');

          addRow(row) {
              this.#tableBody.append(row);
          }

          createNode() {
              return DomBuilder.div({ class: 'table-responsive' })
                  .append(DomBuilder.element('table', { class: 'table table-striped' })
                      .append(this.#tableBody))
          }
      };

      /**
       *
       * @version 2023-02-20
       * @author Patrik Harag
       */
      DomBuilder.BootstrapDialog = class {

          // will be removed after close
          #persistent = false;

          #headerNode = null;
          #bodyNode = null;
          #footerNodeChildren = [];

          #dialog = null;


          setPersistent(persistent) {
              this.#persistent = persistent;
          }

          setHeaderContent(headerNode) {
              if (typeof headerNode === 'string') {
                  this.#headerNode = DomBuilder.element('strong', null, headerNode);
              } else {
                  this.#headerNode = headerNode;
              }
          }

          setBodyContent(bodyNode) {
              this.#bodyNode = bodyNode;
          }

          addCloseButton(buttonText) {
              let button = $(`<button type="button" class="btn btn-secondary" data-dismiss="modal"></button>`)
                  .text(buttonText);
              this.#footerNodeChildren.push(button);
          }

          addSubmitButton(buttonText, handler) {
              let button = $(`<button type="button" class="btn btn-primary" data-dismiss="modal"></button>`)
                  .text(buttonText)
                  .on("click", handler);

              this.#footerNodeChildren.push(button);
          }

          addButton(button) {
              this.#footerNodeChildren.push(button);
          }

          show(dialogAnchor) {
              if (this.#dialog === null) {
                  this.#dialog = $(`<div class="modal fade" tabindex="-1" role="dialog" aria-hidden="true"></div>`)
                      .append($(`<div class="modal-dialog modal-dialog-centered"></div>`)
                          .append($(`<div class="modal-content"></div>`)
                              .append($(`<div class="modal-header"></div>`).append(this.#headerNode))
                              .append($(`<div class="modal-body"></div>`).append(this.#bodyNode))
                              .append($(`<div class="modal-footer"></div>`).append(this.#footerNodeChildren))
                          )
                      );

                  // add into DOM
                  dialogAnchor.append(this.#dialog);
              }

              if (!this.#persistent) {
                  // remove from DOM after hide
                  this.#dialog.on('hidden.bs.modal', () => {
                      this.#dialog.remove();
                  });
              }

              this.#dialog.modal('show');
          }

          hide() {
              if (this.#dialog !== null) {
                  this.#dialog.modal('hide');
              }
          }
      };

      /**
       *
       * @version 2023-10-15
       * @author Patrik Harag
       */
      DomBuilder.BootstrapToast = class {

          #headerNode = null;
          #bodyNode = null;

          #toast = null;

          #dataDelay = 20000;  // ms

          setHeaderContent(headerNode) {
              if (typeof headerNode === 'string') {
                  headerNode = DomBuilder.element('strong', headerNode);
              }
              this.#headerNode = DomBuilder.span(headerNode, { class: 'mr-auto' });
          }

          setBodyContent(bodyNode) {
              this.#bodyNode = bodyNode;
          }

          setDelay(milliseconds) {
              this.#dataDelay = milliseconds;
          }

          show(dialogAnchor) {
              const wrapper = $(`<div class="position-fixed bottom-0 right-0 p-3" style="z-index: 5; right: 0; bottom: 0;"></div>`)
                  .append(this.#toast = $(`<div class="toast hide" role="alert" aria-live="assertive" aria-atomic="true" data-delay="${this.#dataDelay}">`)
                      .append($(`<div class="toast-header"></div>`)
                          .append(this.#headerNode)
                          .append($(`<button type="button" class="ml-2 mb-1 close" data-dismiss="toast" aria-label="Close"></button>`)
                              .append($(`<span aria-hidden="true">&times;</span>`))
                          )
                      )
                      .append($(`<div class="toast-body"></div>`)
                          .append(this.#bodyNode)
                      )
                  );

              // add into DOM
              dialogAnchor.append(wrapper);

              // remove from DOM after hide
              this.#toast.on('hidden.bs.toast', () => {
                  wrapper.remove();
              });

              this.#toast.toast('show');
          }

          hide() {
              if (this.#toast !== null) {
                  this.#toast.toast('hide');
              }
          }
      };

      /**
       *
       * @version 2022-09-24
       * @author Patrik Harag
       */
      DomBuilder.BootstrapSimpleForm = class {

          #formFields = [];
          #submitButton = null;

          addTextArea(label, key, initialValue = '', rows = 8) {
              let input = DomBuilder.element('textarea', { class: 'form-control', rows: rows }, initialValue);
              this.#formFields.push({
                  key: key,
                  label: label,
                  input: input
              });
              return input;
          }

          addInput(label, key, initialValue = '') {
              let input = DomBuilder.element('input', { class: 'form-control' });
              if (initialValue) {
                  input.val(initialValue);
              }
              this.#formFields.push({
                  key: key,
                  label: label,
                  input: input
              });
              return input;
          }

          addSubmitButton(text, handler) {
              this.#submitButton = DomBuilder.button(text, { class: 'btn btn-primary' }, e => {
                  handler(this.getData());
              });
          }

          createNode() {
              let form = DomBuilder.element('form', { action: 'javascript:void(0);' });

              for (let formField of this.#formFields) {
                  form.append(DomBuilder.div({ class: 'form-group' }, [
                      DomBuilder.element('label', null, formField.label),
                      formField.input
                  ]));
              }

              if (this.#submitButton) {
                  form.append(this.#submitButton);
              }

              return form;
          }

          getData() {
              let data = {};
              for (let formField of this.#formFields) {
                  data[formField.key] = formField.input.val();
              }
              return data;
          }
      };

      /**
       *
       * @author Patrik Harag
       * @version 2023-04-28
       */
      class SceneImplSnapshot extends Scene {

          /**
           * @type Snapshot
           */
          #snapshot;

          /**
           *
           * @param snapshot {Snapshot}
           */
          constructor(snapshot) {
              super();
              this.#snapshot = snapshot;
          }

          countSize(prefWidth, prefHeight) {
              return [this.#snapshot.metadata.width, this.#snapshot.metadata.height];
          }

          createSandGame(prefWidth, prefHeight, defaultElement, context, rendererInitializer) {
              let elementArea = this.createElementArea(prefWidth, prefHeight, defaultElement);
              return new SandGame(elementArea, this.#snapshot.metadata, defaultElement, context, rendererInitializer);
          }

          createElementArea(prefWidth, prefHeight, defaultElement) {
              return ElementArea.from(
                      this.#snapshot.metadata.width,
                      this.#snapshot.metadata.height,
                      this.#snapshot.dataHeads,
                      this.#snapshot.dataTails);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-05-16
       */
      class SceneImplTemplate extends Scene {

          /**
           * @type ElementArea
           */
          #elementArea;

          /**
           *
           * @param elementArea {ElementArea}
           */
          constructor(elementArea) {
              super();
              this.#elementArea = elementArea;
          }

          countSize(prefWidth, prefHeight) {
              return [this.#elementArea.getWidth(), this.#elementArea.getHeight()];
          }

          createSandGame(prefWidth, prefHeight, defaultElement, context, rendererInitializer) {
              let elementArea = this.createElementArea(prefWidth, prefHeight, defaultElement);
              return new SandGame(elementArea, null, defaultElement, context, rendererInitializer);
          }

          createElementArea(prefWidth, prefHeight, defaultElement) {
              return ElementArea.from(
                      this.#elementArea.getWidth(),
                      this.#elementArea.getHeight(),
                      this.#elementArea.getDataHeads(),
                      this.#elementArea.getDataTails());
          }
      }

      /**
       * Create flipped scene using object composition.
       *
       * @author Patrik Harag
       * @version 2023-07-23
       */
      class SceneImplModFlip extends Scene {

          /**
           * @type Scene
           */
          #original;

          #flipHorizontally;
          #flipVertically;

          constructor(scene, flipHorizontally, flipVertically) {
              super();
              this.#original = scene;
              this.#flipHorizontally = flipHorizontally;
              this.#flipVertically = flipVertically;
          }

          countSize(prefWidth, prefHeight) {
              this.#original.countSize(prefWidth, prefHeight);
          }

          createSandGame(prefWidth, prefHeight, defaultElement, context, rendererInitializer) {
              let elementArea = this.createElementArea(prefWidth, prefHeight, defaultElement);
              return new SandGame(elementArea, null, defaultElement, context, rendererInitializer);
              // TODO: sceneMetadata not set
          }

          createElementArea(prefWidth, prefHeight, defaultElement) {
              const elementArea = this.#original.createElementArea(prefWidth, prefHeight, defaultElement);

              const width = elementArea.getWidth();
              const height = elementArea.getHeight();

              if (this.#flipHorizontally) {
                  for (let y = 0; y < height; y++) {
                      for (let x = 0; x < Math.trunc(width / 2); x++) {
                          elementArea.swap(x, y, width - 1 - x, y);
                      }
                  }
              }

              if (this.#flipVertically) {
                  for (let y = 0; y < Math.trunc(height / 2); y++) {
                      for (let x = 0; x < width; x++) {
                          elementArea.swap(x, y, x, height - 1 - y);
                      }
                  }
              }

              return elementArea;
          }
      }

      // DEFLATE is a complex format; to read this code, you should probably check the RFC first:

      // aliases for shorter compressed code (most minifers don't do this)
      var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
      // fixed length extra bits
      var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
      // fixed distance extra bits
      // see fleb note
      var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
      // code length index map
      var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      // get base, reverse index map from extra bits
      var freb = function (eb, start) {
          var b = new u16(31);
          for (var i = 0; i < 31; ++i) {
              b[i] = start += 1 << eb[i - 1];
          }
          // numbers here are at max 18 bits
          var r = new u32(b[30]);
          for (var i = 1; i < 30; ++i) {
              for (var j = b[i]; j < b[i + 1]; ++j) {
                  r[j] = ((j - b[i]) << 5) | i;
              }
          }
          return [b, r];
      };
      var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
      // we can ignore the fact that the other numbers are wrong; they never happen anyway
      fl[28] = 258, revfl[258] = 28;
      var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
      // map of value to reverse (assuming 16 bits)
      var rev = new u16(32768);
      for (var i = 0; i < 32768; ++i) {
          // reverse table algorithm from SO
          var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);
          x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);
          x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);
          rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;
      }
      // create huffman tree from u8 "map": index -> code length for code index
      // mb (max bits) must be at most 15
      // TODO: optimize/split up?
      var hMap = (function (cd, mb, r) {
          var s = cd.length;
          // index
          var i = 0;
          // u16 "map": index -> # of codes with bit length = index
          var l = new u16(mb);
          // length of cd must be 288 (total # of codes)
          for (; i < s; ++i) {
              if (cd[i])
                  ++l[cd[i] - 1];
          }
          // u16 "map": index -> minimum code for bit length = index
          var le = new u16(mb);
          for (i = 0; i < mb; ++i) {
              le[i] = (le[i - 1] + l[i - 1]) << 1;
          }
          var co;
          if (r) {
              // u16 "map": index -> number of actual bits, symbol for code
              co = new u16(1 << mb);
              // bits to remove for reverser
              var rvb = 15 - mb;
              for (i = 0; i < s; ++i) {
                  // ignore 0 lengths
                  if (cd[i]) {
                      // num encoding both symbol and bits read
                      var sv = (i << 4) | cd[i];
                      // free bits
                      var r_1 = mb - cd[i];
                      // start value
                      var v = le[cd[i] - 1]++ << r_1;
                      // m is end value
                      for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                          // every 16 bit value starting with the code yields the same result
                          co[rev[v] >>> rvb] = sv;
                      }
                  }
              }
          }
          else {
              co = new u16(s);
              for (i = 0; i < s; ++i) {
                  if (cd[i]) {
                      co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);
                  }
              }
          }
          return co;
      });
      // fixed length tree
      var flt = new u8(288);
      for (var i = 0; i < 144; ++i)
          flt[i] = 8;
      for (var i = 144; i < 256; ++i)
          flt[i] = 9;
      for (var i = 256; i < 280; ++i)
          flt[i] = 7;
      for (var i = 280; i < 288; ++i)
          flt[i] = 8;
      // fixed distance tree
      var fdt = new u8(32);
      for (var i = 0; i < 32; ++i)
          fdt[i] = 5;
      // fixed length map
      var flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);
      // fixed distance map
      var fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
      // find max of array
      var max = function (a) {
          var m = a[0];
          for (var i = 1; i < a.length; ++i) {
              if (a[i] > m)
                  m = a[i];
          }
          return m;
      };
      // read d, starting at bit p and mask with m
      var bits = function (d, p, m) {
          var o = (p / 8) | 0;
          return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
      };
      // read d, starting at bit p continuing for at least 16 bits
      var bits16 = function (d, p) {
          var o = (p / 8) | 0;
          return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
      };
      // get end of byte
      var shft = function (p) { return ((p + 7) / 8) | 0; };
      // typed array slice - allows garbage collector to free original reference,
      // while being more compatible than .slice
      var slc = function (v, s, e) {
          if (s == null || s < 0)
              s = 0;
          if (e == null || e > v.length)
              e = v.length;
          // can't use .constructor in case user-supplied
          var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);
          n.set(v.subarray(s, e));
          return n;
      };
      // error codes
      var ec = [
          'unexpected EOF',
          'invalid block type',
          'invalid length/literal',
          'invalid distance',
          'stream finished',
          'no stream handler',
          ,
          'no callback',
          'invalid UTF-8 data',
          'extra field too long',
          'date not in range 1980-2099',
          'filename too long',
          'stream finishing',
          'invalid zip data'
          // determined by unknown compression method
      ];
      var err = function (ind, msg, nt) {
          var e = new Error(msg || ec[ind]);
          e.code = ind;
          if (Error.captureStackTrace)
              Error.captureStackTrace(e, err);
          if (!nt)
              throw e;
          return e;
      };
      // expands raw DEFLATE data
      var inflt = function (dat, buf, st) {
          // source length
          var sl = dat.length;
          if (!sl || (st && st.f && !st.l))
              return buf || new u8(0);
          // have to estimate size
          var noBuf = !buf || st;
          // no state
          var noSt = !st || st.i;
          if (!st)
              st = {};
          // Assumes roughly 33% compression ratio average
          if (!buf)
              buf = new u8(sl * 3);
          // ensure buffer can fit at least l elements
          var cbuf = function (l) {
              var bl = buf.length;
              // need to increase size to fit
              if (l > bl) {
                  // Double or set to necessary, whichever is greater
                  var nbuf = new u8(Math.max(bl * 2, l));
                  nbuf.set(buf);
                  buf = nbuf;
              }
          };
          //  last chunk         bitpos           bytes
          var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
          // total bits
          var tbts = sl * 8;
          do {
              if (!lm) {
                  // BFINAL - this is only 1 when last chunk is next
                  final = bits(dat, pos, 1);
                  // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
                  var type = bits(dat, pos + 1, 3);
                  pos += 3;
                  if (!type) {
                      // go to end of byte boundary
                      var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                      if (t > sl) {
                          if (noSt)
                              err(0);
                          break;
                      }
                      // ensure size
                      if (noBuf)
                          cbuf(bt + l);
                      // Copy over uncompressed data
                      buf.set(dat.subarray(s, t), bt);
                      // Get new bitpos, update byte count
                      st.b = bt += l, st.p = pos = t * 8, st.f = final;
                      continue;
                  }
                  else if (type == 1)
                      lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
                  else if (type == 2) {
                      //  literal                            lengths
                      var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                      var tl = hLit + bits(dat, pos + 5, 31) + 1;
                      pos += 14;
                      // length+distance tree
                      var ldt = new u8(tl);
                      // code length tree
                      var clt = new u8(19);
                      for (var i = 0; i < hcLen; ++i) {
                          // use index map to get real code
                          clt[clim[i]] = bits(dat, pos + i * 3, 7);
                      }
                      pos += hcLen * 3;
                      // code lengths bits
                      var clb = max(clt), clbmsk = (1 << clb) - 1;
                      // code lengths map
                      var clm = hMap(clt, clb, 1);
                      for (var i = 0; i < tl;) {
                          var r = clm[bits(dat, pos, clbmsk)];
                          // bits read
                          pos += r & 15;
                          // symbol
                          var s = r >>> 4;
                          // code length to copy
                          if (s < 16) {
                              ldt[i++] = s;
                          }
                          else {
                              //  copy   count
                              var c = 0, n = 0;
                              if (s == 16)
                                  n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                              else if (s == 17)
                                  n = 3 + bits(dat, pos, 7), pos += 3;
                              else if (s == 18)
                                  n = 11 + bits(dat, pos, 127), pos += 7;
                              while (n--)
                                  ldt[i++] = c;
                          }
                      }
                      //    length tree                 distance tree
                      var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                      // max length bits
                      lbt = max(lt);
                      // max dist bits
                      dbt = max(dt);
                      lm = hMap(lt, lbt, 1);
                      dm = hMap(dt, dbt, 1);
                  }
                  else
                      err(1);
                  if (pos > tbts) {
                      if (noSt)
                          err(0);
                      break;
                  }
              }
              // Make sure the buffer can hold this + the largest possible addition
              // Maximum chunk size (practically, theoretically infinite) is 2^17;
              if (noBuf)
                  cbuf(bt + 131072);
              var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
              var lpos = pos;
              for (;; lpos = pos) {
                  // bits read, code
                  var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
                  pos += c & 15;
                  if (pos > tbts) {
                      if (noSt)
                          err(0);
                      break;
                  }
                  if (!c)
                      err(2);
                  if (sym < 256)
                      buf[bt++] = sym;
                  else if (sym == 256) {
                      lpos = pos, lm = null;
                      break;
                  }
                  else {
                      var add = sym - 254;
                      // no extra bits needed if less
                      if (sym > 264) {
                          // index
                          var i = sym - 257, b = fleb[i];
                          add = bits(dat, pos, (1 << b) - 1) + fl[i];
                          pos += b;
                      }
                      // dist
                      var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                      if (!d)
                          err(3);
                      pos += d & 15;
                      var dt = fd[dsym];
                      if (dsym > 3) {
                          var b = fdeb[dsym];
                          dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;
                      }
                      if (pos > tbts) {
                          if (noSt)
                              err(0);
                          break;
                      }
                      if (noBuf)
                          cbuf(bt + 131072);
                      var end = bt + add;
                      for (; bt < end; bt += 4) {
                          buf[bt] = buf[bt - dt];
                          buf[bt + 1] = buf[bt + 1 - dt];
                          buf[bt + 2] = buf[bt + 2 - dt];
                          buf[bt + 3] = buf[bt + 3 - dt];
                      }
                      bt = end;
                  }
              }
              st.l = lm, st.p = lpos, st.b = bt, st.f = final;
              if (lm)
                  final = 1, st.m = lbt, st.d = dm, st.n = dbt;
          } while (!final);
          return bt == buf.length ? buf : slc(buf, 0, bt);
      };
      // starting at p, write the minimum number of bits that can hold v to d
      var wbits = function (d, p, v) {
          v <<= p & 7;
          var o = (p / 8) | 0;
          d[o] |= v;
          d[o + 1] |= v >>> 8;
      };
      // starting at p, write the minimum number of bits (>8) that can hold v to d
      var wbits16 = function (d, p, v) {
          v <<= p & 7;
          var o = (p / 8) | 0;
          d[o] |= v;
          d[o + 1] |= v >>> 8;
          d[o + 2] |= v >>> 16;
      };
      // creates code lengths from a frequency table
      var hTree = function (d, mb) {
          // Need extra info to make a tree
          var t = [];
          for (var i = 0; i < d.length; ++i) {
              if (d[i])
                  t.push({ s: i, f: d[i] });
          }
          var s = t.length;
          var t2 = t.slice();
          if (!s)
              return [et, 0];
          if (s == 1) {
              var v = new u8(t[0].s + 1);
              v[t[0].s] = 1;
              return [v, 1];
          }
          t.sort(function (a, b) { return a.f - b.f; });
          // after i2 reaches last ind, will be stopped
          // freq must be greater than largest possible number of symbols
          t.push({ s: -1, f: 25001 });
          var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
          t[0] = { s: -1, f: l.f + r.f, l: l, r: r };
          // efficient algorithm from UZIP.js
          // i0 is lookbehind, i2 is lookahead - after processing two low-freq
          // symbols that combined have high freq, will start processing i2 (high-freq,
          // non-composite) symbols instead
          // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
          while (i1 != s - 1) {
              l = t[t[i0].f < t[i2].f ? i0++ : i2++];
              r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
              t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };
          }
          var maxSym = t2[0].s;
          for (var i = 1; i < s; ++i) {
              if (t2[i].s > maxSym)
                  maxSym = t2[i].s;
          }
          // code lengths
          var tr = new u16(maxSym + 1);
          // max bits in tree
          var mbt = ln(t[i1 - 1], tr, 0);
          if (mbt > mb) {
              // more algorithms from UZIP.js
              // TODO: find out how this code works (debt)
              //  ind    debt
              var i = 0, dt = 0;
              //    left            cost
              var lft = mbt - mb, cst = 1 << lft;
              t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });
              for (; i < s; ++i) {
                  var i2_1 = t2[i].s;
                  if (tr[i2_1] > mb) {
                      dt += cst - (1 << (mbt - tr[i2_1]));
                      tr[i2_1] = mb;
                  }
                  else
                      break;
              }
              dt >>>= lft;
              while (dt > 0) {
                  var i2_2 = t2[i].s;
                  if (tr[i2_2] < mb)
                      dt -= 1 << (mb - tr[i2_2]++ - 1);
                  else
                      ++i;
              }
              for (; i >= 0 && dt; --i) {
                  var i2_3 = t2[i].s;
                  if (tr[i2_3] == mb) {
                      --tr[i2_3];
                      ++dt;
                  }
              }
              mbt = mb;
          }
          return [new u8(tr), mbt];
      };
      // get the max length and assign length codes
      var ln = function (n, l, d) {
          return n.s == -1
              ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))
              : (l[n.s] = d);
      };
      // length codes generation
      var lc = function (c) {
          var s = c.length;
          // Note that the semicolon was intentional
          while (s && !c[--s])
              ;
          var cl = new u16(++s);
          //  ind      num         streak
          var cli = 0, cln = c[0], cls = 1;
          var w = function (v) { cl[cli++] = v; };
          for (var i = 1; i <= s; ++i) {
              if (c[i] == cln && i != s)
                  ++cls;
              else {
                  if (!cln && cls > 2) {
                      for (; cls > 138; cls -= 138)
                          w(32754);
                      if (cls > 2) {
                          w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);
                          cls = 0;
                      }
                  }
                  else if (cls > 3) {
                      w(cln), --cls;
                      for (; cls > 6; cls -= 6)
                          w(8304);
                      if (cls > 2)
                          w(((cls - 3) << 5) | 8208), cls = 0;
                  }
                  while (cls--)
                      w(cln);
                  cls = 1;
                  cln = c[i];
              }
          }
          return [cl.subarray(0, cli), s];
      };
      // calculate the length of output from tree, code lengths
      var clen = function (cf, cl) {
          var l = 0;
          for (var i = 0; i < cl.length; ++i)
              l += cf[i] * cl[i];
          return l;
      };
      // writes a fixed block
      // returns the new bit pos
      var wfblk = function (out, pos, dat) {
          // no need to write 00 as type: TypedArray defaults to 0
          var s = dat.length;
          var o = shft(pos + 2);
          out[o] = s & 255;
          out[o + 1] = s >>> 8;
          out[o + 2] = out[o] ^ 255;
          out[o + 3] = out[o + 1] ^ 255;
          for (var i = 0; i < s; ++i)
              out[o + i + 4] = dat[i];
          return (o + 4 + s) * 8;
      };
      // writes a block
      var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
          wbits(out, p++, final);
          ++lf[256];
          var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];
          var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];
          var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
          var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
          var lcfreq = new u16(19);
          for (var i = 0; i < lclt.length; ++i)
              lcfreq[lclt[i] & 31]++;
          for (var i = 0; i < lcdt.length; ++i)
              lcfreq[lcdt[i] & 31]++;
          var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
          var nlcc = 19;
          for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
              ;
          var flen = (bl + 5) << 3;
          var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
          var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
          if (flen <= ftlen && flen <= dtlen)
              return wfblk(out, p, dat.subarray(bs, bs + bl));
          var lm, ll, dm, dl;
          wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
          if (dtlen < ftlen) {
              lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
              var llm = hMap(lct, mlcb, 0);
              wbits(out, p, nlc - 257);
              wbits(out, p + 5, ndc - 1);
              wbits(out, p + 10, nlcc - 4);
              p += 14;
              for (var i = 0; i < nlcc; ++i)
                  wbits(out, p + 3 * i, lct[clim[i]]);
              p += 3 * nlcc;
              var lcts = [lclt, lcdt];
              for (var it = 0; it < 2; ++it) {
                  var clct = lcts[it];
                  for (var i = 0; i < clct.length; ++i) {
                      var len = clct[i] & 31;
                      wbits(out, p, llm[len]), p += lct[len];
                      if (len > 15)
                          wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;
                  }
              }
          }
          else {
              lm = flm, ll = flt, dm = fdm, dl = fdt;
          }
          for (var i = 0; i < li; ++i) {
              if (syms[i] > 255) {
                  var len = (syms[i] >>> 18) & 31;
                  wbits16(out, p, lm[len + 257]), p += ll[len + 257];
                  if (len > 7)
                      wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];
                  var dst = syms[i] & 31;
                  wbits16(out, p, dm[dst]), p += dl[dst];
                  if (dst > 3)
                      wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];
              }
              else {
                  wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
              }
          }
          wbits16(out, p, lm[256]);
          return p + ll[256];
      };
      // deflate options (nice << 13) | chain
      var deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
      // empty
      var et = /*#__PURE__*/ new u8(0);
      // compresses data into a raw DEFLATE buffer
      var dflt = function (dat, lvl, plvl, pre, post, lst) {
          var s = dat.length;
          var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
          // writing to this writes to the output buffer
          var w = o.subarray(pre, o.length - post);
          var pos = 0;
          if (!lvl || s < 8) {
              for (var i = 0; i <= s; i += 65535) {
                  // end
                  var e = i + 65535;
                  if (e >= s) {
                      // write final block
                      w[pos >> 3] = lst;
                  }
                  pos = wfblk(w, pos + 1, dat.subarray(i, e));
              }
          }
          else {
              var opt = deo[lvl - 1];
              var n = opt >>> 13, c = opt & 8191;
              var msk_1 = (1 << plvl) - 1;
              //    prev 2-byte val map    curr 2-byte val map
              var prev = new u16(32768), head = new u16(msk_1 + 1);
              var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
              var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };
              // 24576 is an arbitrary number of maximum symbols per block
              // 424 buffer for last block
              var syms = new u32(25000);
              // length/literal freq   distance freq
              var lf = new u16(288), df = new u16(32);
              //  l/lcnt  exbits  index  l/lind  waitdx  bitpos
              var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;
              for (; i < s; ++i) {
                  // hash value
                  // deopt when i > s - 3 - at end, deopt acceptable
                  var hv = hsh(i);
                  // index mod 32768    previous index mod
                  var imod = i & 32767, pimod = head[hv];
                  prev[imod] = pimod;
                  head[hv] = imod;
                  // We always should modify head and prev, but only add symbols if
                  // this data is not yet processed ("wait" for wait index)
                  if (wi <= i) {
                      // bytes remaining
                      var rem = s - i;
                      if ((lc_1 > 7000 || li > 24576) && rem > 423) {
                          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                          li = lc_1 = eb = 0, bs = i;
                          for (var j = 0; j < 286; ++j)
                              lf[j] = 0;
                          for (var j = 0; j < 30; ++j)
                              df[j] = 0;
                      }
                      //  len    dist   chain
                      var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;
                      if (rem > 2 && hv == hsh(i - dif)) {
                          var maxn = Math.min(n, rem) - 1;
                          var maxd = Math.min(32767, i);
                          // max possible length
                          // not capped at dif because decompressors implement "rolling" index population
                          var ml = Math.min(258, rem);
                          while (dif <= maxd && --ch_1 && imod != pimod) {
                              if (dat[i + l] == dat[i + l - dif]) {
                                  var nl = 0;
                                  for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                                      ;
                                  if (nl > l) {
                                      l = nl, d = dif;
                                      // break out early when we reach "nice" (we are satisfied enough)
                                      if (nl > maxn)
                                          break;
                                      // now, find the rarest 2-byte sequence within this
                                      // length of literals and search for that instead.
                                      // Much faster than just using the start
                                      var mmd = Math.min(dif, nl - 2);
                                      var md = 0;
                                      for (var j = 0; j < mmd; ++j) {
                                          var ti = (i - dif + j + 32768) & 32767;
                                          var pti = prev[ti];
                                          var cd = (ti - pti + 32768) & 32767;
                                          if (cd > md)
                                              md = cd, pimod = ti;
                                      }
                                  }
                              }
                              // check the previous match
                              imod = pimod, pimod = prev[imod];
                              dif += (imod - pimod + 32768) & 32767;
                          }
                      }
                      // d will be nonzero only when a match was found
                      if (d) {
                          // store both dist and len data in one Uint32
                          // Make sure this is recognized as a len/dist with 28th bit (2^28)
                          syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];
                          var lin = revfl[l] & 31, din = revfd[d] & 31;
                          eb += fleb[lin] + fdeb[din];
                          ++lf[257 + lin];
                          ++df[din];
                          wi = i + l;
                          ++lc_1;
                      }
                      else {
                          syms[li++] = dat[i];
                          ++lf[dat[i]];
                      }
                  }
              }
              pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
              // this is the easiest way to avoid needing to maintain state
              if (!lst && pos & 7)
                  pos = wfblk(w, pos + 1, et);
          }
          return slc(o, 0, pre + shft(pos) + post);
      };
      // CRC32 table
      var crct = /*#__PURE__*/ (function () {
          var t = new Int32Array(256);
          for (var i = 0; i < 256; ++i) {
              var c = i, k = 9;
              while (--k)
                  c = ((c & 1) && -306674912) ^ (c >>> 1);
              t[i] = c;
          }
          return t;
      })();
      // CRC32
      var crc = function () {
          var c = -1;
          return {
              p: function (d) {
                  // closures have awful performance
                  var cr = c;
                  for (var i = 0; i < d.length; ++i)
                      cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);
                  c = cr;
              },
              d: function () { return ~c; }
          };
      };
      // deflate with opts
      var dopt = function (dat, opt, pre, post, st) {
          return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);
      };
      // Walmart object spread
      var mrg = function (a, b) {
          var o = {};
          for (var k in a)
              o[k] = a[k];
          for (var k in b)
              o[k] = b[k];
          return o;
      };
      // read 2 bytes
      var b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };
      // read 4 bytes
      var b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };
      var b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };
      // write bytes
      var wbytes = function (d, b, v) {
          for (; v; ++b)
              d[b] = v, v >>>= 8;
      };
      /**
       * Compresses data with DEFLATE without any wrapper
       * @param data The data to compress
       * @param opts The compression options
       * @returns The deflated version of the data
       */
      function deflateSync(data, opts) {
          return dopt(data, opts || {}, 0, 0);
      }
      /**
       * Expands DEFLATE data with no wrapper
       * @param data The data to decompress
       * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
       * @returns The decompressed version of the data
       */
      function inflateSync(data, out) {
          return inflt(data, out);
      }
      // flatten a directory structure
      var fltn = function (d, p, t, o) {
          for (var k in d) {
              var val = d[k], n = p + k, op = o;
              if (Array.isArray(val))
                  op = mrg(o, val[1]), val = val[0];
              if (val instanceof u8)
                  t[n] = [val, op];
              else {
                  t[n += '/'] = [new u8(0), op];
                  fltn(val, n, t, o);
              }
          }
      };
      // text encoder
      var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();
      // text decoder
      var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
      // text decoder stream
      var tds = 0;
      try {
          td.decode(et, { stream: true });
          tds = 1;
      }
      catch (e) { }
      // decode UTF8
      var dutf8 = function (d) {
          for (var r = '', i = 0;;) {
              var c = d[i++];
              var eb = (c > 127) + (c > 223) + (c > 239);
              if (i + eb > d.length)
                  return [r, slc(d, i - 1)];
              if (!eb)
                  r += String.fromCharCode(c);
              else if (eb == 3) {
                  c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,
                      r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));
              }
              else if (eb & 1)
                  r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));
              else
                  r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));
          }
      };
      /**
       * Converts a string into a Uint8Array for use with compression/decompression methods
       * @param str The string to encode
       * @param latin1 Whether or not to interpret the data as Latin-1. This should
       *               not need to be true unless decoding a binary string.
       * @returns The string encoded in UTF-8/Latin-1 binary
       */
      function strToU8(str, latin1) {
          if (latin1) {
              var ar_1 = new u8(str.length);
              for (var i = 0; i < str.length; ++i)
                  ar_1[i] = str.charCodeAt(i);
              return ar_1;
          }
          if (te)
              return te.encode(str);
          var l = str.length;
          var ar = new u8(str.length + (str.length >> 1));
          var ai = 0;
          var w = function (v) { ar[ai++] = v; };
          for (var i = 0; i < l; ++i) {
              if (ai + 5 > ar.length) {
                  var n = new u8(ai + 8 + ((l - i) << 1));
                  n.set(ar);
                  ar = n;
              }
              var c = str.charCodeAt(i);
              if (c < 128 || latin1)
                  w(c);
              else if (c < 2048)
                  w(192 | (c >> 6)), w(128 | (c & 63));
              else if (c > 55295 && c < 57344)
                  c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),
                      w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));
              else
                  w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));
          }
          return slc(ar, 0, ai);
      }
      /**
       * Converts a Uint8Array to a string
       * @param dat The data to decode to string
       * @param latin1 Whether or not to interpret the data as Latin-1. This should
       *               not need to be true unless encoding to binary string.
       * @returns The original UTF-8/Latin-1 string
       */
      function strFromU8(dat, latin1) {
          if (latin1) {
              var r = '';
              for (var i = 0; i < dat.length; i += 16384)
                  r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
              return r;
          }
          else if (td)
              return td.decode(dat);
          else {
              var _a = dutf8(dat), out = _a[0], ext = _a[1];
              if (ext.length)
                  err(8);
              return out;
          }
      }
      // skip local zip header
      var slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };
      // read zip header
      var zh = function (d, b, z) {
          var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
          var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];
          return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
      };
      // read zip64 extra field
      var z64e = function (d, b) {
          for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
              ;
          return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
      };
      // extra field length
      var exfl = function (ex) {
          var le = 0;
          if (ex) {
              for (var k in ex) {
                  var l = ex[k].length;
                  if (l > 65535)
                      err(9);
                  le += l + 4;
              }
          }
          return le;
      };
      // write zip header
      var wzh = function (d, b, f, fn, u, c, ce, co) {
          var fl = fn.length, ex = f.extra, col = co && co.length;
          var exl = exfl(ex);
          wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
          if (ce != null)
              d[b++] = 20, d[b++] = f.os;
          d[b] = 20, b += 2; // spec compliance? what's that?
          d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;
          d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
          var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
          if (y < 0 || y > 119)
              err(10);
          wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;
          if (c != -1) {
              wbytes(d, b, f.crc);
              wbytes(d, b + 4, c < 0 ? -c - 2 : c);
              wbytes(d, b + 8, f.size);
          }
          wbytes(d, b + 12, fl);
          wbytes(d, b + 14, exl), b += 16;
          if (ce != null) {
              wbytes(d, b, col);
              wbytes(d, b + 6, f.attrs);
              wbytes(d, b + 10, ce), b += 14;
          }
          d.set(fn, b);
          b += fl;
          if (exl) {
              for (var k in ex) {
                  var exf = ex[k], l = exf.length;
                  wbytes(d, b, +k);
                  wbytes(d, b + 2, l);
                  d.set(exf, b + 4), b += 4 + l;
              }
          }
          if (col)
              d.set(co, b), b += col;
          return b;
      };
      // write zip footer (end of central directory)
      var wzf = function (o, b, c, d, e) {
          wbytes(o, b, 0x6054B50); // skip disk
          wbytes(o, b + 8, c);
          wbytes(o, b + 10, c);
          wbytes(o, b + 12, d);
          wbytes(o, b + 16, e);
      };
      /**
       * Synchronously creates a ZIP file. Prefer using `zip` for better performance
       * with more than one file.
       * @param data The directory structure for the ZIP archive
       * @param opts The main options, merged with per-file options
       * @returns The generated ZIP archive
       */
      function zipSync(data, opts) {
          if (!opts)
              opts = {};
          var r = {};
          var files = [];
          fltn(data, '', r, opts);
          var o = 0;
          var tot = 0;
          for (var fn in r) {
              var _a = r[fn], file = _a[0], p = _a[1];
              var compression = p.level == 0 ? 0 : 8;
              var f = strToU8(fn), s = f.length;
              var com = p.comment, m = com && strToU8(com), ms = m && m.length;
              var exl = exfl(p.extra);
              if (s > 65535)
                  err(11);
              var d = compression ? deflateSync(file, p) : file, l = d.length;
              var c = crc();
              c.p(file);
              files.push(mrg(p, {
                  size: file.length,
                  crc: c.d(),
                  c: d,
                  f: f,
                  m: m,
                  u: s != fn.length || (m && (com.length != ms)),
                  o: o,
                  compression: compression
              }));
              o += 30 + s + exl + l;
              tot += 76 + 2 * (s + exl) + (ms || 0) + l;
          }
          var out = new u8(tot + 22), oe = o, cdl = tot - o;
          for (var i = 0; i < files.length; ++i) {
              var f = files[i];
              wzh(out, f.o, f, f.f, f.u, f.c.length);
              var badd = 30 + f.f.length + exfl(f.extra);
              out.set(f.c, f.o + badd);
              wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
          }
          wzf(out, o, files.length, cdl, oe);
          return out;
      }
      /**
       * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
       * performance with more than one file.
       * @param data The raw compressed ZIP file
       * @param opts The ZIP extraction options
       * @returns The decompressed files
       */
      function unzipSync(data, opts) {
          var files = {};
          var e = data.length - 22;
          for (; b4(data, e) != 0x6054B50; --e) {
              if (!e || data.length - e > 65558)
                  err(13);
          }
          var c = b2(data, e + 8);
          if (!c)
              return {};
          var o = b4(data, e + 16);
          var z = o == 4294967295 || c == 65535;
          if (z) {
              var ze = b4(data, e - 12);
              z = b4(data, ze) == 0x6064B50;
              if (z) {
                  c = b4(data, ze + 32);
                  o = b4(data, ze + 48);
              }
          }
          var fltr = opts && opts.filter;
          for (var i = 0; i < c; ++i) {
              var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
              o = no;
              if (!fltr || fltr({
                  name: fn,
                  size: sc,
                  originalSize: su,
                  compression: c_2
              })) {
                  if (!c_2)
                      files[fn] = slc(data, b, b + sc);
                  else if (c_2 == 8)
                      files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));
                  else
                      err(14, 'unknown compression type ' + c_2);
              }
          }
          return files;
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-07-23
       */
      class ResourceIO {

          static RESOURCE_TYPE_SCENE = 'scene';
          static RESOURCE_TYPE_TOOL = 'tool';

          /**
           *
           * @param snapshot {Snapshot}
           * @returns Uint8Array
           */
          static createResourceFromSnapshot(snapshot) {
              // TODO
              return LegacySnapshotIO.createSave(snapshot);
          }

          // TODO: other types of resources
          /**
           *
           * @param content {ArrayBuffer}
           * @returns Promise<Scene>
           */
          static async parseResource(content) {
              const zip = unzipSync(new Uint8Array(content));

              if (zip['metadata.json']) {
                  // old snapshot format
                  let snapshot = LegacySnapshotIO.parseSave(zip);
                  return new SceneImplSnapshot(snapshot);
              }
              throw 'Wrong format';
          }

          /**
           *
           * @param json
           * @returns {Promise<Tool>}
           */
          static async parseToolDefinition(json) {
              return NewIO.parseToolDefinition(json);
          }

          /**
           *
           * @param objectUrl {string}
           * @param brush {Brush}
           * @param defaultElement {Element}
           * @param threshold {number} 0-255
           * @param maxWidth {number|undefined}
           * @param maxHeight {number|undefined}
           * @returns Promise<Scene>
           */
          static async fromImage(objectUrl, brush, defaultElement, threshold, maxWidth, maxHeight) {
              const imageData = await Assets.asImageData(objectUrl, maxWidth, maxHeight);

              const width = imageData.width;
              const height = imageData.height;

              const elementArea = ElementArea.create(width, height, defaultElement);

              const random = new DeterministicRandom(0);

              for (let y = 0; y < height; y++) {
                  for (let x = 0; x < width; x++) {
                      const index = (y * width + x) * 4;

                      let red = imageData.data[index];
                      let green = imageData.data[index + 1];
                      let blue = imageData.data[index + 2];
                      const alpha = imageData.data[index + 3];

                      // perform alpha blending if needed
                      if (alpha !== 0xFF) {
                          red = Math.trunc((red * alpha) / 0xFF) + 0xFF - alpha;
                          green = Math.trunc((green * alpha) / 0xFF) + 0xFF - alpha;
                          blue = Math.trunc((blue * alpha) / 0xFF) + 0xFF - alpha;
                      }

                      // filter out background
                      if (red > 0xFF-threshold && green > 0xFF-threshold && blue > 0xFF-threshold) {
                          continue;  // white
                      }

                      const element = brush.apply(x, y, random);
                      const elementHead = element.elementHead;
                      const elementTail = ElementTail.setColor(element.elementTail, red, green, blue);
                      elementArea.setElementHeadAndTail(x, y, elementHead, elementTail);
                  }
              }

              return new SceneImplTemplate(elementArea);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-07-23
       */
      class NewIO {

          /**
           *
           * @param json
           * @returns {Promise<Tool>}
           */
          static async parseToolDefinition(json) {
              const type = json.type;
              const name = json.name;
              const category = json.category;
              const action = json.action;

              if (type === undefined) {
                  throw 'Tool definition: type not set';
              }
              if (name === undefined) {
                  throw 'Tool definition: name not set';
              }
              if (category === undefined) {
                  throw 'Tool definition: category not set';
              }
              if (action === undefined) {
                  throw 'Tool definition: action not set';
              }

              if (type === 'template') {
                  const scenes = await NewIO.parseSceneDefinition(action);
                  return Tool.insertElementAreaTool(category, null, name, scenes, undefined);

              } else {
                  throw 'Tool type not supported: ' + type;
              }
          }

          /**
           *
           * @param json
           * @returns {Promise<Scene[]>}
           */
          static async parseSceneDefinition(json) {
              const type = json.type;

              if (type === 'image-template') {
                  const imageData = json.imageData;
                  if (imageData === undefined) {
                      throw 'Image template: imageData not set';
                  }

                  const threshold = json.threshold;
                  if (threshold === undefined) {
                      throw 'Image template: threshold not set';
                  }
                  const parsedThreshold = parseInt(threshold);

                  const brush = json.brush;
                  if (brush === undefined) {
                      throw 'Image template: brush not set';
                  }
                  const parsedBrush = Brushes.byCodeName(json.brush);
                  if (parsedBrush === null) {
                      throw 'Image template: brush not found: ' + brush;
                  }

                  const scene = await ResourceIO.fromImage(imageData, parsedBrush, ElementArea.TRANSPARENT_ELEMENT,
                          parsedThreshold, undefined, undefined);
                  const scenes = [ scene ];

                  const randomFlipHorizontally = json.randomFlipHorizontally;
                  if (randomFlipHorizontally) {
                      scenes.push(new SceneImplModFlip(scene, true, false));
                  }

                  const randomFlipVertically = json.randomFlipVertically;
                  if (randomFlipVertically) {
                      for (const s of [...scenes]) {
                          scenes.push(new SceneImplModFlip(s, false, true));
                      }
                  }

                  return scenes;

              } else if (type === 'random') {
                  const actions = json.actions;
                  if (actions === undefined || actions.length === undefined || actions.length === 0) {
                      throw 'Image template: actions not set';
                  }

                  let scenes = [];
                  for (let i = 0; i < actions.length; i++) {
                      let parsedScenes = await NewIO.parseSceneDefinition(actions[i]);
                      for (let s of parsedScenes) {
                          scenes.push(s);
                      }
                  }
                  return scenes;

              } else {
                  throw 'Scene type not supported: ' + type;
              }
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-10-11
       */
      class LegacySnapshotIO {
          /**
           *
           * @param snapshot {Snapshot}
           * @returns Uint8Array
           */
          static createSave(snapshot) {
              const metadata = strToU8(JSON.stringify(snapshot.metadata, null, 2));

              let zipData = {
                  'metadata.json': metadata,
                  'data-heads.bin': new Uint8Array(snapshot.dataHeads),
                  'data-tails.bin': new Uint8Array(snapshot.dataTails)
              };
              return zipSync(zipData, { level: 9 });
          }

          /**
           *
           * @param zip {{[path: string]: Uint8Array}}
           * @returns Snapshot
           */
          static parseSave(zip) {
              let snapshot = new Snapshot();

              let metadataRaw = zip['metadata.json'];
              if (!metadataRaw) {
                  throw 'metadata.json not found';
              }
              snapshot.metadata = Object.assign(new SceneMetadata(), JSON.parse(strFromU8(metadataRaw)));
              if (typeof snapshot.metadata.width !== "number") {
                  throw 'Metadata property wrong format: width';
              }
              if (typeof snapshot.metadata.height !== "number") {
                  throw 'Metadata property wrong format: height';
              }

              // load element data
              if (snapshot.metadata.formatVersion < 3) {
                  // ensure backward compatibility
                  // legacy interleaving buffer (element head 1, element tail 1, element head 2, element tail 2, ...)
                  const dataRaw = zip['data.bin'];
                  if (dataRaw) {
                      if (dataRaw.byteLength % 8 !== 0) {
                          throw 'Buffer length is not divisible by 8';
                      }
                      const elements = dataRaw.byteLength / 8;
                      const dataHeads = new Uint8Array(new ArrayBuffer(elements * 4));
                      const dataTails = new Uint8Array(new ArrayBuffer(elements * 4));
                      for (let i = 0; i < elements; i++) {
                          for (let j = 0; j < 4; j++) {  // 4 bytes
                              dataHeads[(i * 4) + j] = dataRaw[(i * 8) + j];
                              dataTails[(i * 4) + j] = dataRaw[(i * 8) + j + 4];
                          }
                      }
                      snapshot.dataHeads = dataHeads.buffer;
                      snapshot.dataTails = dataTails.buffer;
                  } else {
                      throw 'data.bin not found';
                  }
              } else {
                  // one buffer for element heads and one for element tails
                  const dataRawHeads = zip['data-heads.bin'];
                  if (dataRawHeads) {
                      snapshot.dataHeads = dataRawHeads.buffer;
                  } else {
                      throw 'data-heads.bin not found';
                  }
                  const dataRawTails = zip['data-tails.bin'];
                  if (!dataRawTails) {
                      throw 'data-tails.bin not found';
                  }
                  snapshot.dataTails = dataRawTails.buffer;
              }

              // ensure backward compatibility
              if (snapshot.metadata.formatVersion === 1) {
                  // after 23w32a first byte of element head was changed (powder elements reworked)
                  LegacySnapshotIO.#convertToV2(snapshot);
                  snapshot.metadata.formatVersion = 2;
              }
              if (snapshot.metadata.formatVersion === 2) {
                  // interleaving buffer >> element head buffer & element tail buffer
                  snapshot.metadata.formatVersion = 3;
              }

              return snapshot;
          }

          static #convertToV2(snapshot) {
              const elementArea = ElementArea.from(
                      snapshot.metadata.width, snapshot.metadata.height,
                      snapshot.dataHeads, snapshot.dataTails);

              for (let y = 0; y < snapshot.metadata.height; y++) {
                  for (let x = 0; x < snapshot.metadata.width; x++) {

                      // TODO: dry flag ignored
                      let elementHead = elementArea.getElementHead(x, y);
                      let oldType = elementHead & 0b111;  // type without dry flag
                      let oldWeight = (elementHead >> 4) & 0x0000000F;

                      if (oldType === 0x0 && oldWeight === 0x0) ; else if (oldType === 0x0) {
                          // static
                          elementArea.setElementHead(x, y, ElementHead.setType(elementHead, 0x7));
                      } else if (oldType === 0x1) {
                          // falling (grass only)
                          elementArea.setElementHead(x, y, ElementHead.setType(elementHead, 0x5));
                      } else if (oldType === 0x2) {
                          // sand 1 (soil, gravel)
                          elementArea.setElementHead(x, y, ElementHead.setType(elementHead, 0x5 | (4 << 5)));
                      } else if (oldType === 0x3) {
                          // sand 2 (sand)
                          elementArea.setElementHead(x, y, ElementHead.setType(elementHead, 0x5 | (6 << 5)));
                      } else if (oldType === 0x4 || oldType === 0x5) {
                          // fluid 1 (not used) or fluid 2 (water)
                          elementArea.setElementHead(x, y, ElementHead.setType(elementHead, 0x3));
                      }
                  }
              }

              snapshot.dataHeads = elementArea.getDataHeads();
              snapshot.dataTails = elementArea.getDataTails();
          }
      }

      // TODO: refactor

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ServiceIO {

          /** @type Controller */
          #controller;

          /** @type TemplateForm */
          #templateForm;

          constructor(controller) {
              this.#controller = controller;
              this.#templateForm = new TemplateForm();
          }

          initFileDragAndDrop(node) {
              const domNode = node[0];

              ['dragenter', 'dragover'].forEach(eventName => {
                  domNode.addEventListener(eventName, e => {
                      e.preventDefault();
                      e.stopPropagation();
                      domNode.classList.add('drag-and-drop-highlight');
                  });
              });

              domNode.addEventListener('dragleave', e => {
                  e.preventDefault();
                  e.stopPropagation();
                  domNode.classList.remove('drag-and-drop-highlight');
              });

              domNode.addEventListener('drop', e => {
                  e.preventDefault();
                  e.stopPropagation();
                  domNode.classList.remove('drag-and-drop-highlight');

                  this.loadFromFiles(e.dataTransfer.files);
              });
          }

          loadFromFiles(files) {
              if (!files) {
                  return;
              }
              let file = files[0];

              let reader = new FileReader();
              reader.onload = (readerEvent) => {
                  let content = readerEvent.target.result;
                  this.loadFromArrayBuffer(content, file.name);
              };
              reader.readAsArrayBuffer(file);
          }

          /**
           *
           * @param content {ArrayBuffer}
           * @param filename {string}
           */
          loadFromArrayBuffer(content, filename) {
              try {
                  let imageTypeOrNull = Assets.getImageTypeOrNull(filename);
                  if (imageTypeOrNull !== null) {
                      this.#loadImageTemplate(content, imageTypeOrNull);
                  } else {
                      ResourceIO.parseResource(content)
                              .then(scene => this.#importScene(scene))
                              .catch(e => this.#handleError(e));
                  }
              } catch (e) {
                  this.#handleError(e);
              }
          }

          #loadImageTemplate(content, imageType) {
              const handleImageTemplate = (brush, threshold, maxWidth, maxHeight) => {
                  const objectUrl = Assets.asObjectUrl(content, imageType);
                  ResourceIO.fromImage(objectUrl, brush, ElementArea.TRANSPARENT_ELEMENT, threshold, maxWidth, maxHeight)
                      .then(scene => this.#importImageTemplate(scene))
                      .catch(e => this.#handleError(e));
              };

              let dialog = new DomBuilder.BootstrapDialog();
              dialog.setHeaderContent('Image template');
              dialog.setBodyContent(this.#templateForm.create());
              dialog.addSubmitButton('Place', () => {
                  let materialBrush = this.#templateForm.getMaterialBrush();
                  let thresholdValue = this.#templateForm.getThresholdValue();
                  let maxWidth = this.#templateForm.getMaxWidth();
                  let maxHeight = this.#templateForm.getMaxHeight();
                  handleImageTemplate(materialBrush, thresholdValue, maxWidth, maxHeight);
              });
              dialog.addCloseButton('Close');
              dialog.show(this.#controller.getDialogAnchor());
          }

          #importImageTemplate(scene) {
              this.#controller.pasteScene(scene);
              Analytics.triggerFeatureUsed(Analytics.FEATURE_IO_IMAGE_TEMPLATE);
          }

          #importScene(scene) {
              try {
                  let dialog = new DomBuilder.BootstrapDialog();
                  dialog.setHeaderContent('Import scene');
                  dialog.setBodyContent([
                      DomBuilder.par(null, "The imported scene can be opened or placed on the current scene.")
                  ]);
                  dialog.addSubmitButton('Open', () => {
                      Analytics.triggerFeatureUsed(Analytics.FEATURE_IO_IMPORT);
                      return this.#controller.openScene(scene);
                  });
                  dialog.addSubmitButton('Place', () => {
                      Analytics.triggerFeatureUsed(Analytics.FEATURE_IO_IMPORT);
                      return this.#controller.pasteScene(scene);
                  });
                  dialog.addCloseButton('Close');
                  dialog.show(this.#controller.getDialogAnchor());
              } catch (ex) {
                  this.#handleError(ex);
              }
          }

          #handleError(e) {
              let dialog = new DomBuilder.BootstrapDialog();
              dialog.setHeaderContent('Error');
              dialog.setBodyContent([
                  DomBuilder.par(null, "Error while loading resource:"),
                  DomBuilder.element('code', null, e)
              ]);
              dialog.addCloseButton('Close');
              dialog.show(this.#controller.getDialogAnchor());
          }
      }

      /**
       * Creates template form and remembers last values.
       *
       * @author Patrik Harag
       * @version 2023-05-19
       */
      class TemplateForm {

          #thresholdValue = 50;
          #maxWidth = 300;
          #maxHeight = 200;
          #materialValue = 'sand';
          #materialBrush = Brushes.SAND;

          create() {
              return DomBuilder.element('form', null, [
                  DomBuilder.element('fieldset', { class: 'form-group row' }, [
                      DomBuilder.element('legend', { class: 'col-form-label col-sm-3 float-sm-left pt-0' }, 'Material'),
                      DomBuilder.div({ class: 'col-sm-9' }, [
                          this.#creatMaterialFormGroup('sand', Brushes.SAND, 'Sand'),
                          this.#creatMaterialFormGroup('red_sand', Brushes.RED_SAND, 'Red Sand'),
                          this.#creatMaterialFormGroup('soil', Brushes.SOIL, 'Soil'),
                          this.#creatMaterialFormGroup('wall', Brushes.WALL, 'Solid'),
                          this.#creatMaterialFormGroup('glitch', Brushes.GLITCH, 'Glitchy'),
                          this.#creatMaterialFormGroup('wood', Brushes.TREE_WOOD, 'Wood'),
                          this.#creatMaterialFormGroup('real_wood', Brushes.WOOD, 'Real Wood')
                      ])
                  ]),
                  DomBuilder.element('fieldset', { class: 'form-group row' }, [
                      DomBuilder.element('legend', { class: 'col-form-label col-sm-3 float-sm-left pt-0' }, 'Background threshold'),
                      DomBuilder.div({ class: 'col-sm-9' }, [
                          this.#createThresholdSliderFormGroup(),
                      ])
                  ]),
                  DomBuilder.element('fieldset', { class: 'form-group row' }, [
                      DomBuilder.element('legend', { class: 'col-form-label col-sm-3 float-sm-left pt-0' }, 'Max size'),
                      DomBuilder.div({ class: 'col-sm-9' }, [
                          this.#createMaxWidthFormGroup(),
                          this.#createMaxHeightFormGroup(),
                      ])
                  ])
              ]);
          }

          #createThresholdSliderFormGroup() {
              const id = 'image-template_threshold-slider';

              const label = DomBuilder.element('label', { 'for': id }, 'Value: ' + this.#thresholdValue);

              const slider = DomBuilder.element('input', {
                  id: id,
                  class: 'form-control-range',
                  type: 'range',
                  min: 0, max: 255, value: this.#thresholdValue
              });
              slider.on('change', (e) => {
                  this.#thresholdValue = e.target.value;
                  label.text('Value: ' + this.#thresholdValue);
              });

              return DomBuilder.div({ class: 'form-group' }, [
                  slider,
                  DomBuilder.element('small', null, label)
              ]);
          }

          #createMaxWidthFormGroup() {
              const id = 'image-template_max-width';

              const label = DomBuilder.element('label', { 'for': id }, 'Width: ' + this.#maxWidth);

              const slider = DomBuilder.element('input', {
                  id: id,
                  class: 'form-control-range',
                  type: 'range',
                  min: 25, max: 800, value: this.#maxWidth
              });
              slider.on('change', (e) => {
                  this.#maxWidth = e.target.value;
                  label.text('Width: ' + this.#maxWidth);
              });

              return DomBuilder.div({ class: 'form-group' }, [
                  slider,
                  DomBuilder.element('small', null, label)
              ]);
          }

          #createMaxHeightFormGroup() {
              const id = 'image-template_max-height';

              const label = DomBuilder.element('label', { 'for': id }, 'Height: ' + this.#maxHeight);

              const slider = DomBuilder.element('input', {
                  id: id,
                  class: 'form-control-range',
                  type: 'range',
                  min: 25, max: 800, value: this.#maxHeight
              });
              slider.on('change', (e) => {
                  this.#maxHeight = e.target.value;
                  label.text('Height: ' + this.#maxHeight);
              });

              return DomBuilder.div({ class: 'form-group' }, [
                  slider,
                  DomBuilder.element('small', null, label)
              ]);
          }

          #creatMaterialFormGroup(value, brush, label) {
              const checked = (this.#materialValue === value);
              const id = 'image-template_checkbox-material-' + value;

              const input = DomBuilder.element('input', {
                  class: 'form-check-input',
                  type: 'radio',
                  name: 'template-material',
                  id: id,
                  value: value,
                  checked: checked
              });
              input.on('click', () => {
                  this.#materialBrush = brush;
                  this.#materialValue = value;
              });

              return DomBuilder.div({ class: 'form-check' }, [
                  input,
                  DomBuilder.element('label', { class: 'form-check-label badge badge-secondary ' + value, 'for': id }, label)
              ]);
          }

          getThresholdValue() {
              return this.#thresholdValue;
          }

          getMaterialBrush() {
              return this.#materialBrush;
          }

          getMaxWidth() {
              return this.#maxWidth;
          }

          getMaxHeight() {
              return this.#maxHeight;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-10-15
       */
      class Controller {

          #init = {
              scale: 0.5,
              canvasWidthPx: 700,
              canvasHeightPx: 400,
              scene: 'empty'
          };

          /** @type number */
          #currentWidthPoints;
          /** @type number */
          #currentHeightPoints;
          /** @type number */
          #currentScale;

          /** @type SandGame */
          #sandGame = null;
          /** @type string */
          #imageRendering = 'pixelated';
          /** @type function[] */
          #onImageRenderingStyleChanged = [];
          /** @type boolean */
          #simulationEnabled = false;
          /** @type boolean */
          #showActiveChunks = false;
          #rendererInitializer = RendererInitializer.canvasWebGL();

          /** @type ServiceToolManager */
          #serviceToolManager = new ServiceToolManager();
          /** @type ServiceIO */
          #serviceIO = new ServiceIO(this);

          #dialogAnchor;
          #canvasInitializer = null;

          /**
           *
           * @param init
           */
          constructor(init) {
              if (init) {
                  this.#init = init;
              }

              this.#currentWidthPoints = Math.trunc(this.#init.canvasWidthPx * this.#init.scale);
              this.#currentHeightPoints = Math.trunc(this.#init.canvasHeightPx * this.#init.scale);
              this.#currentScale = this.#init.scale;
          }

          /**
           *
           * @param canvasInitializer {function(contextId:string):CanvasRenderingContext2D|WebGLRenderingContext}
           */
          registerCanvasInitializer(canvasInitializer) {
              this.#canvasInitializer = canvasInitializer;
          }

          registerDialogAnchor(dialogAnchor) {
              this.#dialogAnchor = dialogAnchor;
          }

          setup() {
              this.#initialize(Scenes.SCENES[this.#init.scene]);
          }

          /**
           *
           * @param scene {Scene}
           */
          #initialize(scene) {
              if (this.#canvasInitializer == null) {
                  throw 'Illegal state: canvas initializer not registered!';
              }
              if (this.#dialogAnchor == null) {
                  throw 'Illegal state: dialog anchor not registered!';
              }

              const [w, h] = scene.countSize(this.#currentWidthPoints, this.#currentHeightPoints);
              if (w !== this.#currentWidthPoints || h !== this.#currentHeightPoints) {
                  this.#currentWidthPoints = w;
                  this.#currentHeightPoints = h;
                  this.#currentScale = +(w / this.#init.canvasWidthPx).toFixed(3);
              }

              // init game
              const defaultElement = Brushes.AIR.apply(0, 0, undefined);
              let contextType = this.#rendererInitializer.getContextType();
              let context = this.#canvasInitializer(contextType);
              if ((contextType === 'webgl' || contextType === 'webgl2') && (context === null || context === undefined)) {
                  // WebGL is not supported - unsupported at all / unsupported after recent failure
                  // - to test this, run Chrome with --disable-3d-apis
                  this.#reportRenderingFailure("Unable to get WebGL context. Using fallback renderer; game performance may be affected");
                  this.#rendererInitializer = RendererInitializer.canvas2d();
                  contextType = this.#rendererInitializer.getContextType();
                  context = this.#canvasInitializer(contextType);
              }
              this.#sandGame = scene.createSandGame(w, h, defaultElement, context, this.#rendererInitializer);
              this.#sandGame.graphics().replace(ElementArea.TRANSPARENT_ELEMENT, defaultElement);

              this.#onInitialized.forEach(f => f(this.#sandGame));

              // start rendering
              this.#sandGame.startRendering();

              // start processing - if enabled
              if (this.#simulationEnabled) {
                  this.#sandGame.startProcessing();
              }
          }

          #close() {
              if (this.#sandGame !== null) {
                  this.#sandGame.stopProcessing();
                  this.#sandGame.stopRendering();
              }
              for (let func of this.#onBeforeClosed) {
                  func();
              }
          }

          enableGlobalShortcuts() {
              document.onkeydown = (e) => {
                  // handle start stop
                  if (e.ctrlKey && !e.altKey && !e.shiftKey && e.key === 'Enter') {
                      e.preventDefault();
                      this.switchStartStop();
                  }
                  // handle next step
                  if (e.ctrlKey && !e.altKey && !e.shiftKey && e.key === ' ') {
                      e.preventDefault();
                      if (this.#sandGame !== null) {
                          this.#sandGame.doProcessing();
                      }
                  }
                  // handle fast execute
                  if (e.ctrlKey && !e.altKey && e.shiftKey && e.key === ' ') {
                      e.preventDefault();
                      if (this.#sandGame !== null) {
                          const input = prompt('Enter the number of iterations to run', '10000');
                          const iterations = Math.abs(parseInt(input));
                          const timeBefore = new Date();
                          for (let i = 0; i < iterations; i++) {
                              this.#sandGame.doProcessing();
                              if (i % 2500 === 0) {
                                  console.log(`Performed ${i} of ${iterations} iterations`);
                              }
                          }
                          const timeAfter = new Date();
                          const elapsedMs = timeAfter.getTime() - timeBefore.getTime();
                          console.log(`Performed ${iterations} iterations in ${elapsedMs} ms`);
                      }
                  }
              };
          }

          /**
           *
           * @returns {SandGame|null}
           */
          getSandGame() {
              return this.#sandGame;
          }

          // controller - simulation state

          /** @type function(SandGame)[] */
          #onInitialized = [];
          /** @type function(SandGame)[] */
          #onBeforeClosed = [];
          /** @type function[] */
          #onBeforeNewSceneLoaded = [];
          /** @type function[] */
          #onStarted = [];
          /** @type function[] */
          #onStopped = [];

          /**
           *
           * @param handler {function(SandGame)}
           * @returns void
           */
          addOnInitialized(handler) {
              this.#onInitialized.push(handler);
          }

          /**
           *
           * @param handler {function}
           * @returns void
           */
          addOnBeforeNewSceneLoaded(handler) {
              this.#onBeforeNewSceneLoaded.push(handler);
          }

          /**
           *
           * @param handler {function}
           * @returns void
           */
          addOnBeforeClosed(handler) {
              this.#onBeforeClosed.push(handler);
          }

          /**
           *
           * @param handler {function}
           * @returns void
           */
          addOnStarted(handler) {
              this.#onStarted.push(handler);
          }

          /**
           *
           * @param handler {function}
           * @returns void
           */
          addOnStopped(handler) {
              this.#onStopped.push(handler);
          }

          restartAfterRenderingFailure(cause) {
              this.#reportRenderingFailure(cause);
              const snapshot = this.createSnapshot();
              this.#rendererInitializer = RendererInitializer.canvas2d();  // fallback to classic CPU renderer
              this.openScene(new SceneImplSnapshot(snapshot));
          }

          #reportRenderingFailure(message) {
              console.warn(message);

              let toast = new DomBuilder.BootstrapToast();
              toast.setHeaderContent(DomBuilder.element('strong', { style: 'color: orange;' }, 'Warning'));
              toast.setBodyContent(DomBuilder.par(null, message));
              toast.setDelay(20000);
              toast.show(this.#dialogAnchor);
          }

          start() {
              if (this.#sandGame !== null) {
                  if (!this.#simulationEnabled) {
                      this.#simulationEnabled = true;
                      this.#sandGame.startProcessing();
                      this.#onStarted.forEach(f => f());
                  }
              }
          }

          switchStartStop() {
              if (this.#sandGame !== null) {
                  if (this.#simulationEnabled) {
                      this.#simulationEnabled = false;
                      this.#sandGame.stopProcessing();
                      this.#onStopped.forEach(f => f());
                  } else {
                      this.#simulationEnabled = true;
                      this.#sandGame.startProcessing();
                      this.#onStarted.forEach(f => f());
                  }
              }
          }

          /**
           * @returns Snapshot
           */
          createSnapshot() {
              let snapshot = this.#sandGame.createSnapshot();
              snapshot.metadata.scale = this.getCurrentScale();
              return snapshot;
          }

          openScene(scene) {
              for (let handler of this.#onBeforeNewSceneLoaded) {
                  handler();
              }
              this.#close();

              this.#initialize(scene);
          }

          pasteScene(scene) {
              const toolManager = this.getToolManager();
              const revert = toolManager.createRevertAction();

              toolManager.setPrimaryTool(Tool.insertElementAreaTool(null, null, null, [ scene ], revert));
              toolManager.setSecondaryTool(Tool.actionTool(null, null, null, revert));
          }

          // controller / canvas size

          /**
           *
           * @returns {number}
           */
          getCurrentWidthPoints() {
              return this.#currentWidthPoints;
          }

          /**
           *
           * @returns {number}
           */
          getCurrentHeightPoints() {
              return this.#currentHeightPoints;
          }

          /**
           *
           * @returns {number}
           */
          getCurrentScale() {
              return this.#currentScale;
          }

          /**
           *
           * @param width
           * @param height
           * @param scale
           * @returns void
           */
          changeCanvasSize(width, height, scale) {
              if (typeof width !== 'number' || !(width > 0 && width < 2048)) {
                  throw 'Incorrect width';
              }
              if (typeof height !== 'number' || !(height > 0 && height < 2048)) {
                  throw 'Incorrect height';
              }
              if (typeof scale !== 'number' || !(scale > 0 && scale <= 1)) {
                  throw 'Incorrect scale';
              }

              this.#close();

              this.#currentWidthPoints = width;
              this.#currentHeightPoints = height;
              this.#currentScale = scale;

              this.#initialize(new SceneImplTmpResize(this.#sandGame));
          }

          // controller / options

          /**
           *
           * @param show {boolean}
           * @returns void
           */
          setShowActiveChunks(show) {
              this.#showActiveChunks = show;
          }

          /**
           * @returns {boolean}
           */
          isShowActiveChunks() {
              return this.#showActiveChunks;
          }

          /**
           *
           * @param initializer {RendererInitializer}
           * @returns void
           */
          setRendererInitializer(initializer) {
              this.#rendererInitializer = initializer;
              if (this.#sandGame) {
                  this.#close();
                  this.#initialize(new SceneImplTmpResize(this.#sandGame));
              }
          }

          /**
           * @returns {RendererInitializer}
           */
          getRendererInitializer() {
              return this.#rendererInitializer;
          }

          /**
           *
           * @param style {string}
           * @returns void
           */
          setCanvasImageRenderingStyle(style) {
              this.#imageRendering = style;
              for (let func of this.#onImageRenderingStyleChanged) {
                  func(style);
              }
          }

          /**
           * @returns {string}
           */
          getCanvasImageRenderingStyle() {
              return this.#imageRendering;
          }

          /**
           *
           * @param handler {function(string)}
           * @returns void
           */
          addOnImageRenderingStyleChanged(handler) {
              this.#onImageRenderingStyleChanged.push(handler);
          }

          // controller / services

          /**
           *
           * @returns {ServiceToolManager}
           */
          getToolManager() {
              return this.#serviceToolManager;
          }

          /**
           *
           * @returns {ServiceIO}
           */
          getIOManager() {
              return this.#serviceIO;
          }

          // controller / ui

          getDialogAnchor() {
              return this.#dialogAnchor;
          }
      }

      /**
       * @interface
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class Component {

          /**
           *
           * @param controller {Controller}
           * @return {jQuery<HTMLElement>}
           */
          createNode(controller) {
              throw 'Not implemented';
          }
      }

      /**
       * @interface
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class Action {

          /**
           *
           * @param controller {Controller}
           * @returns void
           */
          performAction(controller) {
              throw 'Not implemented';
          }

          /**
           *
           * @param func {function(controller:Controller):void}
           * @returns {ActionAnonymous}
           */
          static create(func) {
              return new ActionAnonymous(func);
          }

          /**
           *
           * @param def {boolean}
           * @param func {function(controller:Controller,v:boolean):void}
           * @returns {ActionAnonymous}
           */
          static createToggle(def, func) {
              let state = def;
              return new ActionAnonymous(function (c) {
                  state = !state;
                  func(c, state);
              });
          }
      }

      class ActionAnonymous extends Action {
          #func;

          constructor(func) {
              super();
              this.#func = func;
          }

          performAction(controller) {
              this.#func(controller);
          }
      }
  //bingbingbing
      var img$j = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAn5JREFUeF7tW0tOwzAQTUQXrMoBELkHEnfhIiy5ASfgLkjco4gD0BWLoCKndZQ6jsceez5R3F2bxvF7fvM842nbZuOvduP4m0pAVcDGGaghsHEBVBNs+/enU64K+q/PZvfwOA5j3t++/KHC6/f15jQdyw66e/5AjQdhOxNwPEDfC17vf77PBEzGMZ+lkjCAv7ufP2vfNdslgBC8YZpMAWbwFBVIrP5AgHlwlv4vN7shUIQA4tUfCCgB3o7h85MYFUitvm4CGFa/OAGD7D27SkgFkquvlwCm1SchwKrAJEPuy80LlgzYGCrVvu/OqagJljRUrrEqAVxMa31OVYCWlTHbZ04VicUhroCxHD8ekmoHLGA1u8AU+HRSMalzKfBkeUBogkvAx3oCcY6QQwhbCMQAN0BSD1FywLMoQCtwSxyZArQDJyNgLcBpCfAcshp3l4hxyCOKh4B7HqAVOJkC3HIYcnWoL0FdFl8pwE4m96GmzoeAj/t+oC/BkRSNBFxJd98N88slAoo/q5alxowcAXbmDESEOlNsBIDtMUIiVBBgz+a8fbmpjgmIUEGAxShBhD0HWPKLWDON8Rvfd7x5ACcRqrZBl6EUIrCnOf1bN+tN2nY7dswUNURlgjFEYB17FQRAHoEFP+QBa1AAFBo5BIS6Qywh4DOh2AzQTj7HqcVN0Fe95QBKMSAVqXAlwKnGcuI5dfWrAhZ+UDGWygxH5LNfiVUFMLA+DRXxWkCFCQbMI3ZLxviPuUc+BKQzQXEFVAKEq8HNK8BXjHCmwiqLIayjUtzHvgtQgMCOyZGUFfm/ABYgdF8lgCErrQoAu0KQTgmvs4RAqb/MUPFAvSX/A0cMoV9aUoLsAAAAAElFTkSuQmCC";

      var img$i = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAASlJREFUeF7tm8ENwjAQBM+CBy86gD6QKI0njVANfYAoAF48jEAmsaMkVozC687jCryru/Pu2nb+tH9Lpctfz+JqJSCAD6sj4HGpqg78/QYBVAAtMDEDYo9oHwzLzU4kM9+KM8ACAV/wYf1DwOrwclqrIB3xEDA+4n9uASqAFmAGMAQ5BZQywDEYsw50ADpg1MQIoVIgEhlCCaIEUYIoQaU6SBBCCKH21gsliBJECQ4ZQAojhQuXo3iBtkQwQ5ghzBBmCDOklAHcIG4QN9g8AsUOY4exw9jhAQPkAeQB5AHTr8UJRAhEmh4hESIRIhGqNxFK7+2VBiJp23PcoKy32mF3+59FgB34WSRFL2Acv0BAyQxRAcYZ6LVA/EhsHHMWnnseF9V+nw+MfABuYozu9NxGSQAAAABJRU5ErkJgggAA";

      var img$h = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAcdJREFUeF7tmU1Ow0AMhV3BghUcAKkn4S5chCUX4S5I3KOoB6ArFkGgKQxKozZjZ2yPo3lZT+L3Pr/5iWZDnT+bzv0TACABnRPAFOg8AFgEMQUwBQQEhpeH7zT8+vE1THJqNbGM5CJ02NHwsaebpy/WewK2i4cetR12RLfb4zekzZk1MjY+VhgFwr/5sTghiDKARHfyhAZAJEppMcpnKQuLLM73zItaugCA0x0t2pxanDGaeooJSII0C3IMlsZo6mEBiARB03zyBQCluJ3s//nQ0Whb1O6+KAERpkFzAC0hWJgXJwAA/ua+VTcurUeW9di7QMvFMBwAz6lgaX7RGpCTYC3Mq86iKeAlzgMyAEhOgufGWnXJ6rtTD1UJsFwMVwPAAoKX+apdwPJcsDoAminwNK+WAABQ+kfw7r5qAjRSsHoANRBamFdPwCUA6SYpPXN3ip/PV78Xr3f3J2cV61uo6oPQ3OmQY3z6/hiEtXmTBOQUDO9vVbfIGYT1TbRJAmr/LzzfBwBP2hFrIQERu+KpCQnwpB2xFhIQsSuempAAT9oRayEBEbviqQkJ8KQdsRYSELErnpqQAE/aEWshARG74qmp+wT8ALf5JV/oG6j0AAAAAElFTkSuQmCC";

      var img$g = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAT5JREFUeF7tmcERgjAQRcN48WQJVmJpHm3EauxDxwL05CGODp5UAiFZIOJ/XIVkeftf4oTKiV+V+Ps7AJAAcQIoIB4AFkEUQAFxAiggHgB2ARRAAXECKCAeAHYBFEABcQIoIB4AdgEUQAFxAiggHgB2ARRAAXECKCAeAHaBhgJ+v3l8p8KfDm65vf+0Lrl1hwFcjx8M/OU8DwAZdQOgEfdagQySpRfTlwIZdQe9zh2sFARLvQAIdc1CtEQKLPWSABIQIGCJ1F8oUL/EXCBY62z9e2sdeKokWOsEQFunrGRJwEQErI1Cga5GWemOHYIh6us85BhigjEhDFEfAFIVcKv1mE1NHzvjDOB9kuQEpFc47ROpx3cAiPUntNDEnin1e2r36zqjR93yAG67ReM7QakO95k39ftFNAF9Jp3zPU/FK4VQ6p+1EwAAAABJRU5ErkJgggAA";

      var img$f = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAc5JREFUWEdjZBhgwDjA9jOMOoDkEDDX0viPL9pOXrtBkpkkKQZZTHcHYFjIDXGz/NfrYPq3vCGYfvbmByRgvqIGEKEQIRgCA+YAuMVQH0uJcIA9qCksBAmBm3vB9GXtMIi4pjiY3nPgCEqIvHj4Bsx/+Oo1Vs/iDIFB4wApeU6wD6TFVcF0KO9WMH1FJglMP718DUy7C54A0zdOfAXTO0QgaePc2SeUhQDdHYAe9KbaumAf8P15C6ZLAq6C6Z4N2ig+3/neAsz/xCIMpmFpgmXNZDC/7aEo1pDASAODxgHyDDfALnbmBlMMf0JyUeIcFhJ1W+wgCqAAFlJ3zkFyCaycwJUWcIbAgDsAlvhg+R6Wyld/9kZJEzBxWK44uBAS52JmkPLh6cvbYJrkEBgwB8iLiYILcwl5EbDL0XMBuo9hqfyhujNYPayEhJUDsDoCV4mIkQYG3AGw1AxziJGxDFgIVx3w6tQqlNQO0+/x5jyYiSv/w9ThrAsGjQNgaQG9/of5gPUhxKew/A4TJxT3RIfAgDkAPS3A+DAHJTFAWkS4UjtMPa52AMEQGDQOgDkEl4PQ5Qn5GF09wTbhoHMAuoMo5ZMcApRaSHEUDDsHAACl5Vww3KQdMwAAAABJRU5ErkJgggAA";

      var img$e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAKFJREFUOE9jvHG06T+fmB7Dz28vGUDg55eXDCj8ry8Z+EQR8l/f32UQkraCq2fEZgBIwdePdyEGUmoAuo0EXQBSIKbgBncBugZ0F2F4AZsByAYSNAAUiMhhgG4gUQYgxwLVDSAYiOjpgORYIMsAlISDJSUKSSESFlYvoIc6clIFhTqyAVhjAa8BaNFKsQEEYwEj6RLInViTMnoYIGdndC8AAKMLhKB4CiI3AAAAAElFTkSuQmCC";

      var img$d = "data:image/png;base64,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";

      var img$c = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACJCAYAAABpXHdXAAAAAXNSR0IArs4c6QAAIABJREFUeF7svQeYXFeZJvyec0NVdVSWbDnngLGxLRyxDbZlTJhgMDAm2hichnlmZ3Z3ZvmfnX/ZYXdmlmUyOJEzJod/wAxge4xxzlgYy0EOspVaoVNV3XT+5/2+c6uqW91Sd6uVwIcHS926devec853vvR+72fw8pj2DPz43f/DFVkOEwW48Av/w0z7Bi9/YK+ZgZcXd4Kl+sqy97nmuk1oDo+iSDPAWtjAwlgLY3TKnHNjPlnkhfwudwWCIEBtbh+69luIt9963ctzvNeIw9YP+ju7eF866Z1uaOWLsFEEE1jZ2NZY2LxAZg2sg/w/Nw6cJJGHbc2WMeAltnDIjENgLKpdNdSbDeRZhrhWQyWKMDw0LN9x1caf/s7O/d4kL79Ti/TN1/2xW//Ar2HDEBYGBRwKAwReAAyMbm6vHXKjQrLdYQwyVyCKIuRJKtJkoxBRbxdGtgzLPYxx6O7tRbPe8NcAyB2qc3tw2arv/k6tw3bncw+64HdiYa6dd54rAIRRCJfzb7M0qDW8MJkoRNxVlc1PMyxNEsRdNaSNJvKmCk11Ti+yRoK8mcg1Mvm8RyNFddFcXPrUt34n1mOWZn+X3Oa3bkG+c+Gfug33rkBmLQL6BbIJ/UYc5zfs0Awbg7woYK1FWInQbDZR7e6GsQZ04JujdfFbqj3dIkQUCApH1mi2hUMeyy9B4VSrhQaumSHq68L7n/v+b9367NCc74YP/1YtwHX9r3OmEiOnicPNVzg4296A3LzjneupzHlrE6u46TCAsxaVahUuNGgOjaJSq4pDT62QNROkzQRBFCIMAvnetN5EYO3YZygFBBCTj8/Ma3JATL0PbvjJb9UaTWW+96Rr9vrJ//5F/9WtvvUBWBvAdW7gSWZZ9qPjJm5fQMXC3/Pzavo4uDxAUeQw1iGIgahSoGtuHVE1RRg5FKFDEPWDopgMAQMvZHBpFXkOVLu65H65S+EyJ1qDdzcmBA28gKLgcsBY/nq7g8931cDLgrLdidoJF+yVAvL5497uRl7YABtHMDmdaiCxdKi3v9sMDRnj1EFPHWxsMHefERz/h89h4WFD6FsygjB2QEaJoRMvsSnAUXAKEayCES5bhbEUiAR50YQNazBBhKDIMdoYRlSpIKyE2PKSw5qVvRh4pBeP/vuBcIlBFPC+maih7T+xfDUC/odCZ4Cr1t28V67bTti/O/2We91Ef/6It7rm5mHA+xdUBjyubaEmynZHQeGwmLdfHadethKLDtuMWk8u/gSP88AFgM3hHDVSDksB4d/p5kuol7/nnyFs2AOYHFQG3L9i13EXZ01kaUM0hkUGw89GBslgjNUr5uLpuxbiqdsWw4ZiVG33kXlFbg2CglcbRN0VXPrsy/7JdiduFi7Y/urMwpfMxi0+c+RbXWP9JgQ23IYppSaSExOKG9rCUKvYAkUWIq5kOPXyJ7D/iRvRM78Jl1FUjJzKtPe5yUVfiBkm+kLOeFEizImIZWbl9yIrtgJjI0omkKfIiwyBDWCCAFkyImZWYAoUxiJwFs5m8nmEDs8/shBP/WwRnrl/CfLRQDUKn1ueQwVBxK0jUlbOIwMDWZZhzuH745K7P7vXrOFs7INdfY89enK/+bqr3cADTwBxKCd85PMUsmEnGAYUngLGFMjzAouOrOPoC57HUa99CXlqEPCDVo97W4Qowhz0hukYo3cOiu75sN1zYHrmiacgKqHI5JSX4DBVBawKBxULv4vZcwQwuRXBCOIuFPkWZGkTtrER4fqn4Rp10XD87oJapqCYUGB4SwMT5diypgsrfrwfHv7e/rC2oJ5QP2Wi9/SOPZ+BeZxqXzfe99S39+i13NUbe7a+b4+d1OvmnO/COJQEnERpCycnOP2NyTIZ1jqkiUHfvAxv+Jt7MWffBtC0sCYVk4hbmTrAGGqBHKY2H+hfJMJhKnO8GUVx8O4+NyIVEU91ygcFSWaM0tEWRp76QdgLUHugQJYOqwagwx/QCsvg6uthVv8GppnTYuPNJDvPr5BbFha5zfHrmw/CQ989EEPrQtiAz0KTrv3G7YhaG+5ibIAiyXDV5n/fY9dztjbsrr7PHjmh1y99g2MuYLJBJ1sdARpIBgXNKRgsOGQLXvWHq7Dfsk2IjApDaxhu3RygWdQzH3beEqBnoceQlFiSrb+RMiFOuZg7hKXEclGR1mlXeS1CyY0hG7VIWyc/NdaYELHLkTcGYLe8CDOwEU40AQ8AqhL1oMSXKQyevGMhbvmH4xDEBbKc+syqCThZIMIYxD01XPbMy1n52RSiPUpArlv0BseNYgva7ZO/Jk2QIg/A/x35+hdw3EWr0LegAZunKOhE0/cQH4SbzcEcfDxcz2LBWtFsEQ3Ba7jrWzFe/q603dQZUb0hCQ+5zIYRkiRBGEYSCcuzFNZvcgRGnXG5b6dg6HuIW5RTZYRwLkMh1wcwyQDyp++HpZIzNA9VWPiUjMolsHj85qW469NHij/D3082KGKxhAUcrnw5fzIrcrJHCMiXjnmHa6zZiIJZaO8Uy0k6yRB8VGxxzIWrcPp7fwNkkexj3fhULNyIFWDePjDzD4ALK2IW+UgpHO2eglqhbeOXwiF/SmjMD69BEAQSlRJzKojQaA4hjmNVLy6Xe1OflR59pymkEmLE/6AQ0WxSQ03NObg68o1PAxvXwDYpXPw3+igFg2QiyL/49OF47OaDvB+09cRQk2ruxYnQUqdetf7lcPCOSsluF5BPzjvPhSFP1c4TvIzeSD5Zw6+G6TXGcgsc88aXcOJbnkatnw53If6JGFnWSWIO3XNhDz0JuQkRFJnusLat5Tex+heS1+DmEp+AQsRdxnumcEUDaWMtkI7CFBniOAJchjxvomDQoFLj18PRka/MhQm6YJgPiecDgRUwIgVGnGk5+xlm8CGxiVauGEXx1B2wiZpTPCwULKn+zPoXu3DndUdi3a81Qak3prZV36dzlJGuq19GDe+QjOw2Ablx4QUCIJzMpha7nDkGHrtBhiVHbcTplz+DBQcMy+8k403BsBlcEcD1zkNw4IkeXsINRv+Ae4jWe3vzEHqiZlYoE2eyQRT1dcjrT4t2iGwvnEuRpE1EcTesh4mI3OQpgjCGKzTbXoig1MU/Ee3B/xNKwtyHRNQyIKjCRfNhqkvg4vmwokYmCTNwRvh8/Gy6EeaJe8QU5B0L0TyxRMIawyFuv+EYPH3HYglhi6U4TkBKDVY41Vcf3PDj3bbWO7RDd/OHd8ukXT9vueTHaFJJnmKiwU1UVOBMgt75KS654Q4UmdEQKB0U2f0GeW0OzD6HwPXMlW0i4VQKgInEhGFOoROyzs1nkCBPBmCHfgNTNDS2RRNIzLMQIROAEmItkGWJwFhMECJtjMqThgE1XiKaI6TPExSieSQixYSjaDsKSeC1h8+Z1w6Eqy2BDfonfGWJ1/kVEXNx9EWYNc/AjIyKFiyhNCIMNsSz983FT/72BBWgTh3Zge+i0OdS55Lhype1ybTFbZcLyGePfptrrt884YNy80ZIkdIHsDQiCpz4ludwwkXPIgg1qqVnt1rweaUPwZFnAHnSOsPLG5dOPjUINRH/5DYqRlbANNbCFIm3/3UKuMGKgtoFiKp9cBpOQrM+LL+Lq11idqVpA5aC7SNUtN5EACdLzkzwpi7shZl7GkVNI2GSmJygHovnQJGg2LwSZvU6deJFnEuRCPGTjx2LZ+7dB4YCzefi/SZx4IICWLr8FLzha3+9y9d92jtzD/nALpuo6+ae52wYSIRl8iIkxUnZOMH7v3Q7kAdwYa5JOKQiGLkNYI96HUwYKD6qYPiHQkAHuh0alhOdZ246jHzLXQiJ7BXvV/FUAjgpNOknwS7JdwikUASFjngYV5BnCbKUqNyYgSrkGSEkCtpVz0bUxrSWUxxwBm6dEUQwFpwKZ2qwYnSOG3S45SsMsOnXKNY9D5syUsYHZsSO05RhaE0Xvn7Nab7GZOLH4bzTxIzm9OCylXtP7cn33/Jf3foHn0Bz4xACFrvRcihhRSwl0JrPVlhff3JgYAVphixNcc3QrTPa6zP60LR2A4BvnH+NG3joSf1YK9m29V24Mfc7fiNe+ycr0NXPwiNmqhn9KcRxzrrmIVh6FGy1X/0ISeRx91CAFPxXDtdcD9d4Bki2KFxEwr8+aiWCQNte3H4fIAhgmeMIIjobUvDEeo6oUoUjRNeGyNMRwKWiQTj0jyngv8a9qggvhUOeiwDEGKZ2IGzXwZ2GktdrlGbN9VgTIG8OwD71gI+eqedDM5Kuze03HIknfrSfmHwTDYXVaJSLQYQrXvrRLln/6e6X8vovLXuPG3ryJUgQx/thusY8ZDWQoSvQXgONDHqNXEKHfPWoyzLMP/oQvO3OT035vad84Uxf8vPHvM01NgzCCRhQh8b6uUG4yR2KIkQQZDj9/U/h2Aufg0uDlpPNiaCgFPscBTP/QPUvOh6Gm0NS04xA8VQvDIpkNczQI2pWiZCVE6jurGqKMkeoNSJB1CVayG99ebZms45qtccHEgpkzUFf7mHa+Y+ZTswEn3O2C5h/lphdRhInfP5U/+6HIFbWPopiYA1sQWCl5nQk5hUEWPkfC3DbJ46FS/n5tERQjsF0KY7MoMhzXD2w59XGf2LuuY6HHwWD0cLZGCWmjdG9noP3xSV3f2ZKe39KF830Aa9beIGAxEXCO5xxfVhu3Bg5CrziTU/hjHc9DyNgPipPNbWcjeAWHQY7f3/ZsA6RmiGd9j7tBppK2Sa4TfdqjoH3EVNdI2EtD9YDEHmCB0EXiiwVJ5ynUlzrQ5omyAWFGyCu1OTPpLFFhYEneGlWlcnBmU7MJJ9Tt4c5HYeiez+g5zDYnPmX9geoMEkM4WwAJMNwK+/yAQUih3MBRvLwufl/Ho/nftWruRs/Wrke/mwNKt01NOtNXLVm92qSb599tdv42NNiDAieoCxjngCoOdMpLwWkFf0kAtwafHDdtqN7O01Abpi3nIhxAQN25t3aWkQz1Of+xUM4aNkG8Q1o9PC05yK7uAs48HjYuEuVptRgFCh8aWr7SB1FPvwUbHON5hz8teroqPC0JEQEhBrLIgi7BBqSp01kWVMEhAvTbAyrwFRqsEGITAREISAUFAkRzNC02u7iSoKPeRMVEtO3DEW1XwSivctVWOmuy7UvPgq7ab3PF/HwYGg8QBEWuPNzR+Kx7+8rZcFidfiNpygdg7i7hsbIqISod0eNyZdPeo8bfOoF2EqsXAE8uOhT+cK1mVR/bmuOW5RN3iyTiGfhcMWmyTFsO0VArp1/vqjIsYNmic/0yiZ26NtvBG/7x3t8LYeAK2DoCTPZd9x54z5OPURTqoTScqPkcOtvgXV01LfjDniDlZlmjfIYBHG/fCxLRhFGWi7LXAd9ENIBceTJkIZvJVM+vWjVdgVi26uJnAJZOxim62DNqxDCIslN9b0K/hxYFGufgl27yoe3vf3oH3rFrYvxy389GrnACCjcnEOKlkPc0+UjXxpnuHTVd3bKfpjoNa+be76zkZYib0sQZFk9BKJ1+NG6ECHXdxV/rtxvLoMVOI/EOb1p6RPOHZxmoqzp4FcriKMQ75+EWWbWJ+STiy5wPPHEFBjjv9JUKARfdMIfrcKrLtLEXJnGs8QnVfpgDjoZLrawon46hq/kczZEsPk+IOGp6eu4JZJBU2I8wNHb7iUaV6JVKiA2qEhugxMZBCGSpCHZ9EBAh0CRM8/BHIikLCeJw+6QCGz7w85q/EH+lwM9x6Do2l/NPYlha/Eu39kzdwGP3wmXj/ikpd6e/gln+UtXvRqNLTypqbi9Wcp5C32pclagiEIsOfEIvPXf/mnW9wWf5bo557ogqiAjNEd4yLb/Ndz4jPZZy2iURdRVYM5+DRxx/rPo3ydB19wR9M6hUBDGZzC0JcTwui5seqYPD333IIxucQgjzgGhOzStA+ELkLMuDBB1V9EYbYjvevW6rU3N7T/hNPbAJ+ef5yRxNi6yoCtltATbFLj867eKKUXJl4y0HIsBcPQ5UlNBXLuEMTsGoy9BESNvPg0z/LjPPeh9xY6bSIV05APa0SrdNGHcgzSpixMYxjUREvofhJEQJSIBX9EcFJCJkhTTmJgZXVoujSb6OFeoLIDpPRYGFT3y5ST1RVYeeWBWPQwMb2gFMkThOIPR0Rg/+sgJ2PBslwZI5FBpB0dpibKWnmZl9wEL8LZbr5/VvXH9/PNlQiUX6//cngnFuSdSKIgdFhw6hNMufwIL9x+GjQsYWhmyMsxJ+eikL0+Q7zEpiryKNb+eg0f/bSmevW8+wq4qgjBAYwtzW0wnhEKqkY40ZBtVurpw+XPfG/PeszYJ18073xWhHWsvS4QpBLUDq+miSowLP3I3lhw8rAA/Xx3IGqZ8yYEIFh7e2koexidaR1Qskbr1XyMYZcJs4kKiMfvQq13Jphe+tNU7Q1StcaUfzeYoipynj0Vc6xaByJqEsXveql1tVk1FkIJuOEa6JJqnODWtnmwvZf7Sb2A3Pq9hcF8OTKhKM43xs//zSqx+dI5HMStqmpHCoFbxvGE5GvUmrpmluvfPHPgHLhkZnbAysjOyJLU28g6a2EWRA6HF2R96DAecuAGV3gwm9RWjPmFc+pZiXhG1PU4jSW6LpmmY4qcfeyWee3ApoloFWbOBpNlEaKuIuiM0R+pwWY6gu4pqGOJ9T7dNzVkREGqOKgIk47PJksXmgxeoznH4vY/ehb5FKWyRSHGRggMt3L5HAHMPRNBRQScnn2CeDFxgUGy6FZZmkHjMUxOQUmuQXEFMKx5H4qQXiCu9gm9Kmw2xx2vdfbIoWUI+K/mkbNeZ5jqmstdndo1B3nckbIV+CXd/6Z+3l5IHj3nkZt383tbmoQBbk5zRF97zOikPbjYShGrki7kRRJHmfwqg6+DFeM+9X9ih/fGt5R9y6x56Qis2tzGUNywEAgYYgL7FCY55/XM48qz1qPTWVVlyH5T1M/IuHQBUya0xq6Up2HLwYBVrRggLIjz/qzn4xQ0nIKnXkKWZhPG7e3rl3iIwlRgRU259MS575Ovy7js0AbzB9UsudCYj8qhA5KwkospB1c7Tue/AYVz0d/dIFEpsSsErGeRhDHv02Rq2pLnVkZGWV3UNmC2PAek6LSrydeaT1xR2rAKjIXLPACbsUpuTwpiRoKGJNM1Q6+7VWg8KTdYQn0MhJL6wdodnZ2YisM1P0U71pkTBKsZ5zJ6TGKLNt6V+B4DRTXCrHhQNDmqeIJZCrzDuxj3f3g8PfGURbJGhYK5J5ocncSHZffnZGUTzunHZE9PLul83b7kLAotUSpIn32TtenuHw85eh1dd/Czm7DeiaGYwUaxlCXqTEKwco5XiKl2wvfMA8gFw9Ya3wI1uQkBUBSswy5SCx6+JJuFhGwWwtg+3fW4pnrnlIASRxcjgkBD/EZRaNFP5PxPEV/hSgR3aAp8++PddWk/kwVuDkZVcmUE4y/P3H8EbP/ogqtVM1aY3q/IgRnDQiTCV7g6zSoXAFBZFPgg39AiCdMTXcUwzYSQQcw8biXuREiKCQJJPijVxoj2EtV2Shz5zLz7HLoxW7YgMuRD5vGWw0VyYIkfBMmDLeW7f1NVHUDx9D4KgCoH6NBNEcYx6OorHfnQQ7vn8AUIoASMgoK0gZdwgV0yj+Oq6RcvHA4vHvKEeRz4sKFZVjiNe+xLOuuY3MBlhJGVys4xuebqlWg/cvkfDVHtQBJUxFE+FCHYOM7QebtUjcoBQY9IAFeOaPgl5ACIyXwYYrY/g/q8ci5W370vLHXmDARkWq7XF4Sr/zjMWkC+/+lI38syL8iCdQ5N8FHqH+QcN440feRCVLjJ2ZKJGHc2YqIro4JNQVHrG4I8kmicUI4BbdwuMaapDKdCM6QqIVkjw9Agrc4QEjj5HtUpfQ1+b0JMiTVCQ10oAiB014jOAkOzIXp/JZ3VDh8jnHI4gPhCpyRCkbUSwsDnyFG2MIHr2YYQ0aw3QrNeF1ijoDvC5t5yuJy7LAhhJ7LQAxAFWh/6KDdsuvvoGCTYefkI2oOT6Jpg/SdJRqzuFvBx86gac8u7foG9JApPRJ20z0mhBqIHZ92CgbyFQ6ROuMrV72iawrKMceRqsKDb8GtiwGkWu7Jq6PfWgDGPmvixGRwYl13brP52O9U/MQ0pC8aZyKnMwiBDXKrj0ue9PIc42ycpdu3C5QH70pTqFROGtvYuaeMc/3y3RhMAReq4PkFFzHEU4hX6m022RSR18HEie97+ncHhndIYConF2Rq36PLwkR9YchaWTS8CjJ/HRaJXPMUxKCzGTbbzzPqNZc5oxnmll0RtbcBnycoVhBYVlhr2QgyB56h5ELhfznU6xFHrlo1h5x7649Z+PkkStRgR1KMuk/iYQpHOOKzaOTap99YzL3fCKVciiQHwNFahy27bfXSJSRYGu/gxnfGAlDnn1Wn1u4SDTw4kj6w4QHnC6UCqpmPnyaamPUOEXNpmOadWAjo/JMeBTNGAH70GwoSbPTHI/+laBjRCTKlaIMMgdEOLGi0+WEgURMj5EuZetxZXrfjwzAbl+7vmOjnM5FPiXyalED6/al+MtH7sX3f11gUkJ8FSccgtz8Ikwtd6Oz5aA2ADF4P1Ac634LVPyM7a593ShqH3yjLHwmkx62hxqhYWltoSCIdG2slx2523onXNnf3LyPeP9YPuPB4JQpk+qMGlD8FSUMHYdjZX3IabGpLYoEpAMlUr7qXsW47aPH+OxWzyhSxaYtrDwb2maom/fRVhw5CFYdcvdCGPSE22d7NPd4YvGxBd1OPb3n8PJb39GQLY8oCipDJQISro7gllwCGzvvoqtm2i0ALsqEGV1pvKZ+XJr+uNseLT5AdhmAreJOS8r0ck84+EQIKpWPBbQ4POXHieEfoVEBTscf2NQ7e2evpP+2f3f7Bqk+O9oI6B5gggFGpKV/IP/exd69+Up7WBzIlG9qj7kJNiueWOiUMwGMxGEIkWx4RZ15IutS0inv7kUnqJmFk+2WACJJHQjaYIIhtSctI7LWRDK6T/lDn/Ch3f5ngQdF/FCxPOXwRhC9Qsk2Yh8Ra3aK9jlZnMIweO3aLMgX9MiefU8xmcuOUtwbC6vwaI5eRGW2KJ0WyYn16B2MDQxCHspciw6tIE/+NhdypGhnoGicqnJqlXgsDM0MuXzYxPLR8mprKF7Jd3otEIMElZQ5hmKLXfLvspGmohHfVJYKJnYikIJMnhA3PuNg7HiG4chC7kP22a84MNzYgOnMa4jhERodsZGJkSt8qVzgyu+dYv4H4qi1Swtw7XulefJpCh/btskE8kdvAdojopjr0rdM5JM49kmvrQtJGIGkrZHvp3mHk+x8kWmD1nf4Ueb8Q10E5WjDGWXTJAk3aZJVJl/Kkz3YikTSJI6KqyfpwmTsmQ5QfD0fcTYCJmeku3RBAowsLaGH/33V6GxhWZxe3Q6sBqe19Br57N0vpKATdMQb7/hdvQvrgOC0NbopUCOFi2CnX8EjCXxBVEDKjJK6TTBthRHOwHSYSAdgGmsVhSBmJglPFvieWK6Ma4axv3i8zr6I5sC5HkuQRqS+rFsQbzULMKn338mbDMU4GzrvKSwsg/ldNbpugXLW3PWdnRV2ZGf4Lg3PYsz3+vrPvj4hCyzJdm8fRDue+yYr2qVl268FyYfaHFDTed5pnSt0pxs7VWwLkKzBFO6zR5zkZgfutE0QKK2vQh7WFPyuoJ1Qg0E/cfCdrNEgJfT3MpR5KOC30KawD73AFxzqFXfIhrXhagPW3zpstfI0WwlbKrRpslGS3hKnJxoiBDL3v04Tnjjapl9+qqCmeKB2NsNHHTmGOFqOdr+3bxTINEpV4zAEFo0/MR2loEmm25RWg1BNEd9GwYmnq+L5UIH3NKv9d6FCR2+etUZGF5PU3Fr027KAvKlE97phl9Q/NP4QbaOfY7egDd+5P5OK06r8yq9sIedMobHvOUQEbe5/qea/2Btw87arGXCyNutrZf2iac9ZvNv90E8X5c/uNX254dowkZCe6obzSFv5MhQh+1ahKjnZMltZAWRu4Gc4Fql2IR9/D861USrDOG2Gw/FE/++VPmIfX5kwrXv7LIl9kKAOUtHcd6fP4w5BzRUOEg8wZwm0xZL9kMx/1CYggiLzsOpJAMMtRYotDDJCDD4AExCdINHDGxzjjQXJDaKWAwVBGG3gBaz5+uqnVhJ6u1q2QeRw7f//BQMrGLdz9ibKy3hFMa1C8733CATmyJv/OsHsc9RA4CLwaLacrgDT0bRN0eAh1Iz3dJfBsXwCmBUTxcxJjvrNqbwTNO/ZGzcY/qf392f8Jh7bkJLQGWN9b9IaHIwoVfrQ7NO/0qd32q1S2iHkqwugFDEc+B6DkAYLZFCKqFf5bSv+SkwWABNFQRJepflyjBoDAf4/KVnjTn4Omei05I44OQBnHbZE+hf0NBLygOIod8li4G5R4njzpC98kmOjX4yMVw0XoIdXqmMkz4iJreRS6eg7X3iV0RBEu5dkiAsnmcZgyaLSxdfQqUhcNOfnIotq3skYNDaoh7Osl0Buek1V7qB36xCmGu0o737qaroUBt88Nu3asJBH0H+K6r0Fcs7rudflY4HjeeBoV9rzJzJw5fH9megdMbFRmfSrypTnZBUosgRd/VKEjDLmRC1qHb3CXS/IKeX5HcYqIjgon4YRrqYLSdf8NCvtGxg1MCMeHtEstc+iW0s1r3Yhce+dQCeumsJisRH/XguUzPn/K4Ub/7f92H+QUMCqC7DpbJJqzHc0sMRVPZX51wZLlpM9qR0Yi7HDf4GLnnOY/l2ZE/oO1CDKIlerALygm99583AlmAD+OKlZ6PRCMYgmER3MBCwvZVhSLeIlAStMygcGBJLOyw+fAh/+L/uGnObnIJQ6UZ42CltefIZTf6bXfcT5bQKGDnYmxzk7c3WTvyIviV0AAAgAElEQVT3zmgVW7cHMWxUlVyG4IjiGGEQiwNauAxxpQd5NgKXa0BCk7dKiypuucT8GWJVoB87Ztm15PzyJ7f8GUn4U079IENat3j4G4di89oa0qbBksMGsegVA1h8+AgiSYqxdsCHlcSfiYFjToKxc5V0w4ediJTILUGigGkOwY0+BdPYqPkA0VWT8zJPbYZ9cEbiPdSUfDdvLilsq6XhRocq+PL7z5BcTCcEQHZlPgUn/bqFyyX4IFqhQ5wYsTrtgytx/OufHxtVoQ24zzEwC/YfmyXn7zl5A3fDZFR3hLsTzLijkzG1Kdsrr/KFXZoa82sgZIpMfLLNmzcW+CfLh6WeheyP7NowrCaM3wyaBFUoDxNkiogu+cV0cwtqWvanhdnQRuqpVa/2vYIGyyCth4GICaQBD4lczmVtj0HQezxcZZFPdXs+AJp3dTrcj0gJNcCwK0PO5QYbmyXfkXUr6Y9kntZoqqEjvS63vuuLh+KhHxyi8zE2bKf+2LYe4PpFFziBIbcEzndaCgqBkVz0N/dpQQ9T/EKYUCCr9iM8fJksohSxECwoZbQGbuhXCEafnxaH1PYmiKeSCLC0+9MQoTpjGtGQQ61EzO1V2kr7F+p53x6S07EV2KiGIsuQ5QliERZCSAZboVLmeDjYEFSTD1PU1ALwo09iYUYsCjYZUlJhNbuE/LHNri/hfM87IDLSDZhuH3TpPQpFbQkCxMpCPPoMbP0ZYaQc639sb5Vn+u8qzMgCmIH2PWRGhdwvx00fOgND6yqSiuj0cGj+V5dQ821j3DB/OV2MDgEpm046XPQPd2LefokQsKlTp1lTd8gyuK45qj4lxcmHyeAaAzCDjyILnPgzszUc8V2UEJqAciLRNFByNandFmbFsrHg5HH72Xqe2btPOyLDe1IwRItLNSSTnjXkKYnsRuXnMKqIP0ezSpOg+iSqOeSTU3w0+ollSwZyHQPYYmAS7ykz7a0NTgSRICSXbHTaHQBdmcfNWaGHzUNqkWVwxSBMcx0MqZgE2q4H2JSc7ik+9YSXiTtiUQwDdri9kcu6fz7FdRefhVDtz7EzZAyuXH/z5FATag9uuk6zSlhiTYG4N8d7b7xd6xHYE0NULxvchAiOPkcXkplaJggJODRVmHU/6UCM7ogTNnYqWLedJTGe/vFi/OITh6OosyLRoNrfwNwjR3D077+AQ89eL81oFGY0e8K5I2u33c+ydEDKUmOB6wuwMmtKsouzTVIJoSPNMslr8MRTBhanZcIlrmiqmqN8IIkBlxEoLqTPepf7q0TkeHhHy0zzUB35OrH9I6UsKtnH/IGpbSlaYantTsOOXCD1I2zGukHLvTuOenkGtqD5/LvO8VjCsWkG4vSuWPOjiQVE/I5WNKrTxKLfYnHW1Y/j2Ne9MObZxV7b5yhg/gFjHkRgJo2XYAYf2pF3HftdoiloMwZY8eN9cPcnD0NzS4SAHLn+cfXNiMMyuPAf78eBy7YoxEQy+ySB5kLtqf6PRmIyJrsCEisQos9wOPsh5sK8QiGIKqxz4UnMTZ0gp99BHJK8erkJp6o5Zm15du+NOgGHJEIaMgga4ywHYZh0+PXPluL26xh61iGmolaYtfqrTGhiMWPeGd9u3cAAvYubuPhf7mAfytYQSWXY8Ygzt0oIihO+/pcwjsme2RlkLKcNVxQxPnXWWbJvgoyl7OM3g2dUzA1eccnTOOXqpyRwIBF4hgD3WG2izrMysDABWENKtnkKSkAHmygR1lxnCEJF9BZFpsTeLVSy6PHZmfC99C6y0hto7pXARn0Rrn1mInz9qmUYGai1BcR3DMgCEjgovH9CAbl+4QVuooL6ufsP4S1/f69E8jpHwUKUI04TmpqwEyeUD8NtvltMLYb5ZmsQwv2Lfz4Sj9+0VCSeiTDpZTiJOaG127nAYS7/xc8QpRZO4u+z9USzfR8fpmRwQ3zjCCaqokgzBHEsZHehb+iTNgcRMnTrV1Kb+PB59hJTcranruN+xbpASrRZTNYK5wFoZiG+fs2pqG+qjp0nCfhwUzhcMfCTiQXk80de7OoDW1pfQ2gCWxQzknH2f3kEh796g9aZ0y8mcIGdWxcfBbfoIEFRcsdKfoNIz6FfwSYvCfxAWcl3YLRsaoOXHl+A737gBFhxGKe3yy/5we3o6WG1Iy35PdXE0pBniUTmjg+ZCVfnAMnoIAK2cBPSbpYJl/1JpuuQ78B67Kkf9eArCTSs6cRWlf1mItz7nf3w4NcO9YGl9sEd0KGncxE4fHCtMi5upUE+0f86RyqU9vA0zzbF5V+/XYkVmAAiLFpONwP3inNYkS5CoISGsZR+uvU/8aQB2uRlVoYx+N6Vr8Hax0lfU3JCTf3OR//Bi3jNnz2mOZipkD9M/dazfGUZptb8hBZ8GThfAVkyygu7armQe65KnOW52dbtiAxmaDoAOqGD7PtoYjGxb3jnOQgyRQJ0SoBiztraYysBuWHxhWJajSGa5rnFmHAlw3s/d6smmzxkPQ8sgrQAjj9PVTxzH3SMTIIgHYXbfKeHInus1Zj38kmq8b8rf56spYAx+NRZy8XfEFj9NKe+SC3e+In7sfSVm0T77bFD4N2lF0Eh0cy5GE8p2R7pXylVq4y9Dni5k2ae85YbuA0dWtVHVTlVqx/tx48+eoLUHDE/1mqjwHk1wNXr1bRqbcPOH64l810QeSI3/RctwrQ49vxn8ZoPEESmQ7QH241V+2EOOan9e99qoNjyMGzzxUlmoV3ToHlTLdWUuItAs33nqXGLLm51DHz6zHNQuMiHkae3yXmPV79nFV71gZVjir520nLt4G19taDPfwQhS0h5gGnbNxWM6R4RO/hIe+LHhQpKd6uYVhstqc3GDDrsWWHwzT8+E0Mb2hYS9xytntwahF0VXP7s9ycWkO+96c/cC/etQEzV03kuy4IYXPRPd2HRftqCjEOS1yR/2++VMHP26RAQnnwZ3MZbEUwWRhUiBo0mKBxAF9myn1/Bar+OlgUdG0CogCIKyHKPvPSoumksGoXvoNe+iOUfeVzQsHv28KyJJaRc2lhrdUtrFV8WEG9gyskqCIBii08OywGiM8VtdtcXDsOj3z3AAyZbJ4zfiwWu3rA1iXVrnj/Zf64zpGKUMtX2qUTn/MR3/wYn/QHJkTucHmuQxN2IDz19TCRAktYDtyPICXmeKJLiIdU0xigQNMlSUoDmiKtzULBJTZFoX3EpblFHXIibGTCwOW485wKlnpTeGNPb4rzPoadvxHl/+5CUjO4do8RMlcgEsWf3jkff6inbfMlj/mlHBF0waX5/rPWVorqRvZY1+MZ/Phmbn++Xqoq803z33bsYBb1mHCGFyFf5kGOrBUtTh5naAm/95D2Yu2hoDNkws+d24cEoFh82tkgqH4EZ+OUkocaSYIAdYom4rnpEao6kUUel1oM8aQhWh5EEic74qIT/A0Vs8OnTz1X0pQDMtomWmWATBTjuomdw2p8+IfxdRcBmNUpTtMcPtT/3+Mec9AHLtfIaUcGWHNojQ8NGMxD+sm6Ed1jXnh/FdxC7ZnH9Ra+VJCrto86hV5tJaY1ad7th0etd2c1HC1V0g9YW1PGua+9U7tMOl1+++MDjgZ6FY4JhReM52MEn4Sw7I42fqk6buuSs6pMXYDObsj7E5cT08PtYGikdPZRPiRRDAU2s12prAN+Yczo7xqUO5/1DhkOW15GPPoGwsUU7Xr2MKp7ONM7sWl/ZKeTSJXm2WNhqZs84GudpR81mA9NsC0ghfSALbN5cwU1XEtJe0hJ1bEz2SYkjXPbCDyc8eVq/HJ8cLDPpRy5/EWdf/rjvTd6WPibd7JFnwhAk1yE4+ZYHEKSbBCm5Va2HP0H4WQXfEQIcI+I9hDRAC/q9py6F9WxDQPChHiykLgWuPf0ChFX2RyfkZHp+BNk8LrmjQHevtjgrhh4EkjUv16XMbMtP41NqWis5BD+mmCwBRZADyzXlXm2YjL9mCt8gSA6CKTdptWA56KmxxOLmvz4Bzz8019ehj+NxywtcuWnyNnQTmljkQSVvEp31d336DvT0KOlzp0pgf3J7+DJlQvRwdzFV1v944lfqKPjRVuI1WBsjT4eRZgXCMEYYVwUvRQJpvqhCJ8oyyfaEPfD1w3DPvx4GS3yJkIApudxknJdCISDNQAP83k0GS45h/kRrIgRMt/FO2KydHJ3Cmrx8ybRmQKE9YpbbbpgwRt4YQiYsIzFspSadvHSttcnods0t2XYUiAKu6WA2V5SETtgmWbnIGEyIr11zCkY3UgDHPjD3ahFsv7OWPMcP3/ph98Kt97Xv4M1AMj5cftMtsHQYxjE+uHlLYfY9RtUjH4hZbZph62+eYOraOQ/VHuxFTuJog2aDRG6qNOiDSK10Rs1RF94qtRB9Gaf3uiRc996zMLQ6kroTbZFQXjnR11PVOmQuw5UrQyomeWxy0vL0Yb7GJpumteQvXzydGSgFhAsd+nyORcZcGfdCrVsERMws3zuwVS8ymfPeKgsskA8YBAkxR9ynpMIjvRRw77cOxgNfO1hTd52UPiUjTOFw1QSOeeebiYB84bh3utGXOtOOEh0WaX7/N27x2fN2OFbO8n0Oh51Xti1W1nYh/ZpAQEoaevkca2mcRczusQV7AqqAUDCsDRFFMfKM6X/WEHcgaDomipSbm1/ox7cvOxF5kzAWoSAbQ5vZ+ZKavLSYf3iCt3yX2VRh8RKGDxHOzXfApC9rkOls+Wld632PXHqA8JMRgkqP+JhpwnLhGlxGE0vLw6SZa1kPPqmAeIYXQm5eVLpbrQDk38mFFeMz7zwLSQ5Ucot0HJCVu+YD2+Ebbh251/ef61zUiVuhimO/vgJXffPnEyajisNPgYl7wIIlYSwRUbPA+ptbRF4K+9IhdidNNxsiyzLYMJauTtKzg1WHdNTZ0Eb6kDutlZYn3HZ06dtXnIZ1K/oQhAUKzxlVJjdDNmUwIQ69KMdZf0WmP2g/jHJIjqeJYuPtDCBPa81fvniKM9BBuUQfM2DruzAWsokoJo8Xk3aMaiqmTPrZ58pAsm2WfZrMgB0NgMGOPSIIhAKb1/bipj95deshabYJZFEdoe2ScZcflO1ybd9rnYm1aWVrU9JmL4CrvnHLxJv0yDPhwooKiDjKWpfg1t7cKqfUdBYb1jjYsEf4YcU4dDmyQsmsmbkvq8yyZgmhKImk5Xzf5krkJsCTty/FI188AgOPReJXECzJRqC2GuKg1yRYfm1FnyFnJKwtCCS2C0afBoZXjnHuprj0L182lRnwnYWVoJpsLBU56ZuNQRgbSvNUHpRpnRSpuZhDPCC3G9HyB3KxyUk/kfbeJbg2x88/fhyeupMR1o4hvWnYRyjG5S/8YErxcrnok3Ne56z0zfDyIZ1Q6f/m+OBXJhYQd8zZ0sBESMG8DyAl/GQsKZWltLzWbHlU7ZNkYJEXCCPWKDtphcXGJaJaWc/gQ63bPjnGvnPuQqD/eLieBXj2Jw7Dq+i0BZh7YoHFx4WIe+nT5HTJfblvW+BoFhYbb4NliHma0bCp7I3f7Ws6QvqeK8BGPRJUyZM6ciaDxWmPEMWKMaNPwuAM4ftjDuuJJlIiVxYiIB1RVB7qg5tq+NpVp4859NpkE6bVHGcq66MaZOEFbkyijPVPCFBbPIhL/vnujodtx69xzOuEDoYiKdSUBRn7CuTrbhZjJbBV5GxaYyLkkiXXppl5lkktQ1ShD5JJFVxZxzFVs2rMi/Ueh7y2HwIJjU3llZX9TyJfG26FYcMWH2iYyqdfvmYKMyDcuBws5PKLwurISq/vTZ+IkNhII5f0OdmGQU0sLdLdXkKUDO5mvS8P9s1gacUkicFXP/AaNJrkXGsLmo87Cf5uW2Hd8W8nT79VgZRv4TzvkGG85W/v2VpA+CasPWcpnwSDGVPTDxVrfyYagUzq1Bg2iJCmdURRt4Rwk2YdQRgiCBl6y1B4koHSzZ5uJtX1nYC8tkA64E6l5kT73NGJS2AHiE7WMtbt+TpT2Ba/m5e0SlzbkcrS91TTmWa4D6RQSGLmzWhl09bROnC2v4Mr61q273eq7Fm49QTMapsLBZk7PPmLffDvf/8KRAGpqDtOTJrTBdB9xL645M7PTuko5dfIhTcufL0jQUDnYCXnwiM34fc+8uCY3/PlJdN+9FnK1McQr9A9alof626RdmYUEDJ3899LdvGScU+EgPj8lHypmuibjlnV+UB5ZT6Cvldv1VRlst0qDWWaAyi2PAh20ZNY+ri2Zb+bO30H37rMknuvsdW4qMJwvlrsLBHmX9iKWXu8F9J225EGaJp1LUXdwJBtRWJLNONZPGbww/9xAl5aMU/KZbS9uA6e32GS4YotP5+ycIiA/Nvb/x/3/K33q0R3jMAUWHr8Jlz44YcnnLlSQHJpHskwb4CQVPYbb0Xa1La/QUgOWY2ONUfJIq5db2mKKT0POaumFq3a1vIRUgBPqemYiGK8olSvkr0MgXwIrr4aduQpT8Qxtk55+tvDP7fX4ltxzZaYotYJO/1v2OM/0YGDkx4j4nN6ZmzaFXFNzCdGQzkqXb3CVpimw63uwW2zaio4rHaqwQ2QvYaz7tsqMB/mQlx78dnSoGd80phQpSsGtt1GbqL5Nj/8ow+71T+9f1wbNSPFJPsdvwmv//BYDdK6yeGnAhEJf434GGTRpsPdfP67IjC6Cw3iak2iV8x5MOuZZ03fMFPNzDa0YAfCrGKKqiAUtoYwnAMXaRcraQ3QWC2hQ0ufqeWMj83rTHsz+rZniiL12tMzEEqjSskG78A7TfuBdsMHRGuITcG9Chso7IiHbZ6zPwejhwXSVLsHV2q9gqmjgHBuWtxdYwCYU5yzDdajdWlieZ/AOtz41nNb0KdOXoU8zXHNlp9NS3uIBuF/rlt4wTjcuArIPsduxhv/6oGJNchBr4SrLRb1Ro7eKOwX2z55/rvCOMIQnlj7GXliazBk4yBxQkrHvTSrttEjeKrrTeNT5FFZ4lv0mH5z6ox4ahzhZJJjrtXNaKpf076ujUgWLBH/oSzqY28OaV2caLOgcfCc6X/XHvwJ30VY2SyVDjWq9LY6RxUZo1QFgqiKVBDaGapdPSI8bOLDU740uWWNpgt3X8+UQSfuykorg09d9FqZtPHg7J6DluBd902/77sKSEdjHF1vFZD+paN429+PJaYul6xYtD+w4Eg5GYosELvSoQKz6VZl3GNbXjkZLBI2aRGTSqEErfaG052U3b5f2qFLZoOtVPhZYVBn2JKhbOZ4CjEhtNHYlHBFu/29pvMAmnOQRjUiJBYmrMIlTTGzowrxdKydT5GkDflZEsLcV1lDOgqrae2RDzOF768bm9im0dIcquDzH2B9UnuUyPQrp9HKeszn+cO1885zzGSXQ1IgxqE6J8O7r799gtkzyPsWwux/vBYztZC5EcyGW4RRPCsyCe0K4U9ClcoGih4U0pqUKarT6azfTr22I7bPsHZYEU3J0agPolrlCeqQJUrOzSkVH2uvfd+JJrOzZIFFb+w9HiJtDov2plnF3AZLX3MyzZMJUjrrStc/LadumdY7UIPTKSBi7uYYWN2Lb/1ZO3uuwSA9lK9YP33/QxQb//OJuaxF75BIWVSHODK49IsM244dPDyKWLmwaMnoaaIWt1n3M3lY/iqu9QuyMk3ooHf6HDswMTtVALZz884WBIL8DyQTbBjKZviaXFXs5punvjBHqYV+q+rHO6JVCNg5mIBRFrxps1BaDFEUIQi71GySFmoZsqyhGXJPJDIZh9mUl7fDxKLGYpuGtc/Mww/+24lb71cAV+2IBvmXuee5iH3r/JBecpYnocU13/65gL/YIk2jVXpRkRvYQ05G3r1QWBNJohCgCbf+FwiiSHyOImGvCg3hzYozPuXZm8ULfShbXG6hNmfTIJV2G5CKRzdHtatXUQNsNesTXjS39mqChYkicHIQeksg6JVgBAVEzChfZEf+4CwZRRDEPqJPv9MgYIZcqHbKtN0014lJR59lLzYb2CY1FUsXtI/iulU9+P5fnNzex/75eRzvkIl1/YLlExScWsmfXfXtn3nHViMWYktKrdMc2IW9wJKTJelGEuXCpLDrKVBkF+fEaR1Jmw5zhhMzzXmc3cvZ1VcDAbkwxfPEpCmh/gfBjkQIRLFG8ThLSX0IPG+4nswnqRO6N777BDPpLQVloqH21MSfckoVyBk1pFZJh4Ro2wZKhzp2D8gRO4Nlakcei2EDO8KG62znRlqSAIMDNWFMLIdAWaSdQ5trd7pfKmv3uSMudo2NnXBvRmB4UmT4wDdvgWEnx7L1r49emEofiiCB2f8kBNU5yNMEhDOHAzdrT4ZWDcfMk4DTfZmdcX0aBEIyljUiPHnbPMw/KMe8IzcgiuYgo68lAEtGz4y2WrahEk9IL/ZOVDKfbi81Lb3pJIVxfpKlSxVzDzaW/BZDuULk5wyqXX3Im7QqFJndMqtkU8zSHDQtsFk1SqnRG6NW2ql1hnfLEPwOaRA+9/gWz8oPUOB9X7pVTwSbCOOJZEQdOxz1SDbczDWohzHiKrOXDaCxSpvqiIPjJV7EcJYmZmdIwYT3VJNz05oqbnrHGdLGS7gF/Ctd8ct7YFKLNCMLSyotzzjyjEnSThLp8tTb296/Y1KkNNZbEBIp19xPKxcrOZ9A+pSYkNqDLDWzFK2aZL0F3jTA9oqqIYQTK8rwqYvO93tNE9jlQV1ZPA/v+9VXZ5YHGS8gGugNxSx489/chYUHDMH5jLg0R8wL1Lr65LTIqglspUBQ4fU5ckasxjCM743C0cYV3X3D0bjvq0slpxFGkdbOO4fz/uppHHzOWjUV8gI2YqViiiwbEd5cjuk3r9ll0j/1LxK5NsI0r7uNfkWo5hSpnXyEjoVusDXxyfKEWnWWolWTCogBBtlaoyO7Hhjc8BZCoAipp3nfloc8zXDNNGEm+uZ+jNUgtK21Re6r370KR5//lKjRuNItV4tkCoYpRG5T2AUks2Y+oAFYdlmVfOoU0bVTX6udf+VYziZuiZv/2/F4+u6FCINQmPfKDWFcE2/9+j3o7mLbASpTQiqaErVqwWdm06TY+S8/wTd4lnnvdwpHMLFV0kWW+dBhD+lQ4SH5gvRgkUSwtyJmy6Qa/3Q0axsObjNdXoWbFHmEG956HmxIjJ8GDTrHTMysloBcv/j1jkRqgk72tCz8e09/N97+yTtQiQs0mQCT0CajBwZJvQ4bOpiFudaECEzej501MTttoyhZtLBuyAGg0P4n71iK2/7qOMR9NYwODonwS0fZaoxkKMfRf7QCp1/+rJrWQaHvLz38OpzyvQWPVZI50xFv9SEkfMpHrcIuyW0wrM0ajqS+WSpECd8R/gB5z84y6Z0YmJBOWAbFFnbKLY35Aj/625OEwcSS80xa8ekIyH9QZPjjTdODm7QE5BPzz3Oh8EMpfELRmMTwV3Henz+DA05ai7Sx2XPoWlRqXUL2xnJbu6gAQrYLKzl1Rc/stK28U27sozOKDGVpcEV6jjeyCr71rtPgkj7UB4clysioSa2vB436MGxqcfqHV+Co5S8iyEOtp6YYSUhzJpGanfJ2U7up5DgYhiUSQmE7OoivIlSduQ0mByNkrCEvCgT0OaTuh+/dGbErP7uz9oF2g2KHP9L9lGPlXYtxy/99pXQX6DRhuBKxsVh8yrF48w8/PmVfpC0gc851cRiKBpHEnx8k9T3o5EG88b8/gXS4IV1VGbWp1rqRNEa1CrDbIehTCPsOJ4CmtpSzeFXbjBCxliq3mvQFLHIuvMWdX1yKJ772CiRpHWmjKTCJ7u5ejIySXpUEeQUu//nPFAzJhZFoD0vOpsfZNYsvNaNbSecuDzUiZkqExectpGSZ1X/VGorcIWmOoFLV7roSmBCK811pPfjOu/zKtaVpDCR5gC++72zkrIPrkE3pUMPXSTNctXnqWqQlIF9a9j439OxLmvxUZi/YkOA7ixx1XHLj4+jvT5GlddENEbPH2aicNuzwZBYqE+LsNQKZ0RpP/0MdZHYlXJvZ8CCiv2XAVM7QyBC+f+kFyJNYSoa5HHzbZJgYM6LugOX/5xEsPW0Uka1K3sSkgzD5yHYr46b/wDvjEx2HBBWI7UbeHBEzOgirEp0iXIRddcMKy2MZWuUGIeaqiYJs89IbsaRG3fma0xEQmxsUQQG7hgEiDbG6oMBtn3glnvj5ojE2DDd6bq1EYq9Yr81xpjLGXPgv/ec41ovTvg4rsQhKCSWas0+CN3/0FwhY88FIltDkqM0ueBdi8BeRj2h67Qim8pA77ZoW4wZlgRuBZNo5kvqI9B7nRi9Cg4e+cgDuum6x2LGEk0j/lDH1Mz5v5HKc+KcWyz4QKokZwZlbHodpvLBnQ9/HHRLswx54xkwiA2hKh1VirEI064xSamJQYDQlybiYZjtfMCbaC/lQgGBUigyl5TdpCn7w4ZPx0uNa8jB+TMdZHyMgXz35fW7D8y+iu6dHhKM5Sh8jQKW3BpM4vP3G76MS1eBYSmu1AUMrS0xa0H4LW9uLzIoyK0xfi3B9EyBLRpBSP3MUAe75l1Px1G0LhBaIGqY+rH3IW+8uMQ028wmQmQJBEeKdDzdQDckcSX8lhWH1YnPDTpPzHbuxN6N4NHhSP76nIJN5BBY50saotPWu1LqRJ6M+UuXfmyd5i1N7Z/kb237DIg9gBvjdmq+hJlv18ALc/NFXtj7Y5ps2kuG/euPkdKOd37aVqvnXuee62tw+YQEZ8lGboFpBpRrgkut/DGSZ74/n6SGpPTysQly8hbvnFJnJJikJ7bghgrgXaZKKyYCIBUAVDG/ownfeewriCqH8TIAlSOv0O9Q0l8CN/ESGRu1JQe2y+MQAb/qyZ9tguDHfBDtwx0wecSd/phQODTxQMcqc0JcMqp5txGF0hKYkhaYLYBLQFzu1M+S7T3voSQMYyHUAACAASURBVGWRbTYIm4xA+mexDp+6+LyxWfUSVe0MFp1+LP7w+9t31ie0xa7b9w0urpVULKmQLPCUOPTslTj9vSs1clUST7Tu4B28+TnYI5qAxz03kuVZ+fwT0gGlgJDAgfmf2z9+NJ66eR5spYqsWUfSYH6jk9teRMJv3jKTqz/ypCKNxSveGuCM/wXYVKXINVbDDP1KecFmhEOaRVnx4Vzhl5SSaT19LdG5nAOPG0sbCjKkY142u8ubg626npnyCMzim/hbKQCy2Ow5soT1P8U3/vxMDK4OkTG62LHT6b/wcOs9ciku+cVntumPTPiP1+5zoaPTFVfISKFZoqyRoHAZ3vGv/4G+frYq6HhNtbMU+l7NYed44dgje260s+TUdRrO5uN3w9UKrLt/Mb7/p0dIFITEf4GJkdabLcb5csLU91IN0tlwSAWkwHEXhzjjowCSQpk36LRvvmtsfmT2d8oU7tiGiEg4X/AiWrYqFYFSQp0KOpeeeNpsiICIxZnxoGib1rrpdo9ZNfZFaVo5ZXjfHAhtKc3l5x+agx98dBnCgBix9nPycKe/wlqVq7eTF5lQQD53yEWuPlrXkkn2LMwygXEzN3PAso244C8fFgT8mFHKBOPn8zKQ0X7a7Z+msLw7fMkYooG2gNTrMe7+xOF44t/2E3i/NSGqtQqSNEWRtFsFlx2v+g+MkCQJRl8c1ymVuiUrcN71wMGvpRmmJwlh72bjHT43srs2VUdmXFre0adgNlzzH1G1H1ljGBnLY2u9WpacNpE7NhniZxMhI/EFzPqXPeIQ9IceEQ1rmIvi+6QiJN/98EkYWNnfhsr4HH9GIGkQ4Mo1P5q+BvnKie919c2DEtJMh5WhRC1t7VYbRQXe+6X/gDWsd6go+Vo5JJ4GFD0FbM/u2ggTiVFZCceMubayNmGA9U9VcPvHjsaWxytouAiRs4j6aVLwPQqkI3Xd4J6Bha3fjn6fxWl/oVXnTH1sWAH88LIc+RaLoDvHu243iIhzJ+admCBCIYZ+A1NfpYGe3YYy0DmgM05okGGxlw2Q0bdKG6h2zZFiryRpIgojBHFVun0VAsAsSd1K6L7olB0+r2bnBu2cSDFgYVP1Q6QphjX40d8cjefuX9KxRxUlEVQiVOf04T2PTQ5inFR6Pnfg77uR0XpZnyKmBE9DJ0yKAS75zK1gB4NIGp902lu6m9gezQinwx4iJGU1IFsEGyCLAtzzsVOw8taFkuwcHST6NFf1HFcQ2ABFk+QLakbJIRECZ/2NxRFvVJSBLULfBk774zWZ9ugqEJOIm71NtHBG2OTzgf+AdYwK7i7frG1aZp5lnT1Sgkq3ICBI1RTGTPzRWW/XcJC7TEndSoT27hTwScRJyLGUWdONGGBIuwUIdAgGm9b24BsfWtb6cGtHBozM1XDZqu9MKgeT/sNnj7jY1TcNtnr3lTqEGsQUBj0HjOBNH3lQmuuURJN61NIPLaT/HxZTzU05JzM7h8kYVVYKaPsZWEbQ3NCFR296BVZ8dz7CiEmmAKPDQwhaPVA0AiFFQcQW0QHMcrz93yP0HegFRoqlEmUNlAhWQByraBWpuRMcBJNTBezIs8DIb0q+vKkxpM7qbLRDubwte5fS1xDeMhY8icwaIfhjt6/SYiiyuoAwldTN84jtNu23jQmRNtCCGNW6pY0GpmBijtqSuSuD6996TusG9A4IKGXEMezuQlAJcNnKb0+4Ube5ez9z1MUu2TBJ3wyZ1BBxJcP7vno7QDs9tHoC+yHlNT1WzK2ggyd1Vtd+opv5U5p8wQKAiFKs/dUcPPDlQ/HCHQsQBgZxD80HTXQ26nVE1QoyhnmTTPtmE3NkCkTdFq/9O4uDzqUdTkofpRfSrFQiwiXdxHx+ndAThWymcGxSuuEWION1uzo/NBZCI2dXB5k4OaxI/0o8GQ8CUjMxEUhclfaLVGydwMrGgS2l8pU39AkQqQ/hL/cE4aGwJAGKjXx+luKKPYn7vnoU7v/WfmrZ0E9sAVMJoTEIqhE++Pz/t5U8bPd434q3129Iwktyz1Kx9IRNOOuDK9CziD12CXf2Jpei4uHmsF5iV9irPtxHWtMihIlz1AdDfP/KUzD4VC+CqAFnIqTGore7JqZWfZRdjhxqvd1ImwmKRiICEphQEkrvuSdA3K+VcpL38Owv0ljUVFA0X4IZXAHMWSb4Lfk9PdmiQNF8DnZkhdKb7mrgYgfBREkDqjxePD9ZEh0jCGto1If8M1tUunpk/ZRggW3MVOzlerptLcAumysJRNYbDV5j7gk+iexoz/qeKncWgwxJM8ZXrjwDSSNCGAbC10a8mZYKk0s6wAfXbg1BmZKA6Okz1peQULqL2m0DjMFh56zG6z60gnaFhg/93UVeFuwKCIoikdl7btUvF+LJmw/A2nuXYnRkVA79oEIbO5PeIYS0h9WqqFmZpNyhMUrQnWaG47kFzvpIgIPOZWiCWoGFQh6hK05JhKKxFmbwETijHX2LgHXp5KJNUWSbRZvS/3ABNesu1iAiICx0EoMCQUjStgQZmdRlpzOM3yuNa0gPynp6sq2T44vcyhxBM4RLCvLgSeK4bRmog25ig6KLFKMe07hH+JvtxjrFIOO5NIEL5C7CQz/eD4/ddDzyiALNnGcDaZrKwUctOREEZbsCwqm4buHyMk80qXXUslsJu0i1wm7ZZStx4PHr0b+kDhs75P3KmUqXSrQMUa/i/CnbYVuT6zlcEhq3Qu2CR6PwsVtUDhcWaA5G2PR0D164ez4e+NKhcM0MQRxJpMpEIaJqrAwkFOU01ZoVVgYCGB0aRchIk3A3ZTBZBfNOdvjDr+SwOdni6bh30CGJf6WwEqz9iQDl5M57Iv6sA0YDU5FuwgwaEKoubJh5hiIh2R3fk5StKbKBBmxDGvohFKbKKRjDYloBRVjA9BDSJvUAu8fc8oeC5He4TmvUUZeDAkQi9+DB7y7GA988VIIwTITmTT0MmPe7cgLurKlMAW7Y90LH/uJlje/4aevEubAvtQKfFW3JXrld83Kc9OZnMP9Vo5hz6CC6FpEOiI58KKa5qH2xX2m7e1NMIhDOl/oasKEonf88tVj7eDe2PDEP637Vi5U/3QdZk/0N2fKXn81kAxNywCozqs7IowIaI6OiVuOuqgjJ6GAdoVAZFehbanDahw0OOEcFQCI7Bog6fCphESTQYuhh2OZ6b3LvCs04hY06/pKWgPDssVIJKNxVgrPq8nufRXBNgYDbIQObMjLtw9fi+E7BLPaXaaGZRvFcfyFIi10+Sm42rhL30xrVomJyuQBhhTVMEb565eloUjiyDJW4IiUMFJA8T3D1wFj29ykJiGiRuec5ietvZ0h7ZUeUpy+8Imk1+wdmSiPEVoj9hwyjb99R9OyTYP5Rm1Ht46ZNENV8RR+be46GyEYMki1V1DdbrH14IUbWRhjeUMXoAJGlBUzo2z8XzodVy+fjpqemYYWkRVe/Eiow2dkYqYtwELHcHB6CSSyqSxzeeYsY1Zq6YNSGFFjjs8TZCNzggzBZIt9nfX/FPScf0LE4YwSEWLN+IXBrNhuokWWdi0GegS0F8kGaVTkMTUHPrqsWwRRC9CXVlf9q+cR8xi525cHRiY5gdIpBlgLBOpbdqk+S5pAaJp7BN158KrKUXME1JdeuNzUQweY647reTllAREgWvd5Z7cY5Bl6xPaGZTOPw92VEoSRAaV+rj6aIDlGa2zTvxBEtF8k5VPvYYFR/0WzUpW6D0JnC5jBpiPmHJnjDl0elXztnVEyKcrSiMZ6cmnb7yAOwzUEQx0MHvLNh/XTff9dc31lPrhxWNuwWKqdsZAQYciRjQcgQtVDClkGpEhnQMd9CJMhrdO012en/P4nfIdCPPgdUed8pCNqOTEqr0IuuVS/IjC1NQQfYs1JNeUZcHZoiGD/5+ClYt7JfoCmNEU8w4WMOJHe4crCtRaYlINfPO98VgZVOoR2IjR15tRYEcPwUlpWJMrdltm6ib/L185K38OYQT8JKDztcUQ1oeRM767rE4YgLenDMe+qYc1yKCjP+stBa9DVGQArmR4C8/jTsyEq5UEKENEFy/tsudrpnMssyqUoJK0yY1W4hvmu8sBmhNJxhuI45nDIZOsGXtBCw5TLwaPC9m8bX2nf8LEtGwdqHebNdIyDynoXV0mAE0qKNbRgICarVaEXkSJIUT945Hz/7p2MQGWLLoo5kNg+/HFd2QOGnJSCcvk8ufr2LMicsgzMdpUMv0RQNh219q/JXnqlyskNInO6YjjijEk35M6xo8qtZ1yahXZUaug6wOPjCIbzqylDYMMTW9sIjVveYZ1B/KE/XAZsf0gyHoQcioSqlYt3Zp+JMJ7elBbWQreRMZs4nQBfQrCAfZE2L5gdaCUD+SLqiMe+lZha7Bhd1i8ZoBXE1RdjNhquc8HFrN0ZANIuN2AH99DGnvdWmPgNCXq0WBC3HwkSImAQdiNBsjAo1ahRWfb+SFCODKW664kw0GUzyLUBL8Ck15ZXr2uHeGT319XPPd67Vw2CC95DTiRGjQDLKbYOsM1I19fcff6WcTuJjOEaUEdVqiK1Bwnj3UCK1K6+4rIp9zxnBvKMceoMaXEQBShCKI6/mQck2zx+1EY6GfzFwq6+MJOKSUJq9cLQ2q2/js4bUOJQCnpjs6ltaSWM3OWFE9EeefXABHvjaYVj7JDPNDFN7VS7EHswVVdC7eAQn/9HTOPCMDTJfDGlPOAjvYZRrYXkPntSK65vZaPscunbKo6DWP7nL6JQXqGxhWE3rW6SkIQikP41zTfzqhwfizi8c2eqsLFuCEdXCyT76441atz4jAeEHJ0sgyk0p0RJaZTyL/yWmSYK7peE6s3nxL6HLUMaUHNIU6Oqp4eALLJac2pRQ7aL9u4GM3z0qddUuJRCkLmWz1FgKvvO1GaV5NroaqD+tIV8RmJku4Ixfb5Y+6B1sbhSiBbYYuESJ3LRfudbrSDa5ZLcrlYctsPbZXnz3P50ukUPxH6ThnwIClVXR/53HSg4sPrSO3/u7eyclqaD2JfTDRQ6GoX7h690BnN4E/RAV4MAkYJdHIVs0XiKxRM1XvVrJA+VZXTTbulU1fOe/nIkgaANtua84HfRTSpK5WRcQnTzWnBkcd+FzeHHFHAy9VENzhL00GIcf63Bvz1Jplbf6J6Vf4ZIAJsoRzzU44k0WC08OsfjEEL37BHCZEVZ5G8dgyJlajNEbdjgi+lg2fos7uO1oEkwYMCMm/6bEaNw9e2SOY3tiJLvPiBNuyF9LOS/9uI4/ZW79+6qfZnDP1w/Br753sFQNSgbIMGTepvBUR90D3mlx0vR0OZa952m86k3PTfxknEzpRutbtnUDtodm6vZeZPy/T1TL47vcGiutKNh2WqyLIcCNsv1bJoBEBmKILRN0Na2NkRhfvOw0bf7ph8TwPPPJlZ75ZMYCIlpk8eudzaUbyIRvSk1y7n9+DAe8ep1qE4YVA0XI2iKQzlRJ3RLdgCzlFQHMQSehiCJUauwzYWHjAlFFVXRBe4rxM6nZEVIaWSzpRQGDRnNYwHbkasqzRMilGXyRSLhg13hi0t8g1GAT7Ma75d+o5/Y2ip6tJlxqgJXwjqd9sYE/CovBhGuj0Cn1zhkKX3n7Itz+z8eoQHh0wXj0xLa2M/MIlJ3a4mFc8q93KliQEUNZqo5tJsRiPklcdTC9zEoy8OEh69vSLB0kGzaYo+ZT0URGfraYPUkqSDaPIhvOEBYVgc6wIpRQAGLLysOWD0X21G9+6ExsXB23Xkv5/lT7lln1HRIQ3nl8d6rSlivVNwnHlv/lozj45AG4EtAm6lwXRxdJ0abSzqx/IcL9SPxFWL1mqmWOfeUbkxTsiegtT/lMzB7sDOI1h+XXcVyVlnB5wvrxAiT/k0aPDPUlz8LUn4FNRj3iTo7BSTfSdM+43Xa9MMyzghHAoPY9doxQSZhu68GTU5KeiHH7Zw/A4/92mJiUSrg29VEmifUTJJXLce6fP4b9X71eNBCVDwtgW0PQEHpQqQBaOOa/xJH3oMcJZXpcmTRihCHLwi0ajWHBjFbiXjRXjyAX55ss8z1CwkGtUTZQk9nglgocvvPnp2L9M0qnK/tWZFd3XNmRaocFhDce3+OwFBJqkMJmYvdfftPPFYosWCev2jsiVSIEYt+GyOYuht33WI0sSdqBgDO+smJm5L55hpzUk6aQiaGMJdz0pFcgZQ1Vap6KOUVBs8l6IFkNk2zQk4eLId+pKmaXgwmnvgenfKUbtcCw+oCyytuAfDChS935vf/3VVi3Yq6ui891TEdzdD6czqceaMf93nNY9u6noXjq9o6X7r8e/lHaWPJ9NcCwspdxkQ70Qvv+vgWHd8h52LKG3kaRhHIJG4mLHpi6JojF4XYOaUIycbUr1bz2Ci20+PZ/ehU2rGLz2fYoSUyv8B2pZkVAePsbF1zgMnE/JjMsC7z2Q7/GIWetQThJEkUWyT8RY+1531wEC4+Gq2gWmKtOXlguvJhrQlOTIc0UQRzHEVzeQJpsgRt6FIEb8VzBCs7TxdlbHe+J5MRr16aDE6gIyx63IU+FQUatYixefGwebv7fr0BBaPgkjqBoBw867QTy3bhguUsYPeQBtQ3zmuUAy//yMex/4iYEsukZ3Zx4/tWX8aUDhBURMsbofaVkzdEAgTQTp1ayVQSoIm9kCEZoIlgJ52ZFE4H0QyS5nbZgUI+snQAl/i9PDL5w6VnSRa2lQcQHcVJJW9ICzZqAfOX097vRx19ANonNq5VqVZx+6aN45RtemHgVW9LByeCj0Y51yOZ1w8w7EA7dCIMeZC6XxB81hVTp5cPSOLMYeQFkXRd0Jk8NXyYqGk2DgVM+jfeGC6WUYIsF6t4QldOREaOJIUGSDXcOK36+CHdce4xi3yQMOsmmDQxskuHKCYgNvnn+NW7DQysndbQFRc4DLc9wzPJ1OPkDv0ZFXKJJDtAWtEUQoQpkJYSI/gk3PGWLXcv4e/H5+4RmSTLhoUFV+tVYpI1BTY1S4MjZJaaJlvCUI3PAltVz8PUPnYQgaj8PI64U1DyZhSjWRBvocydc4hovjCVIawEZJbqVsPsnPviNn04iILqV9Z00fi1AX4Sw8zNkgoCLRTAadarOGBGpR3y+0WVMCiWa/BIKTd6J7aj9fWUuph062XNlJQmATeMTrWWYauvHzl0oGKkbLzoPCAjq1Pkoqz7GmBpCOxri8pe2LiIqr/vk/PMcUbETmWTsJ2PJPukrM/sWpnjHJ2/zJcfbmlK/mz0FblmIJl6nnG961MWkabLsoDwqh2UYxogIJZLOVso23woQ+LB++a3E6d33rQPw0FcOE0xdpwZhAjxo5rhicAfzIJO94g0LX+8EqVtCQPyF5c+Mdhxy+lqc/Scr1HmTE88gDxy7B0w4uAASwOoGXNUginrUsaa0Z02tD/e1DNrdyfPEtuRt7xcKx1PU92WRbT3igGHt/bfV6MhoM8IoWe/CoJ4F+PnHX4kXH+hvxQBbUyTNOP26GYP+w/fDJb/89HYtjE8tfZNjTQXXTuiu/fN0Co2sR5HjyDevxmnvfBIhrWPfQ0QjWvR/xi6+CIPH4bEykxEqRqRoUnM1w6hLBJj2FntE8t9tGKLk7ZL3kviPHiBqXoeakzMhvnHNMgxt6BoLWJZYjUXcVcH7nvteeazO/gH5mWPe5pobtozxR8ZC4h1Iu9I7L8EfXftLNYUy5fedbFAzl9h+098F28OXTVE0FTahib/S1CjX9bfDpBKORkL9CZ0aDIBRT/2/vSSS18SMzHzmktfAZaGEyqXBaKdZ5QWKpgw34FUbpkbL2blW1849zxEDxwOwJD9vncw0ryVBqTkUOtjv+fTtiOdmCPhSDGD56sTWKe8FRGrKoy5hX5EhCtJIZwGaWgSgMkjP5yYbv+a6tjarRBCZKnDAF688A9nGGCmfqeMl5NZZgSs3t99/uyfETMXni8e/y42sXjfB4aZln85FCG2K1/3FYzjg5A0ICtZ8Tw6nL6NNdKAKFyMkX3APkOZbtM10mfwrj46ZPvge+DlZuGYAN+zDoLJ5NF4vYzxo0L8DT/HCWtz/9UPw8LcOFSSvhDLHQyg8Y4mNI3xg9Q9nvCeIrpC6kHFRKAo46/vpI5SQHpZgv+qiZ3Hc7z+HIKb1MLEGkZgPNUhURWN0EFFEbaK+E4nfsoywF0qYQBW1u1c5LR3bSSL5zLdFDp++aDlMwEKkiOnR1opTCCnkH+wwK2c8GVPZRzcsuMCfcZMXJHLjv+ptz+DV71gl0stKMJoD4y2HtsqVEmKppza2iqxnI0ys9mabHrTMk0zlKfeca5RWVqMtLQwnJyJ3KDaQPmhb4CBFWBvGSXmayikL/Ozjx+K5BxfDyoZoL7dodN6OphEh7zC4YsPNO7wfvvSKd7jRNZukHoM5GDnzJrFwWRnaM7+Oky95BkectUaESHQM8WAmEyefJhQbGoWVbiTNumiSKGYY30+GMcjKxk4CofFnhhcOCecXIXJBYgOPfO8g3P3FQ7Y+uKWP3tatEXZ4Qqayva6ff77TDOXWg0sTMEQX5njz/3wIi46gNtlaQEr12gIA+2aaAoWk7Syt4LggTI7tpT6Hd2hF1IVLK0DARjaMxkhkatvvReeTTOc2zHDj217rP0O4jdLClu25RelILtFIf/trptmWbEprfuCbHUYSDbRMtvYmRER8VMAOVgb9i5o47i3P4ZgLVitMxhNMqHltPeN8gSxhdytFZJAYTurjJzSrQhRRKibcz689Bk/9fKlHYrf3Ynnm8MAok4Od77dLBIRfOFEy0cu6YLTYCJ6TecLbn8Syi1+C9Ryw4xdDVVIZ0+ZB4nuYCMN6DnQZuG6pXJ/KOu5R13g+eCFJMCNswqM1+yLwrRLYyZaMdfgOjXoFt/3jkXjhwQWSFRdGFQmGbE28QXPk/2/vWmOkOsvwc647Z9j7LnQLi1QJ2FLFtLUa06jRWqLWpg1qgkFJpW4R+8ffRv+Y9I8m/aEJFizGNrbaJpp4SZp0E5LWRCD+0Aq6oIbSglBY9n6ZmTNn5jPP+31n98wyt+3OsAu784vLmTPf936393vf53negTI87EYapSqoVZYANWCMBhnvWZGNnY+8g7u+cAEdfbNC29b5D0dKj3O8ozCjXTaT+JObxBzwcr71MlccC++e6cTvv3+fiLAURFOgdG7EgYVlXSCHe3YpUdU2xoi7URrtoDthoXvbOHb/6E3YQm1lxohJJLMT0VhJ8l+cCUouCP5bTySFVLSSoUGOSoZZC0Qs60euD0QBmLyZZL2NOzJCSS2jYrjwSrbgrqHdF110lJGqS6c3YPCZO5GbmiulWtJNcecN+YCTwvM9PLGEO0c9Njz6/sdUNJXR5SKIiBCYCSNyld1uyXkroHfrBHZ97xSCrqwkND2/VarXFkNKJ/LuoMdR83n4J615JZAiK4+xK2n89YVteOvEbRUpwLSHRPoKRRwYuz44ccNOkNiYL37oa2r6yuiccFfJAuGIE36sKGBm4/a7ruFT3/032tbPyupfFETaKFyw0qnVZgMpEn+K8h6tmBhjMeoZ5gY/Q1EJo/5N+IEaI32GkSriBzRPgkmwZJiyrHsqrikw+t9WDD6zA5PDHbDom1T4MJpFebKBBtw13otFDnV/TkmFrhoblHaaGJn04FJXwMmLzpnvRWjvV2jfOI4tH7uEdLsFPwhZ5wr5GSA7sg5Dgxsxcj6NKEPdL4aE6UtUjmZyFjxpYCXl+nTDFwgbUclQGqMVd4joX26QHu7ZcxYffYxZ8vlTpPYAmVPC7NRSX5Mbq5EeajpPukoDBb0R2igSfU14iCC/NRLX9dYJZ4FRuXlq/Hx+IflaAtJP/GobTv1hkyTGCMdRiiTw8oBDl46rXcR3rr62LOPOth/d8qgKjSB4pUboE0FzULTGsQFWGm/BLRZQLPgoiH6XxuZJnoOq/OI1ELhpkpQUDSnlV5WMTK1ybMtmKN5JiAniBVsQlBX8QroCzJQ++vQ/cNvdo6Ls6QjugCeN4EVrr5XEE/KVVEFAcZZn4PNGLE4SSnJmUznQRMIMmHHOTav4a8aUGjOtb8FGAjVmtYnrQD5/1oKa4uqnWFsgl07LyPXbVGfM04XQi0JcUvrXbhGK9zSjy8UL9+WhdvzpB/eIdldyl0zmnKRHsiIt+F1t2P+f3y7bmCdNd6T384rRM8njk9TlzNepr3XCLGrA5x42XBT+Xdw9fbcbGKu+WSy7sZ7tZoKJA69lV+JPySAbaDx3hRbPwt7n34Dnsum6NvdiPjHMXlPH4suhDRBy7RPsR+EoxtWN1GY8yav8SJJWLyFTm+w1S5KfmGG9EF0SQvvWvHhrvJHcpRxfiD6sBUj1FZZWzpPDwDApgw6ig2tAiXQXLQ8vPP4AcjNUtSR2KBJuDTFYSdvFf2bpY+YYDlwbXKypFmPWJT17pP9h5WYKyDqKubwlKeZUawg3GzFC2sfAO3+syx51PbSk3tfx5Wc37BLNtyRkLglVkSgDdxmWJLAipNsU7v/6WWz/9BUTzajjR+Znj8F3GQKNHBQ6faWjIlSLI5qUyRapPi9Z3mSIdOGv0TUscrGxlnjkQOXYGcIr5DiSAdc5DO1/67OJdFVOcApHs/ybDldr4lF8kmkqoNTncC1cOtuB489tw/hbrRLV0frAlLMpFZGIozJ8X/vG9dh76qUVMc7VRunojq+qwsVRRCm3KWF67kkFEvAyIb49USoOV61dK8Zwv/n4fjVx7hIK1KiqobvFcguFoo/22yex59BfoAo+bHOaaL5JHBZdnPtVc5kRVW1cunmQgsQOy0fGFma4DQ+c/rKcJMqG7aaEz0CSl5A4ZJ2aRUSIRpiRFPBrP96JCyd6RHmksgsSc1uo7hHhYBPyGzVt1IAHDnU9pBzPFV6HTp6KmrjeJM19IulhLgCmMwAABdtJREFU6IynMR03F8kbmW2IbqpiyYcI3Xd+AHuOP7eoOb+ohxvQ95qvePkTT6iRM+dFrqfih/NfbvA0YIh8MUBP3wy+/NOTsG26HPPav5VgGDUbUumBBCQ/4dPUDh0bPnYcmFTwBWPEJZeZnZLD33aoJbxO+AjF4jROPn8Hhga3oEg1I4cZYU/gIuU+HEhOmnwhwlNGkeM993GFffGX23erzNUJ0VoWIpQh12mCXUI1SmOOxFVnAjTo78W+0y8vaY4v6cvNtGPlxCJ/1bhDMTuIWByHJQxC3P3Fy9ix6yL8deF1dS2W3t5ETqUkO1wjw23S/8L6NRAJllm2HZ4eOeRDStGwdQ681gBTowFOvdKNf73aR0yNPhGlbJwgMst2gwEP4tP2n6tcLWnp/V8Zb/j1vfvU5P+GUQipzK7DE7Jh+i56P3gHvvL6zxo2rxv2omaY7lDXg4oCDAJv5GVViutVjls5TgFRmIIfZPHw03/H+q0TQF6X55KdRwOPNP+BggIN9sDK2iB2q+gi8Le5u7EP5LK4aeSjnLhR5Gr4gYdjP9mB88d7ZPDj3TL53oU0ArnnE0Eb5nHQKHE0YyxW6ztX9AJJDsphlmDg3cQcq+UHjD6qjg7xUk0YNC/Om++/hh0PXcGmDw/D9llBytxTmtl7SUgmFzPDSZQ+YpaXghI5qcg1drkVx354H2ZmiVItIDM+LqJs9BNjV+K6oIA5RXiyVEtyrdZJ3ch+N3OKNLKd8i6ig0Wko2ImVneHJ4VArOPnJJeikGor4JNPnUH/zmtIUZepctJ5SW2fY74ZoTU59cij97s15EHZePN3W3DmWBdmrrbBYoiZ4MRZShUZDp2Egq8/4vRJqHNDMW96SY1d+3JVC9xUCyTuCVmLgulhKkMV4YnAW33xc5Gh8Wz0bR/HAwND6No8y0QBFF0xk0uQBSY1EIgMjksMa+CgTiLGiuVGdZCQD9O4uV1foCwFqWwkWr62g3fPvg/n/hzg/N86gcx64fBkJqcErMfoXQwtiS/ccbRKw/i11iPhKE8mtGPX5ndzLXBTLpCkSY707FKESzN3UFdnxFEzBUBM6WC+L8p7oFpQR+80tn5mGO39k+jsy6C7PwPLy0M5xEcRq6KlN5mP0YwKXfEqP+siN+1ieqQFb5/sw8jbbciOdOKaFLbXhUHtVICQAtsRa6EEcDwPUSYLSu7Hn7gPyTAm/83r7cA3h16pq4vNnTKr6+23hMGP9n9JhTM52K6uXlrtMxdHJylHHiQCVPbsuWSgxYs0EaFKwU/n4acj+GmFoCuE61FiqAhW0I2yNsKcjVzWx+ww6/vZiJjbcwtoSbfAaQlMSQYLs9OTUriGSLMwF8JPsdyyQmaKdRFjTbDSljMyQ753+6YN+MbpysXuV9eUvbG9vSUWSGyyQx0PKsefh3oL7kmkoky5mzKciFrmjrnufK7S4hOaqWCedCRWE5QUUq1phpikxBcr6AZtrXOKguIeZkNEuVCiUHFyUL9Lw9IPDF9fdbVWe9f+v7EWuKUWSNI0L927T02cuwjLdYV3wbsx5WKbEto19FV/XSALIjc9K3xpZoM93zelzfSCYGlpYUAKylSKkMvCc1kjLxvi4CJgEI2dCmtvK2eBW3aBJDt7uP2zKmpx5TK/UFCg3mmxMP9Q8j3CGSienPKIaUBuRhOENDCSGrEBbJe1UjRUJTs1o3lb9MYYYICFbw2/uirGol57r5TnVtWgvPiRvWriwlW5q4g2hJmwGsdj8DtGfVAkLikiZhC4tS42TuDD8X25dMuJ4LpygmRzIVQuj5agReAzuWwOxagAFealBPNAmeL1K2VyrLUjljFc5Zb4xbbdKndlHMrzpAoRpThFjM6ADatd+wUnx3sDq40FuvSCABHJc8lG8BwLFEBsaQvw+D/XolA321RbVSdIvYPz882PqOIMw68sjUy4O6EpWl0+/sQul0bLs2KsDtUy5Bx0tqOlrxv76lAmrLdNa88tjwX+D9bD4A4qjunOAAAAAElFTkSuQmCC";

      var img$b = "data:image/png;base64,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";

      var img$9 = "data:image/png;base64,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";

      var img$8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJ5JREFUSEtjZGBgYDhvbv4fRIMAm6QkmP71/DlMiGa04cmTjIwgy2GWwmxCt/z1t29Uc4QoFxfcoyB7wA5AN52aFuJyOcwhYAfQw0JsDgE5YtQBAxoCz3/9GtgoGBwOWKiu/l+SjY1q+ZwUg8AhMOqAQRECoHijdzoAxT8IMHYoKoLrAnQHUNtBMAthiRTuAJAAKBpISb3UUht/8yYjAO2WY3bQOXpaAAAAAElFTkSuQmCC";

      var img$7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJxJREFUSEtjZGBgYPjx+eV/EA0C7DxiYPrnl1cwIZrRHLzijIwgy2GWwmxCt/zn55dUcwQ7rzjcoyB7wA5AN52aFuJyOcwhYAfQw0JsDgE5YtQBAxoCoKgfdQDjq5u7/8OyBNUyO5EGgaNg1AGDIgTAlRC0jCYy+ihWBit9GR+fWQKuC9AdQG0HoRf3cAeALAdFA8VeIsMAMXVXRgDHQnlqOy8RyAAAAABJRU5ErkJgggAA";

      var img$6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJxJREFUSEtjZGBgYPjTZvMfRIOBsByEfvsILkQrBkvVEUZGsOUwS2E2oVtOTcfA7ALRbx8xQByADqhpIa7ggzoE4gB6WIjNIcJy0BAYdcAAhcCfd08HNgoGhwN+JDL/ZxGSplVZg9dccAiMOmBQhAAoouidDkDxDwKMt0KZwXWBHA9qeqG2g2AWwmx59AXCYgQRoGgYiGzAMf8vIwB5ZV3LwFFRawAAAABJRU5ErkJgggAA";

      var img$5 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJxJREFUSEtjZGBgYPiz0+Y/iAYDbjkI/fURXIhWDBb3I4yMYMthlsJsQrecmo6B2QWivz5igDgAHVDTQlzBB3UIxAH0sBCbQ7jloCEw6oABCoE/X54ObBQMDgf8WMT8n4VHmlZlDV5zwSEw6oBBEQKgiKJ3OgDFPwgw3upjBtcFciKo6YXaDoJZCLPl0RsIixFEgKJhILIBR9xfRgALuGEL1RXxHQAAAABJRU5ErkJgggAA";

      var img$4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAAXNSR0IArs4c6QAAAJ9JREFUSEtjZGBgYPiz0OY/iAYDfjkI/fERXIhWDJb4I4yMYMthlsJsQrf8ExUdwwf1IMjOj48YIA5AB9S0EFfwQR0CcQA9LMTmED45aAiMOmCAQuDPx6cDGwWDwwE/Wpj/s/BL06qswWsuOARGHTAoQgAUUfROB6D4BwHGWyXM4LpATgA1vVDbQTALYbY8+gBhMYIIUDQMRDbgqPnLCAC7Z1+Jrp0+OQAAAABJRU5ErkJgggAA";
      //big_block_cheese
      var img$m = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAVRJREFUeF7tmkEOgjAURNvowpW6N+Ek3sWLuPQi3sXEe2DciysXGE0LRaIFYnRT5nUHIYR5mfn/t8Ea8WXF9RsA4ABxAkRA3AAUQSJABMQJEAFxA9AFiAARECdABMQNQBcgAkRAnAAREDdA1QXK/frRgFhk/UyKfDTMppuDtV78kGgnOWXhXfqK3MQB9Im9JuSAeYebA5AGQMzUKQn9JpRvUCoHhDVW0TFANQgA4AAiQA2oiqBSAXR6P4ogABIacL7p+13P4oBqSnzNAURALwLl6ajtAADggDoCzgrTxeofzSWZd5TF+dUFAKDsgNtu4vcCshEAAA4gAtQAiiBdgDbIHMAgpLoZYhIUnATDVtgfiio6IArg/SRjTEWxLTjozC/GZMvaAe7CLXejb6UAJSa2rSloDXp9BNo3w8NDMJI5+6o/tEuj/0ss1IHURP36vbPt3T4B6TbrCbLScUkAAAAASUVORK5CYIIA"
      //big_cheese
      var img$n = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAV5JREFUeF7tmU0OgjAUhNvIwpW4N+Ek3sWLuPQi3sXEe2DciysXGE0LRcQCISHE8r5u+A10JvPmDVQrpVR+3L7M1o44qXa9O1nafT2gq9HupLUF3wfagAoZeBu+LFV+ArrA3gNSwKpFzY6QigCfbEMCOqTsGqQUCnBjrqB9BJVEQAAKoATwgMIEJRmgwftjghAQUMAZ0vfb7kUBRUr85ABKgBIYo7LCeQYegAdggnQB2iA5gCAkOgnml7NsBUAAChBcAnl2lZ0EIQAFUAJ4gOivQUywboImEkbxJpz/eSPM9EsBEIACBJfA47Cwq8NiPQACUAAlgAdggnQB2iA5gCAk9WuQJEgSJAmSBEmCJEGSIElQUhJ0v8TtypDEIOQloLnWMCdF1AE7nOlNqWRdKsAcmGFOdI0QSPGBrWNyWB1eWwL1k+7mPjJGWJ2a9BFtGLWZhfOBSWf0By9b7p/6DTYigZD4f1s0AAAAAElFTkSuQmCC"
      //big_pasta
      var img$o = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAoRJREFUeF7tmT1Ow0AQhZ2GAgESP0UqqCgQTWpqCu7AMSJOgTgGd6CgTk2DKKigSsGPBIiCJuhFjDREa++zZ2Nb2bEUJUTJ7s63771Zh0GR+TXIvP7CAbgCMifgFshcAB6CbgG3QOYE3AKZC8C7gFvALZA5AbdA5gLwLuAWcAtkTsAtkLkAvAu4BdwCmRMwW+D+9ny2tj4s8Ph6uZs/43EwujCP3cbemBb5dHc5e3u+KT4/3ovNre1/z7vDo+L49No0fq8BYOd/vqfzonEtAsDfG3uj4vDkqtcQGi8Ou4/CqxQAK6wsgMfJeO597fvQ65UFgN2HChyASn4NA/mAR9+DsHEGQAEpbAAVCSyEZtvgOgWATvI6fQh2kJ39s1bOEp0BgHpgmdAZQtoqQnbZFjIBsAQhAEDuVQrA+Ms+UXYOQPs+9HrZbdQMQAdhWTGhA5EooAoAu/uWIE0KoE6g6ZuoUBcAGAaANUiTAIBX6wQas/uAEpN/iiA1A5DzQJ1ASwmgzryhu8ukANhASw2AnbdTALqlMQAY/6cYJ4kCmEDTnk6xcABl5o2BNANgikHxuNAOyxJ/8X0mAPEdi/yxJgdg/d3NFfB3pq+SYuh3AusJkAEf839rFpCDUsyv4mlm4b0BgCSWwlBoKJgEgIRg7PMMAGZeZhxTCDK7IBkjNoglN3MLzM7bCwAoWHa+TCG6BTKLZgAw45gzgFlI3TMAs3BmXmacVgD0uQO0AkDkDRusnAWYJNYAdACWwWCky8zLjGNSAONDKVIHYV8OQNKdGrdBBzAZz/87LFdZfxcVSAZUfZ6RLcDH5mXGMStABlhckNz2SuHa6/o9XUTs1jd0wxaat8k4v4956Yy4k32yAAAAAElFTkSuQmCC"
      //cheese_med
      var img$p = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAKNJREFUWEdj/LPQ5j8DMuCXg/A+PkIRphWHEewAmKUwW9At/0RFx/BBPQi1C+IAdEBNC3EFHdQhEAfQw0JsDuGTYxh1wGgIjIbAaAiMhsBoCAxoCPz5+HRgK6PB4YAfLcz/WfiladXiwmsuOARGHTAaAqMhMBoCgyIEQMUVvUtDUCkIAoy3SpjBfUM5AdRSk9oOglkIs+XRBwgLXBQPSEUAtRQAZMisU24BwaEAAAAASUVORK5CYIIA"
      //cheese_small
      var img$q = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAMhJREFUWEdjZBhgwDjA9jOMOmA0BEZDYDQERkNgNARGQwAcAn8W2vyHV8v8chDmx0dE1dQs8UcoCkVGsOUwS2FWolv+Cc0xfFBHgvR9fMRAiSMgDkAH6BbiCguoQyh3ALEWYnMInxwVQmAgHfCjhfk/C780UQkOm6I/H58ycNT8JTshMg4KB4B8Rk4ogHwPAhSFwK0SZnAukBNADWBsDoJZCFP56AOEpdZDQRSADABFA7mJgBLfg+wkO/GQ62B0faMOGA2BAQ8BAI7eRCH/UP3hAAAAAElFTkSuQmCC"
      //cheese
      var img$r = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAALVJREFUWEdjZBhgwDjA9jOMOmA0BEZDYDQERkNgNARGQwAcAn8W2vyHV8v8chDmx0c0r6lZ4o8wMoIth1kKsxLd8k9UdAwf1IMgOz8+YoA4AB1Q00Jc4Qh1CMQB9LAQm0P45KAhMOqAAQqBPx+fDmwUDA4H/Ghh/s/CL03zQgebBeAQGHXAoAgBUPzQOx2A4h8EGG+VMIPrAjkB1GRCbQfBLITZ8ugDhAWujkHRMBDZgKPmLyMAiQ5fmUtIMZgAAAAASUVORK5CYIIA" 
      //err_cheese
      var img$s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAANFJREFUWEftlsENgzAMRe0JsoHFAmWCwPAoE9AJ6AZZoKkc6qpNK2QitUGVfYGDw3/5OHYQGgc21gcDMAfMgWM4kMaUHv1gvL9Nug4xXAdd4oesEAJiFhdRSSrFN2D6U78LwDmX8/kZY4QVoAzl7nnZXgCREpAVYIdgyVoLIC4YgDmA3vvEx6E25vNcuxQWWACJKMmRqPmSAfyHA9KVflkDXIAcPI7zLCCiF31tYWp/gQiKyDMAi78PJKUd06V+kHTQ4TEuJMrNfiXNHDAHmjtwA8OAXgH+03ygAAAAAElFTkSuQmCC"
      //house_big
      var img$t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAn1JREFUeF7tmbFOwzAQhl3RgallrwgSz9GHYGbhRRh5ERZmHqISD8BeiaLulImhCOQ0QW56ju/i8znClwna4Pj//P/ni5mYwq9J4fqNAlAHFE5AI1C4AbQIagQ0AoUT0AgUbgDdBTQCGoHCCWgECjeA7gIagbFEYP98+zO9eRJfEPEHQsCt+PZzaQjZAfyJf18Zc7msOUhCyArgSHxrgVl1gHC3EpmbyEN6bW9XvnsJQsgCYP+4PGT+c+OvwUIQxAHU4ueVMdDKZ3CCKADUygtDEAMAim9sDubAjUfCOIgAAKu9VT2rzPr1pdZ/fbUw67dt/XN1Ycx0vjjmkghCcgBe8VQAzf3cW2RSAL3iW0HATrDfbU8dkKhPSAYAVfAoEXADwRiHJABQ4odEIAEEdgBo8cYYa3XfdVIEoRsZnMAKgCLe3wISv4mEwAagFg/s3cE9PqQX0ytEQGABcCI+Nt+drKN6hYEQogF4bT+0wgOtMAUAtU/gAQC91dkVoe7xvkJHGWdWkc4SkgJArRyiBpDGUQAjcUD0Ht84gzzOaBwQsnaq77kBfD2c1cdXvtfTWkff0VYqob5xuQHY51gI5/ffYMEEewBp0Z2+gXKijNoFggAgFxA6uN5uETNOxKsyDwBPHxDcvjC9AqWhGtANRgOw7gDf3DAT5wbQtOCiEegDEOwEkQCC4+SsARwO6B6BHf2OcZIDwP6tr2BDtWYUEfiXAFAdHCICqHFG6QBML4AAgBnGvSdLBMBOETNzRgCuU1hrQNsK9+nZfBz+m0MGEQnAFW3nYC87D3YA7uCYhc19DyuA3GJSPx+1DaaeRM7xFUBO+mN4tjpgDKuQcw6/a8vnUHGfMV4AAAAASUVORK5CYIIA"
      //house_small
      var img$u = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAUJJREFUWEftlTEOgkAQRYdIYaX2JJh4Dg9hbeMJvIGlN/AENtYegsQD2JOIoRcrCwxmB9CFZWF2wNCwFRB2/ps/O7MW9LysnvVhABgcaO1AfF4n9urEjsPeKLpHiGMXRQHYG48Vi7WpIH73ACYucnAgWADxcZlm/gx+Y4QJYQxQKZ5jMCCMAGrFmRBkAJI4A4IEgOJyvSkXCLEcjQAscQMnagG0tmfZVRpRdqrBCQR47UeJPXWUllJaTcrMv17wbTF3wL+F+OzOAApxxEcKAA6Wg4u9bW+DrysKGAcgg9ANqYLYePculKQOoOpQxlGoOvAvAHIJhLtRCOXkcjPZDvQKIDLSLeUQ/sUByiCS/mlVAuwMuUUNxGWnSGcgeKS9LC/5GwVEFhV78/lAAjBIzvjXRgDjiB1taLyMOtLRhhkABgc+eFy6IWRLfqQAAAAASUVORK5CYIIA"
      //parmesan_pile
      var img$v = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAp5JREFUeF7tmbtOAlEQhg8VBgwWBjDEAhJtjIHa0gJrH8Dewjcxthb2voCtPICJHSRWkmBhvEAsJGqkWjObDBmOeznszp5NOEOzyQqcnW/+fy5YUI6/Co7HrwSAKMBxAmIBxwUgRVAsIBZwnIBYwHEBSBcQC4gFHCcgFnBcANIFxAJiAccJiAUcF4B0AbGAWMBxAmIBxwUgXUAsIBZwnIBYwHEB5NsF+r0zr9O9zFWFuR0+6l95lWpbPT9cqzwh5Abg4+XOm04GvgOLpbpq7B7n8izWD4XAIeuVWltNxwP/Ci9Qw2bjwPrzWD2QZh2LL4UA91qdU6vPZO0wKHg02yD/2fe7KpbrajLqqWqrO1eETQhWAEDBw4xj0DTzcK/a7CqAAlaAqy0IVgC8Pt54vz9v85EDgq81jxTcQxAUyFppy/+bDQiZAoDMQzDjp9t50cPAqSL8TlCuK3jv8P5Cbe+fLBTILEFkBgCCD8qqXvzWN3bU1+fwnxLgswtdotbORBHsAKKyzqEGgMI5OLECiMo6hxrAGtzTIxsAnOv1godVnS5dWOSoHUyKIv0uLiWwAMA2p0vcn/DIpAftLYkN9g7P/Z2BTo9cSmADECXxoN4fpAIIUC+KQQqi99LuEakAxBU87P1hWY9Tg74rgKK494jEAKIKnh4Y2oBm3aQo0lkBJ0VaSzj2iEQAouZ6k8BMej8dmHQlcO4RiQBg0UNvQ1aSyhy+g06CYJswBZnuEctslUsD0NscHBaW9TRqQKhwTbJH4NlxY7QxAK65ni5C+mxAdwaoG3FFUldP0B4RpwYjAFnM9VQ5QUpJo56gPSIMRCSAuDaXdsvDIGmmuWqJ6VYZCiDruR4krv8umEUtidsqjSywyv88EQCrnF2T2P4AtKMlbmXPSUkAAAAASUVORK5CYIIA"
      //parmesan
      var img$w = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAASlJREFUWEdjZBhgwDjA9jOMOmA0BEZDYDQERkNgNARGQ2A0BMgKgfsXZ/5X1E8nSy96A4gsQy7uzv7PJ6bHQA1HkOwAkO/5RPUYnlxdwqDvOpVk/RSHwNtnx/9/en0JbA47lziDlGoARY4gSTMs6D+9usQAigIQoDQaSHIAKPhhQUgtRxDtAFjcg4L/59eXDOzc4gyv7+9mEFV0ZQA5htz0QJQDQJbDLEX2OUhMVMGVAeQoUMIUlrIkyjzkhIhXw/PbG///+PYCrh5kuZiCGwNIDOYQZAdxcEmA5UhJF1gdAPIxyLBXD3aBExuyxTDXgHwPzgnc4gwgtXdO9TDI6MTAHUZsAsVwAMhybL5CT3w8/CoMXz7ewQgJkF5k/YQKLJLjjNp9yVEHAABkD4wh8YHj+gAAAABJRU5ErkJgggAA"
      //pasta_long
      var img$x = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAQ5JREFUWEdjZBhgwDjA9jOMOoDiEHh4ofv/r28vGECYR8QATIOwtstSoswmShGudHJ1T/T/ty+uM/DyCTJ8/vQehRaS82CQNyglaD5BBbgsv32s+P+XNxcwLAY5BARAjmLjkiAYEhQ5ABTU+EIA5BBCoUCxA5DjHRtb1aoXrx00dQAh34NCiGwHgBIgKI5BGFsuAIUGzRwASoDo2Y6c4Cc7BEYdQEwIEBP/NI0CmjmAGN+DEiih/A8rYUnOhqMOICYEiI1/shLhgDsAVATDSj2QD7CViDQLAWJ8T0wVjNzGICkXEOMAUnxPchoYdcCAhwC1cwBJaYAWvh96DkDOv5QWQBTVhuidFWKrXmydHACu2vwwVYu09AAAAABJRU5ErkJgggAA"
      //pasta
      var img$y = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAQZJREFUWEdjZBhgwDjA9jOMOmA0BEZDYGiHwMML3f9/fXvBAMI8IgZgGoS1XZYS7TGiFaIXWFf3RP9/++I6Ay+fIMPnT+9RaCE5DwZ5g1KizCZKEbrlt48V///y5gKGxSCHgADIUWxcEkSFBNkOAAU1vhAAOYSYUKDIAcjxjo2tatVL0HyCCrBVVqAoQE946A4gxvcgs8lyACgBguIYhLHlApBjaOYAYnwPchQxwU9WCIw6gJgQIDb+aRYFNHUAKAfAshzIB9iyI80cQEzwE1sCwsoXksoBYhxAiu9JTgOjDhjwEKB2DiApDdDC90PPAchtA0oLILLKAZAmUFSgN1KIrXqxNW4AiV2UMHThWR4AAAAASUVORK5CYIIA"
      //cheeseungus
      var img$z = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAlRJREFUeF7tmUFOAzEMRVPRBSs4ABIn4S5chCUX4S6cBIkDwIpFEWhG4yo14ziJ7XSozQ5Nm+S/fDs/011y/rdzrj8FgHCAcwJRAs4NEE0wSiBKwDmBKAGpAQ4vDz/SMda+v398HbI53ZNYCccwrEE0A/gj/PPNwgAp3dyfjGsFoh+AlXCMcwGxCQDH3R8lHmAYQmhygGsAZxNv7IJqBwQAOO9H1384YCFg1AjJEiCDjgcHFFPepQM4EZ+LhWTmBgAW6gFA8ajTAoAyfu9FQisanzRBcwBK4gGaBoQjADboSB2Qi5f2kWwsKYQxADTFo2A0/SuBYA/AQrwihHEApLanuqUwIf57AIeP9xnN9dN39cUuZxkAgIbVKQA7tL+96z3yi9/bvANggXO3VoaQj73dEkgpWUDQED9tin0PWAysCUFL/FAA02T5wjUaQq/tx54CSKkWBA3xwx0g2XVpt6fmHtYDJOLz8tHaeVhPNQDr85wDdHYHXDyAr+er+Xd+KqwEgOXSoZ3mOOsfo7rw0sM2wXCA9xKYLFJyQW8PoIJPaymZnwIBYOkSlAukDoAAw/UaqlkNcUDuAnwkugGAIeAdkdbu5h0AgmGhbgFg4Vo7pzVObYDiPlf9Kllr4VrjcMJqnweAWlJaO6c1Tu26uc81O6B0Y8STrb28zJtr7Ymi+RIUr7EaAJcU10hT4aXVBVYhaFpzF4AaF5R2rcUFlrvfDGAtJGEb48sP9Q4P54zecbga5543OYALSXgy7gUmFbZax+FElp53AeBAcMKpkDVSOMz1Cww+Il+yzLqWAAAAAElFTkSuQmCC"
      /**
       *
       * @author Patrik Harag
       * @version 2023-08-10
       */ //pingpingping
      class Templates {

          static TOOLS = [
              {
                  name: "Cheese",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$r,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$q,
                              brush: "rock",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$r,
                              brush: "rock",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$p,
                              brush: "rock",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Anything",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$a,
                  },
                  action: {
                      type: "random",
                      actions: [

                          {
                              type: "image-template",
                              imageData: img$m,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$n,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$o,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$p,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$q,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$r,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$s,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$t,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$u,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$v,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$w,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$x,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$y,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$z,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Anything Melted",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$z,
                  },
                  action: {
                      type: "random",
                      actions: [

                          {
                              type: "image-template",
                              imageData: img$m,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$n,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$o,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$p,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$q,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$r,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$s,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$t,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$u,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$v,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$w,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$x,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$y,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          },
                          {
                              type: "image-template",
                              imageData: img$z,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true,
                              randomFlipVertically: true
                          }
                      ]
                  }
              },
              {
                  name: "Large Block",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$m,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$m,
                              brush: "wall",
                              threshold: 50
                          },
                          {
                              type: "image-template",
                              imageData: img$n,
                              brush: "wall",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Cheese House",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$t,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$t,
                              brush: "wood",
                              threshold: 50
                          },
                          {
                              type: "image-template",
                              imageData: img$u,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Cheese House Melted",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$t,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$t,
                              brush: "gravel",
                              threshold: 50
                          },
                          {
                              type: "image-template",
                              imageData: img$u,
                              brush: "gravel",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "glitch cheese",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$s,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$s,
                              brush: "wall",
                              threshold: 50
                          },
                          {
                              type: "image-template",
                              imageData: img$s,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$s,
                              brush: "rock",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$s,
                              brush: "gravel",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$s,
                              brush: "water",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$s,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Pasta",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$o,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$o,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$x,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$y,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Parmesan Pile",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$w,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$v,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$w,
                              brush: "sand",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Cheeseungus",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$z,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$z,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$z,
                              brush: "rock",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Fireball",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$f,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$f,
                              brush: "meteor",
                              threshold: 75,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$f,
                              brush: "fire",
                              threshold: "25",
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Goldfish",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$b,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$b,
                              brush: "wood",
                              threshold: 75,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Cheez Its",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$9,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$9,
                              brush: "wood",
                              threshold: 75,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Courses",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$j,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$j,
                              brush: "wall",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$h,
                              brush: "wall",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$i,
                              brush: "wall",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$g,
                              brush: "wall",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              },
              {
                  name: "Cheeses",
                  category: "template",
                  type: "template",
                  icon: {
                      imageData: img$5,
                  },
                  action: {
                      type: "random",
                      actions: [
                          {
                              type: "image-template",
                              imageData: img$4,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$5,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$6,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$7,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          },
                          {
                              type: "image-template",
                              imageData: img$8,
                              brush: "wood",
                              threshold: 50,
                              randomFlipHorizontally: true
                          }
                      ]
                  }
              }
          ]

      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ComponentViewTemplateSelection extends Component {

          createNode(controller) {
              let buttons = [];

              for (const toolDefinition of Templates.TOOLS) {
                  const name = toolDefinition.name;
                  let loadedTool = null;

                  let button = DomBuilder.button(name, { class: 'btn btn-light template-button', 'data-dismiss': 'modal'}, () => {
                      if (loadedTool !== null) {

                          const toolManager = controller.getToolManager();
                          const revert = toolManager.createRevertAction();

                          toolManager.setPrimaryTool(loadedTool);
                          toolManager.setSecondaryTool(Tool.actionTool(null, null, null, revert));

                      }
                  });
                  button.css('background-image', `url(${ toolDefinition.icon.imageData })`);

                  buttons.push(button);

                  ResourceIO.parseToolDefinition(toolDefinition).then(tool => {
                      loadedTool = tool;
                  }).catch(e => {
                      console.warn('Template loading failed: ' + e);
                  });
              }

              return DomBuilder.div({ class: 'sand-game-templates' }, buttons);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ActionDialogTemplateSelection extends Action {

          performAction(controller) {
              let templatesComponent = new ComponentViewTemplateSelection();

              let dialog = new DomBuilder.BootstrapDialog();
              dialog.setHeaderContent('Templates');
              dialog.setBodyContent(DomBuilder.div({ class: 'sand-game-component' }, [
                  DomBuilder.par(null, "Select a template"),
                  templatesComponent.createNode(controller),
                  DomBuilder.par(null, ""),
                  DomBuilder.par(null, "You can also create your own template using an image. See the Import button.")
              ]));
              dialog.addCloseButton('Close');
              dialog.show(controller.getDialogAnchor());
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ComponentViewTools extends Component {

          /** @type Tool[] */
          #tools;

          /** @type boolean */
          #templates;

          /**
           * @param tools {Tool[]}
           * @param templates {boolean}
           */
          constructor(tools, templates) {
              super();
              this.#tools = tools;
              this.#templates = templates;
          }

          createNode(controller) {
              let buttons = [];

              for (let tool of this.#tools) {
                  let cssName = tool.getCodeName();
                  let displayName = tool.getDisplayName();
                  let button = DomBuilder.button(displayName, { class: 'badge badge-secondary ' + cssName }, () => {
                      controller.getToolManager().setPrimaryTool(tool);
                      controller.getToolManager().setSecondaryTool(Tools.byCodeName('air'));
                  });

                  controller.getToolManager().addOnPrimaryToolChanged(newTool => {
                      if (newTool === tool) {
                          button.addClass('selected');
                      } else {
                          button.removeClass('selected');
                      }
                  });

                  // initial select
                  if (tool === controller.getToolManager().getPrimaryTool()) {
                      button.addClass('selected');
                  }

                  buttons.push(button);
              }

              if (this.#templates) {
                  let button = DomBuilder.button('Assets', { class: 'badge badge-secondary template'}, () => {
                      new ActionDialogTemplateSelection().performAction(controller);
                  });
                  buttons.push(button);
              }

              return DomBuilder.div({ class: 'sand-game-tools' }, buttons);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ComponentContainer {

          #cssClass;
          #components;

          /**
           *
           * @param cssClass {string}
           * @param components {Component[]}
           */
          constructor(cssClass, components) {
              this.#cssClass = cssClass;
              this.#components = components;
          }

          createNode(controller) {
              const content = DomBuilder.div({ class: this.#cssClass }, []);
              for (let component of this.#components) {
                  content.append(component.createNode(controller));
              }
              return content;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ComponentButton {

          static CLASS_PRIMARY = 'btn-primary';
          static CLASS_SECONDARY = 'btn-secondary';
          static CLASS_INFO = 'btn-info';
          static CLASS_SUCCESS = 'btn-success';
          static CLASS_WARNING = 'btn-warning';
          static CLASS_LIGHT = 'btn-light';


          #label;
          #action;
          #cssClass;

          /**
           *
           * @param label {string}
           * @param cssClass {string|null}
           * @param action {Action|function}
           */
          constructor(label, cssClass, action) {
              this.#label = label;
              this.#action = (typeof action === "function" ? Action.create(action) : action);
              this.#cssClass = (cssClass == null ? ComponentButton.CLASS_PRIMARY : cssClass);
          }

          createNode(controller) {
              return DomBuilder.button(this.#label, { class: 'btn ' + this.#cssClass }, e => {
                  this.#action.performAction(controller);
              });
          }
      }

      var FileSaver_minExports = {};
      var FileSaver_min = {
        get exports(){ return FileSaver_minExports; },
        set exports(v){ FileSaver_minExports = v; },
      };

      (function (module, exports) {
        (function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return "undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error("could not download file");},d.send();}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send();}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"));}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof commonjsGlobal&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else {var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else {var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});


      } (FileSaver_min));

      var FileSaver = FileSaver_minExports;

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ActionIOExport extends Action {

          performAction(controller) {
              const snapshot = controller.createSnapshot();
              const bytes = ResourceIO.createResourceFromSnapshot(snapshot);
              FileSaver.saveAs(new Blob([bytes]), this.#createFilename());
              Analytics.triggerFeatureUsed(Analytics.FEATURE_IO_EXPORT);
          }

          #createFilename() {
              let date = new Date().toISOString().slice(0, 10);
              return `sand-game-js_${date}.sgjs`;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ActionIOImport extends Action {

          performAction(controller) {
              let input = document.createElement('input');
              input.type = 'file';
              input.onchange = e => {
                  controller.getIOManager().loadFromFiles(e.target.files);
              };
              input.click();
          }
      }

      var _ASSET_SVG_PAUSE = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-pause-fill\" viewBox=\"0 0 16 16\">\r\n    <path d=\"M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z\"/>\r\n</svg>";

      var _ASSET_SVG_PLAY = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-play-fill\" viewBox=\"0 0 16 16\">\r\n    <path d=\"m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z\"/>\r\n</svg>";

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-20
       */
      class ComponentButtonStartStop extends ComponentButton {

          constructor(cssClass) {
              super('', cssClass, Action.create(controller => {
                  controller.switchStartStop();
                  Analytics.triggerFeatureUsed(Analytics.FEATURE_PAUSE);
              }));
          }

          createNode(controller) {
              const btn = super.createNode(controller);

              controller.addOnStarted(() => btn.html([DomBuilder.create(_ASSET_SVG_PAUSE), 'Pause']));
              controller.addOnStopped(() => btn.html([DomBuilder.create(_ASSET_SVG_PLAY), 'Start']));

              return btn;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ComponentStatusIndicator extends Component {

          createNode(controller) {
              let currenStatus = '';

              const nodeStatusLabel = DomBuilder.span('');
              const nodeLabel = [
                  DomBuilder.span('Performance: ', { class: 'status-label' }),
                  nodeStatusLabel
              ];

              const node = DomBuilder.div({ class: 'btn-group' }, [
                  DomBuilder.element('button', {
                      type: 'button',
                      class: 'btn btn-link dropdown-toggle',
                      'data-toggle': 'dropdown',
                      'aria-haspopup': 'true',
                      'aria-expanded': 'false'
                  }, nodeLabel),
                  DomBuilder.element('form', { class: 'dropdown-menu p-2' }, this.#createStatusContent(controller))
              ]);
              node.on('show.bs.dropdown', function () {
                  Analytics.triggerFeatureUsed(Analytics.FEATURE_STATUS_DISPLAYED);
              });

              let updateStatus = (node, status) => {
                  if (status !== currenStatus) {
                      nodeStatusLabel.text(status.toUpperCase());
                      nodeStatusLabel.removeClass('status-' + currenStatus);
                      nodeStatusLabel.addClass('status-' + status);
                      currenStatus = status;
                  }
              };

              controller.addOnStopped(() => updateStatus(node, 'stopped'));
              controller.addOnStarted(() => updateStatus(node, 'started'));
              controller.addOnInitialized(sandGame => {
                  sandGame.addOnRendered(() => {
                      const ips = controller.getSandGame().getIterationsPerSecond();
                      if (ips === 0) {
                          updateStatus(node, 'stopped');
                          return;
                      }
                      if (ips > 105) {
                          updateStatus(node, 'best');
                          return;
                      }
                      if (ips > 80) {
                          updateStatus(node, 'good');
                          return;
                      }
                      if (ips > 50) {
                          updateStatus(node, 'medium');
                          return;
                      }
                      if (ips > 40) {
                          updateStatus(node, 'low');
                          return;
                      }
                      updateStatus(node, 'poor');
                  });
              });

              return node;
          }

          #createStatusContent(controller) {
              const labelCPS = DomBuilder.span();
              const labelFPS = DomBuilder.span();
              controller.addOnInitialized(sandGame => {
                  sandGame.addOnRendered(() => {
                      const fps = controller.getSandGame().getFramesPerSecond();
                      const ips = controller.getSandGame().getIterationsPerSecond();
                      labelFPS.text('= ' + fps);
                      labelCPS.text('= ' + ips);
                  });
              });

              const labelCanvasSize = DomBuilder.span();
              const updateCanvasSize = () => {
                  const w = controller.getCurrentWidthPoints();
                  const h = controller.getCurrentHeightPoints();
                  labelCanvasSize.text(`= ${w.toLocaleString()}\u00D7${h.toLocaleString()} = ${(w * h).toLocaleString()}`);
              };
              controller.addOnInitialized(() => {
                  updateCanvasSize();
              });
              updateCanvasSize();

              return [
                  DomBuilder.span('Simulated elements'),
                  DomBuilder.element('br'),
                  labelCanvasSize,
                  DomBuilder.element('br'),

                  DomBuilder.span('Simulation iterations /s'),
                  DomBuilder.element('br'),
                  labelCPS,
                  DomBuilder.span(' (target: ' + Processor.OPT_CYCLES_PER_SECOND + ')', { style: 'color: lightgray;' }),
                  DomBuilder.element('br'),

                  DomBuilder.span('Rendered frames /s'),
                  DomBuilder.element('br'),
                  labelFPS,
                  DomBuilder.span(' (target: ' + Processor.OPT_FRAMES_PER_SECOND + ')', { style: 'color: lightgray;' }),
                  DomBuilder.element('br'),

                  DomBuilder.element('br'),

                  DomBuilder.span('Tip: adjust scale if needed'),
              ];
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ComponentViewOptions extends ComponentContainer {

          constructor() {
              super('sand-game-options', [
                  new ComponentButton('Import', ComponentButton.CLASS_LIGHT, new ActionIOImport()),
                  new ComponentButton('Export', ComponentButton.CLASS_LIGHT, new ActionIOExport()),
                  new ComponentButtonStartStop(ComponentButton.CLASS_LIGHT),
                  new ComponentStatusIndicator(),
              ]);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ActionsTest {

          static TREE_SPAWN_TEST = function (controller) {
              let sandGame = controller.getSandGame();
              if (sandGame === null) {
                  return;
              }

              sandGame.graphics().fill(Brushes.AIR);
              sandGame.graphics().drawRectangle(0, -10, -1, -1, Brushes.SOIL, true);
              sandGame.graphics().drawRectangle(0, -11, -1, -11, Brushes.GRASS, true);

              let c = Math.trunc(sandGame.getHeight() / 2);
              sandGame.graphics().drawRectangle(0, c, -1, c, Brushes.WALL, true);
              sandGame.graphics().drawRectangle(0, c-10, -1, c-1, Brushes.SOIL, true);
              sandGame.graphics().drawRectangle(0, c-11, -1, c-11, Brushes.GRASS, true);
          }

          static TREE_GROW_TEST = function (controller) {
              let sandGame = controller.getSandGame();
              if (sandGame === null) {
                  return;
              }

              let treeBrush = Brush.withIntensity(Brushes.TREE, 0.05);

              sandGame.graphics().fill(Brushes.AIR);
              sandGame.graphics().drawRectangle(0, -10, -1, -1, Brushes.SOIL, true);
              sandGame.graphics().drawRectangle(0, -11, -1, -11, treeBrush, true);

              let c = Math.trunc(sandGame.getHeight() / 2);
              sandGame.graphics().drawRectangle(0, c, -1, c, Brushes.WALL, true);
              sandGame.graphics().drawRectangle(0, c-10, -1, c-1, Brushes.SOIL, true);
              sandGame.graphics().drawRectangle(0, c-11, -1, c-11, treeBrush, true);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ActionBenchmark extends Action {

          performAction(controller) {
              let benchmarkProvider = new BenchmarkProvider(controller, results => {
                  let dialog = new DomBuilder.BootstrapDialog();
                  dialog.setHeaderContent('Benchmark results');
                  dialog.setBodyContent([
                      DomBuilder.par(null, 'IPS AVG: ' + results.ipsAvg.toFixed(2)),
                      DomBuilder.par(null, 'IPS MIN: ' + results.ipsMin)
                  ]);
                  dialog.addCloseButton('Close');
                  dialog.addButton(
                      DomBuilder.button('Download results', { type: 'button', class: 'btn btn-primary' }, e => {
                          const data = JSON.stringify(results, null, '  ');
                          const blob = new Blob([data], { type: 'application/json;charset=utf-8' });
                          FileSaver.saveAs(blob, 'benchmark.json');
                      })
                  );
                  dialog.show(controller.getDialogAnchor());
              });
              benchmarkProvider.start();
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-04-29
       */
      class BenchmarkProvider {

          static WAITING_GAP = 300;

          /** @type Controller */
          #controller;

          /** @type function */
          #onFinish;

          /**
           *
           * @param controller {Controller}
           * @param onFinish {function({ipsAvg,ipsMin,benchmarks:{name,ipsAvg,ipsMin}[]})}
           */
          constructor(controller, onFinish) {
              this.#controller = controller;
              this.#onFinish = onFinish;
          }

          start() {
              let scene = new SceneImplHardcoded({
                  apply: (sandGame) => this.#benchmarkScene(sandGame)
              });

              this.#controller.openScene(scene);
              this.#controller.start();
          }

          #benchmarkScene(sandGame) {
              const benchmarkResults = [];
              const benchmarkQueue = [...BenchmarkProvider.BENCHMARKS];
              let i = 0;
              let waiting = BenchmarkProvider.WAITING_GAP;
              let ipsSum = 0;
              let ipsMin = Number.MAX_SAFE_INTEGER;
              sandGame.addOnProcessed(() => {
                  if (waiting > 0) {
                      waiting--;
                      return;
                  }
                  if (benchmarkQueue.length === 0) {
                      return;
                  }

                  const benchmark = benchmarkQueue[0];
                  if (i === 0) {
                      console.log('Running benchmark: ' + benchmark.name);
                  }
                  benchmark.nextIteration(sandGame, i);
                  i++;
                  const ips = sandGame.getIterationsPerSecond();
                  ipsSum = ipsSum + ips;
                  ipsMin = Math.min(ipsMin, ips);

                  if (benchmark.iterations === i) {
                      const ipsAvg = ipsSum / benchmark.iterations;
                      benchmarkResults.push({
                          name: benchmark.name,
                          ipsAvg: ipsAvg,
                          ipsMin: ipsMin
                      });

                      benchmarkQueue.shift();
                      i = 0;
                      ipsSum = 0;
                      ipsMin = Number.MAX_SAFE_INTEGER;
                      waiting = BenchmarkProvider.WAITING_GAP;

                      sandGame.graphics().fill(Brushes.AIR);

                      if (benchmarkQueue.length === 0) {
                          this.#onFinish(this.#finalizeResults(sandGame, benchmarkResults));
                      }
                  }
              });
          }

          #finalizeResults(sandGame, benchmarkResults) {
              const ipsSum = benchmarkResults.map(r => r.ipsAvg).reduce((a, b) => a + b, 0);
              const ipsAvg = ipsSum / benchmarkResults.length;
              const ipsMin = benchmarkResults.map(r => r.ipsMin).reduce((a, b) => Math.min(a, b), Number.MAX_SAFE_INTEGER);
              return {
                  version: 1,
                  date: new Date().toString(),
                  ipsAvg: ipsAvg,
                  ipsMin: ipsMin,
                  benchmarks: benchmarkResults,
                  scene: {
                      width: sandGame.getWidth(),
                      height: sandGame.getHeight()
                  }
              }
          }


          static #createBenchmark(name, iterations, nextIteration) {
              if (iterations <= 0) {
                  throw 'Number of iterations must be a positive number';
              }
              return {
                  name: name,
                  iterations: iterations,
                  nextIteration: nextIteration
              };
          }

          static BENCHMARKS = [
              BenchmarkProvider.#createBenchmark('sand-fall-q', 500, function (sandGame, j) {
                  sandGame.graphics().drawRectangle(0, 0, -1, 0, Brushes.SAND, true);
              }),
              BenchmarkProvider.#createBenchmark('sand-fall-s', 2000, function (sandGame, j) {
                  if (j % 10 === 0) {
                      sandGame.graphics().drawRectangle(0, 0, -1, 0, Brushes.SAND, true);
                  }
              }),
              BenchmarkProvider.#createBenchmark('sand-fill', 1000, function (sandGame, j) {
                  if (j === 0) {
                      sandGame.graphics().drawRectangle(0, 0, -1, -1, Brushes.SAND, true);
                  }
              }),
              BenchmarkProvider.#createBenchmark('soil-fall-q', 500, function (sandGame, j) {
                  sandGame.graphics().drawRectangle(0, 0, -1, 0, Brushes.SOIL, true);
              }),
              BenchmarkProvider.#createBenchmark('soil-fall-s', 2000, function (sandGame, j) {
                  if (j % 10 === 0) {
                      sandGame.graphics().drawRectangle(0, 0, -1, 0, Brushes.SOIL, true);
                  }
              }),
              BenchmarkProvider.#createBenchmark('soil-fill', 1000, function (sandGame, j) {
                  if (j === 0) {
                      sandGame.graphics().drawRectangle(0, 0, -1, -1, Brushes.SOIL, true);
                  }
              }),
              BenchmarkProvider.#createBenchmark('water-fall-q', 500, function (sandGame, j) {
                  sandGame.graphics().drawRectangle(0, 0, -1, 0, Brushes.WATER, true);
              }),
              BenchmarkProvider.#createBenchmark('water-fall-s', 2000, function (sandGame, j) {
                  if (j % 10 === 0) {
                      sandGame.graphics().drawRectangle(0, 0, -1, 0, Brushes.WATER, true);
                  }
              }),
              BenchmarkProvider.#createBenchmark('water-fill', 1000, function (sandGame, j) {
                  if (j === 0) {
                      sandGame.graphics().drawRectangle(0, 0, -1, -1, Brushes.WATER, true);
                  }
              }),
              BenchmarkProvider.#createBenchmark('sand-into-water', 1000, function (sandGame, j) {
                  if (j === 0) {
                      sandGame.graphics().drawRectangle(0, 0, -1, 30, Brushes.SAND, true);
                      sandGame.graphics().drawRectangle(0, 60, -1, -1, Brushes.WATER, true);
                  }
              }),
              BenchmarkProvider.#createBenchmark('soil-into-water', 1000, function (sandGame, j) {
                  if (j === 0) {
                      sandGame.graphics().drawRectangle(0, 0, -1, 30, Brushes.SOIL, true);
                      sandGame.graphics().drawRectangle(0, 60, -1, -1, Brushes.WATER, true);
                  }
              }),
          ];
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-10-14
       */
      class ComponentViewTestTools extends Component {

          static COMPONENTS = [
              new ComponentButton("Tree spawn", ComponentButton.CLASS_SECONDARY, ActionsTest.TREE_SPAWN_TEST),
              new ComponentButton("Tree grow", ComponentButton.CLASS_SECONDARY, ActionsTest.TREE_GROW_TEST),

              new ComponentButton("Chunks", ComponentButton.CLASS_INFO, Action.createToggle(false, (c, v) => c.setShowActiveChunks(v))),
              new ComponentButton("M/webgl", ComponentButton.CLASS_INFO, Action.create(c => c.setRendererInitializer(RendererInitializer.canvasWebGL()))),
              new ComponentButton("M/classic", ComponentButton.CLASS_INFO, Action.create(c => c.setRendererInitializer(RendererInitializer.canvas2d()))),
              new ComponentButton("M/heatmap", ComponentButton.CLASS_INFO, Action.create(c => c.setRendererInitializer(RendererInitializer.canvas2dHeatmap()))),
              new ComponentButton("M/type", ComponentButton.CLASS_INFO, Action.create(c => c.setRendererInitializer(RendererInitializer.canvas2dElementType()))),
              new ComponentButton("M/null", ComponentButton.CLASS_INFO, Action.create(c => c.setRendererInitializer(RendererInitializer.nullRenderer()))),
              new ComponentButton("Pixelated", ComponentButton.CLASS_INFO, Action.createToggle(true, (c, v) => c.setCanvasImageRenderingStyle(v ? 'pixelated' : 'auto'))),

              new ComponentButton("Benchmark", ComponentButton.CLASS_WARNING, new ActionBenchmark()),
          ];


          createNode(controller) {
              let content = DomBuilder.div({ class: 'test-tools' }, []);

              let components = [...ComponentViewTestTools.COMPONENTS];
              for (let tool of Tools.TEST_TOOLS) {
                  let action = Action.create(c => c.getToolManager().setPrimaryTool(tool));
                  components.push(new ComponentButton(tool.getDisplayName(), ComponentButton.CLASS_SUCCESS, action));
              }

              for (let component of components) {
                  content.append(component.createNode(controller));
              }
              return content;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-10-15
       */
      class ComponentViewCanvas extends Component {

          #canvasHolderNode = DomBuilder.div({ class: 'sand-game-canvas-holder' });
          #currentCanvas = null;

          createNode(controller) {
              controller.registerCanvasInitializer((contextId) => {
                  this.#canvasHolderNode.empty();

                  const canvasComponent = new ComponentViewInnerCanvas(controller);
                  this.#canvasHolderNode.append(canvasComponent.createNode(controller));
                  this.#currentCanvas = canvasComponent;
                  return canvasComponent.getContext(contextId);
              });

              controller.addOnImageRenderingStyleChanged((imageRenderingStyle) => {
                  if (this.#currentCanvas !== null) {
                      this.#currentCanvas.setImageRenderingStyle(imageRenderingStyle);
                  }
              });

              controller.addOnInitialized((sandGame) => {
                  sandGame.addOnRendered((changedChunks) => {
                      // show highlighted chunks
                      if (controller.isShowActiveChunks()) {
                          this.#currentCanvas.highlightChunks(changedChunks);
                      } else {
                          this.#currentCanvas.highlightChunks(null);
                      }
                  });

                  // mouse handling
                  this.#currentCanvas.initMouseHandling(sandGame);
              });

              controller.addOnBeforeClosed(() => {
                  this.#currentCanvas = null;
                  this.#canvasHolderNode.empty();
              });

              return this.#canvasHolderNode;
          }
      }

      /**
       *
       *
       * @author Patrik Harag
       * @version 2023-10-15
       */
      class ComponentViewInnerCanvas extends Component {

          /** @type Controller */
          #controller;

          #nodeCanvas;

          /** @type SandGameCanvasDebugOverlayComponent */
          #debugOverlayComponent;
          #nodeDebugOverlay;

          /** @type SandGameCanvasCursorOverlayComponent */
          #cursorOverlayComponent;
          #nodeCursorOverlay;


          /**
           * @param controller {Controller}
           */
          constructor(controller) {
              super();
              this.#controller = controller;

              const w = this.#controller.getCurrentWidthPoints();
              const h = this.#controller.getCurrentHeightPoints();
              const scale = this.#controller.getCurrentScale();
              this.#nodeCanvas = this.#createCanvas(w, h, scale);

              this.#debugOverlayComponent = new SandGameCanvasDebugOverlayComponent(w, h, scale, controller);
              this.#nodeDebugOverlay = this.#debugOverlayComponent.createNode();

              this.#cursorOverlayComponent = new SandGameCanvasCursorOverlayComponent(w, h, scale, controller);
              this.#nodeCursorOverlay = this.#cursorOverlayComponent.createNode();
          }

          #createCanvas(w, h, scale) {
              const wPx = w / scale;
              const hPx = h / scale;
              const canvas = DomBuilder.element('canvas', {
                  style: `position: relative; width: ${wPx}px; height: ${hPx}px;`,
                  class: 'sand-game-canvas',
                  width: w + 'px',
                  height: h + 'px'
              });

              // rendering style
              let domCanvasNode = canvas[0];
              domCanvasNode.style.imageRendering = this.#controller.getCanvasImageRenderingStyle();

              return canvas;
          }

          createNode(controller) {
              return DomBuilder.div({
                  style: 'position: relative;',
                  class: 'sand-game-canvas-component'
              }, [
                  this.#nodeCanvas,
                  this.#nodeDebugOverlay,
                  this.#nodeCursorOverlay
              ]);
          }

          initMouseHandling(sandGame) {
              let domNode = this.#nodeCursorOverlay[0];
              const scale = this.#controller.getCurrentScale();

              let getActualMousePosition = (e) => {
                  const rect = domNode.getBoundingClientRect();
                  const x = Math.max(0, Math.trunc((e.clientX - rect.left) * scale));
                  const y = Math.max(0, Math.trunc((e.clientY - rect.top) * scale));
                  return [x, y];
              };

              let lastX, lastY;
              let lastTool = null;  // drawing is not active if null
              let ctrlPressed = false;
              let shiftPressed = false;

              this.#nodeCursorOverlay.bind('contextmenu', e => false);
              domNode.addEventListener('mousedown', (e) => {
                  const [x, y] = getActualMousePosition(e);
                  lastX = x;
                  lastY = y;
                  lastTool = null;
                  ctrlPressed = false;
                  shiftPressed = false;

                  if (e.buttons === 4) {
                      // middle button
                      e.preventDefault();

                      if (!e.altKey && !e.ctrlKey && !e.shiftKey) {
                          const tool = this.#controller.getToolManager().getTertiaryTool();
                          tool.applyPoint(x, y, sandGame.graphics(), false);
                          Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_TERTIARY);
                          Analytics.triggerToolUsed(tool);
                      } else if (e.altKey && e.ctrlKey && e.shiftKey) {
                          console.log('' + x + 'x' + y + ': ' + sandGame.debugElementAt(x, y));
                      }
                      return;
                  }

                  if (e.buttons === 1) {
                      lastTool = this.#controller.getToolManager().getPrimaryTool();
                      Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_PRIMARY);
                  } else {
                      lastTool = this.#controller.getToolManager().getSecondaryTool();
                      Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_SECONDARY);
                  }

                  if (e.ctrlKey && e.shiftKey) {
                      lastTool.applySpecial(x, y, sandGame.graphics(), e.altKey);
                      Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_FLOOD);
                      Analytics.triggerToolUsed(lastTool);
                      lastTool = null;
                      return;
                  }

                  if (!e.ctrlKey && !e.shiftKey) {
                      lastTool.applyPoint(x, y, sandGame.graphics(), e.altKey);
                      Analytics.triggerToolUsed(lastTool);
                  } else {
                      if (e.ctrlKey && lastTool.isSelectionEnabled()) {
                          ctrlPressed = e.ctrlKey;
                      }
                      if (e.shiftKey && lastTool.isStrokeEnabled()) {
                          shiftPressed = e.shiftKey;
                      }
                  }
                  // if (!lastTool.isStrokeEnabled()) {
                  //     lastTool = null;
                  // }
              });
              domNode.addEventListener('mousemove', (e) => {
                  if (!ctrlPressed && !shiftPressed) {

                      // show / move cursor
                      if (this.#cursorOverlayComponent.hasCursor()) {
                          const [x, y] = getActualMousePosition(e);
                          this.#cursorOverlayComponent.moveCursor(x, y, scale);
                      } else {
                          const cursorDefinition = this.#controller.getToolManager().getPrimaryTool().createCursor();
                          if (cursorDefinition !== null) {
                              const [x, y] = getActualMousePosition(e);
                              this.#cursorOverlayComponent.showCursor(x, y, scale, cursorDefinition);
                          }
                      }

                      if (lastTool === null) {
                          return;
                      }

                      // drawing
                      const [x, y] = getActualMousePosition(e);
                      lastTool.applyStroke(lastX, lastY, x, y, sandGame.graphics(), e.altKey);
                      Analytics.triggerToolUsed(lastTool);
                      lastX = x;
                      lastY = y;
                      return;
                  }

                  if (lastTool === null) {
                      return;
                  }
                  if (ctrlPressed && shiftPressed) {
                      return;
                  }
                  if (ctrlPressed) {
                      const [x, y] = getActualMousePosition(e);
                      this.#cursorOverlayComponent.repaintRectangleSelection(lastX, lastY, x, y, scale);
                      return;
                  }
                  if (shiftPressed) {
                      const [x, y] = getActualMousePosition(e);
                      this.#cursorOverlayComponent.repaintLineSelection(lastX, lastY, x, y, scale);
                      return;
                  }
              });
              domNode.addEventListener('mouseup', (e) => {
                  if (lastTool === null) {
                      return;
                  }
                  if (ctrlPressed) {
                      const [x, y] = getActualMousePosition(e);
                      let minX = Math.min(lastX, x);
                      let minY = Math.min(lastY, y);
                      let maxX = Math.max(lastX, x);
                      let maxY = Math.max(lastY, y);
                      lastTool.applyArea(minX, minY, maxX, maxY, sandGame.graphics(), e.altKey);
                      Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_RECT);
                      Analytics.triggerToolUsed(lastTool);
                  } else if (shiftPressed) {
                      const [x, y] = getActualMousePosition(e);
                      lastTool.applyStroke(lastX, lastY, x, y, sandGame.graphics(), e.altKey);
                      Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_LINE);
                      Analytics.triggerToolUsed(lastTool);
                  }
                  lastTool = null;
                  this.#cursorOverlayComponent.hideCursors();
              });
              domNode.addEventListener('mouseout', (e) => {
                  this.#cursorOverlayComponent.hideCursors();
              });
              domNode.addEventListener('mouseenter', (e) => {
                  if (lastTool !== null && e.buttons === 0) {
                      // mouse released outside...
                      lastTool = null;
                      this.#cursorOverlayComponent.hideCursors();
                      e.preventDefault();
                  }
              });

              // touch support

              let getActualTouchPosition = (e) => {
                  let touch = e.touches[0];
                  return getActualMousePosition(touch);
              };
              domNode.addEventListener('touchstart', (e) => {
                  const [x, y] = getActualTouchPosition(e);
                  lastX = x;
                  lastY = y;
                  lastTool = this.#controller.getToolManager().getPrimaryTool();
                  lastTool.applyPoint(x, y, sandGame.graphics(), false);
                  Analytics.triggerFeatureUsed(Analytics.FEATURE_DRAW_PRIMARY);
                  Analytics.triggerToolUsed(lastTool);

                  e.preventDefault();
              });
              domNode.addEventListener('touchmove', (e) => {
                  if (lastTool === null) {
                      return;
                  }
                  const [x, y] = getActualTouchPosition(e);
                  lastTool.applyStroke(lastX, lastY, x, y, sandGame.graphics(), false);
                  Analytics.triggerToolUsed(lastTool);
                  lastX = x;
                  lastY = y;

                  e.preventDefault();
              });
              domNode.addEventListener('touchend', (e) => {
                  lastTool = null;

                  e.preventDefault();
              });
          }

          getContext(contextId) {
              let domCanvasNode = this.#nodeCanvas[0];

              if (contextId === 'webgl' || contextId === 'webgl2') {
                  // handle WebGL failures

                  domCanvasNode.addEventListener('webglcontextlost', (e) => {
                      // GPU memory leak, GPU failure, etc.
                      // - to test this move the texture definition into rendering loop to create a memory leak

                      const cause = 'WebGL context loss detected. Using fallback renderer; game performance may be affected';
                      e.preventDefault();
                      setTimeout(() => {
                          this.#controller.restartAfterRenderingFailure(cause);
                      }, 2000);
                  }, false);
              }

              return domCanvasNode.getContext(contextId);
          }

          setImageRenderingStyle(style) {
              let domCanvasNode = this.#nodeCanvas[0];
              domCanvasNode.style.imageRendering = style;
          }

          highlightChunks(changedChunks) {
              this.#debugOverlayComponent.highlightChunks(changedChunks);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-05-09
       */
      class SandGameCanvasCursorOverlayComponent {

          /** @type Controller */
          #controller;

          #nodeOverlay;

          /** @type {{node:any,width:number,height:number}|null} */
          #cursor = null;

          constructor(w, h, scale, controller) {
              const wPx = w / scale;
              const hPx = h / scale;
              this.#nodeOverlay = DomBuilder.div({
                  style: `position: absolute; left: 0; top: 0; width: ${wPx}px; height: ${hPx}px;`,
                  class: 'sand-game-canvas-overlay',
                  width: w + 'px',
                  height: h + 'px',
              });
              this.#controller = controller;
          }

          createNode() {
              return this.#nodeOverlay;
          }

          hideCursors() {
              this.#nodeOverlay.empty();
              this.#cursor = null;
          }

          repaintRectangleSelection(lastX, lastY, x, y, scale) {
              this.#nodeOverlay.empty();

              let xPx = Math.min(lastX, x) / scale;
              let yPx = Math.min(lastY, y) / scale;
              let wPx = Math.abs(x - lastX) / scale;
              let hPx = Math.abs(y - lastY) / scale;

              const selection = DomBuilder.div();
              selection.css({
                  left: xPx + 'px',
                  top: yPx + 'px',
                  width: wPx + 'px',
                  height: hPx + 'px',
                  position: 'absolute',
                  outline: 'black 1px solid',
                  'pointer-events': 'none'
              });
              this.#nodeOverlay.append(selection);
          }

          repaintLineSelection(lastX, lastY, x, y, scale) {
              this.#nodeOverlay.empty();

              const w = this.#controller.getCurrentWidthPoints();
              const h = this.#controller.getCurrentHeightPoints();

              const line = DomBuilder.create(`
              <svg viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">
                <line x1="${lastX}" y1="${lastY}" x2="${x}" y2="${y}" stroke="black" />
              </svg>`
              );
              line.css({
                  'pointer-events': 'none'
              });
              this.#nodeOverlay.append(line);
          }

          showCursor(x, y, scale, cursorDefinition) {
              if (cursorDefinition instanceof CursorDefinitionElementArea) {
                  const wPx = Math.trunc(cursorDefinition.getWidth() / scale);
                  const hPx = Math.trunc(cursorDefinition.getHeight() / scale);

                  const node = DomBuilder.element('canvas', {
                      width: cursorDefinition.getWidth() + 'px',
                      height: cursorDefinition.getHeight() + 'px',
                      style: `width: ${wPx}px; height: ${hPx}px; outline: black 1px solid;`,
                  });

                  // render preview
                  let domCanvasNode = node[0];
                  domCanvasNode.style.imageRendering = 'pixelated';
                  Renderer2D.renderPreview(cursorDefinition.getElementArea(), domCanvasNode.getContext('2d'), 0xBB);

                  this.#cursor = {
                      width: wPx,
                      height: hPx,
                      node: node
                  };
              } else {
                  return;
              }

              this.#cursor.node.css({
                  position: 'absolute',
                  'pointer-events': 'none',
              });

              this.moveCursor(x, y, scale);
          }

          hasCursor() {
              return this.#cursor !== null;
          }

          moveCursor(x, y, scale) {
              const cursor = this.#cursor;

              const pxW = this.#controller.getCurrentWidthPoints() / scale;
              const pxH = this.#controller.getCurrentHeightPoints() / scale;

              const pxTop = y / scale - Math.trunc(cursor.height / 2);
              const pxLeft = x / scale - Math.trunc(cursor.width / 2);

              const UNSET = -1;  // expect border
              const pxClipTop = pxTop < 0 ? -pxTop : UNSET;
              const pxClipRight = pxLeft + cursor.width >= pxW ? pxLeft + cursor.width - pxW : UNSET;
              const pxClipBottom = pxTop + cursor.height >= pxH ? pxTop + cursor.height - pxH : UNSET;
              const pxClipLeft = pxLeft < 0 ? -pxLeft : UNSET;

              cursor.node.css({
                  top: pxTop + 'px',
                  left: pxLeft + 'px',
                  'clip-path': `inset(${pxClipTop}px ${pxClipRight}px ${pxClipBottom}px ${pxClipLeft}px)`
              });

              this.#nodeOverlay.empty();
              this.#nodeOverlay.append(cursor.node);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-05-14
       */
      class SandGameCanvasDebugOverlayComponent {

          /** @type Controller */
          #controller;

          #nodeOverlay;

          #w;
          #h;
          #scale;

          constructor(w, h, scale, controller) {
              this.#w = w;
              this.#h = h;
              this.#scale = scale;
              const wPx = w / scale;
              const hPx = h / scale;
              this.#nodeOverlay = DomBuilder.div({
                  style: `position: absolute; left: 0; top: 0; width: ${wPx}px; height: ${hPx}px;`,
                  class: 'sand-game-canvas-overlay',
                  width: w + 'px',
                  height: h + 'px',
              });
              this.#controller = controller;
          }

          /**
           *
           * @param changedChunks {boolean[]}
           */
          highlightChunks(changedChunks) {
              this.#nodeOverlay.empty();

              if (changedChunks) {

                  const sandGame = this.#controller.getSandGame();
                  const chunkSize = sandGame.getChunkSize();
                  const horChunkCount = Math.ceil(sandGame.getWidth() / chunkSize);
                  const verChunkCount = Math.ceil(sandGame.getHeight() / chunkSize);

                  let highlighted = 0;

                  for (let cy = 0; cy < verChunkCount; cy++) {
                      for (let cx = 0; cx < horChunkCount; cx++) {
                          const chunkIndex = cy * horChunkCount + cx;
                          if (changedChunks[chunkIndex]) {
                              this.#highlightChunk(cx, cy, chunkSize);
                              highlighted++;
                          }
                      }
                  }

                  // show stats
                  const total = horChunkCount * verChunkCount;
                  const highlightedPercent = Math.trunc(highlighted / total * 100);
                  this.#showText(0, 0, `${highlighted}/${total} (${highlightedPercent}%)`);
              }
          }

          #showText(x, y, text) {
              const label = DomBuilder.span(text);
              const xPx = x / this.#scale;
              const yPx = y / this.#scale;
              label.css({
                  left: xPx + 'px',
                  top: yPx + 'px',
                  position: 'absolute',
                  color: 'rgb(0, 255, 0)'
              });
              this.#nodeOverlay.append(label);
          }

          #highlightChunk(cx, cy, chunkSize) {
              const wPx = this.#w / this.#scale;
              const hPx = this.#h / this.#scale;
              const xPx = cx * chunkSize / this.#scale;
              const yPx = cy * chunkSize / this.#scale;
              const cwPx = chunkSize / this.#scale;
              const chPx = chunkSize / this.#scale;

              const selection = DomBuilder.div();
              selection.css({
                  left: xPx + 'px',
                  top: yPx + 'px',
                  width: cwPx + 'px',
                  height: chPx + 'px',
                  position: 'absolute',
                  outline: 'rgb(0, 255, 0) 1px solid'
              });

              if (xPx + cwPx >= wPx || yPx + chPx >= hPx) {
                  // clip

                  const UNSET = -1;  // expect border
                  const pxClipTop = UNSET;
                  const pxClipRight = xPx + cwPx >= wPx ? xPx + cwPx - wPx : UNSET;
                  const pxClipBottom = yPx + chunkSize >= hPx ? yPx + chPx - hPx : UNSET;
                  const pxClipLeft = UNSET;

                  selection.css({
                      'clip-path': `inset(${pxClipTop}px ${pxClipRight}px ${pxClipBottom}px ${pxClipLeft}px)`
                  });
              }

              this.#nodeOverlay.append(selection);
          }

          createNode() {
              return this.#nodeOverlay;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-06-05
       */
      class ComponentViewSceneSelection extends Component {

          static CLASS_SELECTED = 'selected-scene';
          static CLASS_VISITED = 'visited-scene';

          static SCENES = [
              'empty',
              'landscape_1',
              'landscape_2',
              'landscape_3',
              'landscape_4',
              'landscape_5',
              'fallthrough',
              'platform'
          ];


          /** @type Controller */
          #controller;

          #ignoreOnBeforeNewSceneLoaded = false;

          #initialScene;

          #selected = null;
          #selectedSceneId = null;

          #closedScenes = new Map();

          /**
           * @param controller {Controller}
           * @param initialScene
           */
          constructor(controller, initialScene) {
              super();
              this.#controller = controller;
              this.#initialScene = initialScene;

              this.#controller.addOnBeforeNewSceneLoaded(() => {
                  if (!this.#ignoreOnBeforeNewSceneLoaded) {
                      this.#store();
                      this.#unselect();
                  }
              });
          }

          createNode(controller) {
              let content = DomBuilder.div({ class: 'scenes' }, []);
              for (let id of ComponentViewSceneSelection.SCENES) {
                  let scene = Scenes.SCENES[id];

                  let label = DomBuilder.element('span', { class: 'scene-title' }, scene.name);
                  // scene.description ? scene.description : '\u00A0'
                  let node = DomBuilder.button(label, { class: 'btn btn-outline-secondary scene' }, () => {
                      this.#onSelect(id, node, scene);
                  });

                  // mark initial scene
                  if (id === this.#initialScene) {
                      this.#selected = node;
                      this.#selectedSceneId = id;
                      node.addClass(ComponentViewSceneSelection.CLASS_SELECTED);
                      node.addClass(ComponentViewSceneSelection.CLASS_VISITED);
                  }

                  content.append(node);
              }

              return content;
          }

          #onSelect(id, node, scene) {
              if (this.#selected) {
                  if (this.#selectedSceneId === id) {
                      // already opened - rebuild scene
                      this.#rebuildConfirm(() => {
                          this.#select(node, id, scene);
                          Analytics.triggerFeatureUsed(Analytics.FEATURE_RESTART_SCENE);
                      });
                  } else {
                      // store snapshot of the old scene and open...
                      this.#store();
                      this.#select(node, id, scene);
                      Analytics.triggerFeatureUsed(Analytics.FEATURE_SWITCH_SCENE);
                  }
              } else {
                  // open
                  this.#select(node, id, scene);
                  Analytics.triggerFeatureUsed(Analytics.FEATURE_SWITCH_SCENE);
              }
          }

          #rebuildConfirm(onConfirm) {
              let dialog = new DomBuilder.BootstrapDialog();
              dialog.setHeaderContent('Restart scene');
              dialog.setBodyContent([
                  DomBuilder.par(null, "Do you want to restart the scene?")
              ]);
              dialog.addSubmitButton('Confirm', onConfirm);
              dialog.addCloseButton('Close');
              dialog.show(this.#controller.getDialogAnchor());
          }

          #select(node, id, scene) {
              this.#unselect();

              this.#selected = node;
              this.#selectedSceneId = id;
              node.addClass(ComponentViewSceneSelection.CLASS_SELECTED);
              node.addClass(ComponentViewSceneSelection.CLASS_VISITED);

              // restore or build scene
              let snapshot = this.#closedScenes.get(id);
              if (snapshot) {
                  this.#closedScenes.delete(id);

                  this.#ignoreOnBeforeNewSceneLoaded = true;
                  this.#controller.openScene(new SceneImplSnapshot(snapshot));
                  this.#ignoreOnBeforeNewSceneLoaded = false;
              } else {
                  this.#ignoreOnBeforeNewSceneLoaded = true;
                  this.#controller.openScene(scene);
                  this.#ignoreOnBeforeNewSceneLoaded = false;
              }
          }

          #unselect() {
              if (this.#selected) {
                  this.#selected.removeClass(ComponentViewSceneSelection.CLASS_SELECTED);
              }
              this.#selected = null;
              this.#selectedSceneId = null;
          }

          #store() {
              if (this.#selected) {
                  this.#closedScenes.set(this.#selectedSceneId, this.#controller.createSnapshot());
              }
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ActionDialogChangeCanvasSize extends Action {

          performAction(controller) {
              let formBuilder = new DomBuilder.BootstrapSimpleForm();
              formBuilder.addInput('Width', 'width', '' + controller.getCurrentWidthPoints());
              formBuilder.addInput('Height', 'height', '' + controller.getCurrentHeightPoints());
              formBuilder.addInput('Scale', 'scale', '' + controller.getCurrentScale());

              let dialog = new DomBuilder.BootstrapDialog();
              dialog.setHeaderContent('Change canvas size manually');
              dialog.setBodyContent(formBuilder.createNode());
              dialog.addSubmitButton('Submit', () => {
                  let data = formBuilder.getData();
                  let w = Number.parseInt(data['width']);
                  let h = Number.parseInt(data['height']);
                  let s = Number.parseFloat(data['scale']);
                  controller.changeCanvasSize(w, h, s);
                  Analytics.triggerFeatureUsed(Analytics.FEATURE_CANVAS_SIZE_CHANGE);
              });
              dialog.addCloseButton('Close');
              dialog.show(controller.getDialogAnchor());
          }
      }

      var img$3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAABQCAYAAADSm7GJAAAAAXNSR0IArs4c6QAABYVJREFUeF7tm02S1DAMhdNVsx4OQNH34FCchkNxj6E4AKynCmpCu0k8lvWeJKexY3YQ/0jvk2Q5HS7L/DO0ApehvZvOLRPw4EEwAU/AgyswuHszgyfgwRUY3L2ZwRPw4AoM7t7M4Al4cAUGd29m8AQ8uAKDuzczeAIeXIHB3ZsZPAEPrsDg7s0MnoAHV2Bw92YGT8CDKzC4ezODN4Bfv15/b3k/fXnpXp/uHYhKwBxuWrd3yBPwsiwS3BEgnx6wBrd3yKcGjMLtGfJpAbNwe4V8SsBWuD1CPh1gL9zeIJ8KcBTcniCfBnA03F4gPwzwVvDWLxNawe0B8kMAlwRvBdkK9/Xnj+Xpw0f4RVkr+2EDhIGHA64JHi0SCjfBzKGOAPlQwIjgUZC1vVB46Lj/tVwfBlgTPPJXHGkvKVO1Mtgz5EMAM3C9maDB1WDunj9fl+XXy/pPbHBEVSLK3sLg5oAtcK2QTXttIBbF7BxyU8AmwTOV0Uww7aXBLRDvLZObATYJLtQjDbJpLwPcZF5PkJsANgmuHDYSZPbMZRsmyaxeIIcDpuESmZRDZuFqZ6y1oUGDRqtE9wqx+TYMnSPZHgqYhmtQNDkcAnfTHVdNIYJQc0kDFv2WLwywGW6geJq4rTKY3Zc9bt7W1wKjaQab4eZWBcBGy2XeMLGQvOPR42a7jwWyO4PD4DaADUHQgkp7XtlECzbtuCktzUJ2AVbhOsRZnfPOr9xjofUd+7NdNhSMt0EMZDNgFS5j8RFjC7CqGZbGA5BbwpSkQSGbAHcDV4MEwMvPahamVqY9sY1ApgFHwEVFysdJf5e649fv39Yf7aHfewnYHijRczXIFGAYLiFWaITnGavZoWV4AI1Q/wR7apBhwJFwvV9OQLoDcFOGQ+sdNUizm4QMAYbhHiWCdZ9cPKOY1u3FeUF2lDJZBUzDZY19vi6HZBLbRYdTBBdk9cuWzSFXAdNwQR/uw1qdgUCmrsfEp8/3LzYk01ufoS3W30IWAZfgQt2vMwLhGJEaKmB/yA/YkNvASrC2gKiZlyAXAb/BRUVAx+0MAiBIV5/0jVTVQaCbRkXfZbojqLz3aQ1o6fkb5HeAPWUZLXsUnDTYGhTSZpUg2MEHyr1FfGQOGoS1tXaA73AdjQ9rFDQ+AK52NatWooD9EaClMZA+lcXvgD2ZSxnPihXQiElwoXfReQXx2g8cH9bjqeTPCrjWUFHwDINDynplX1OPYPCj2GOwweDYVwrWS/PM1RoTx3GA6uEqc2jGEZWGtSdPAuadvAgYMkKLUO9zlKDWSLHrAEG5dvMEVNYEa5nO57XPYMKz0HItBRcKL7dbC1bCz/zKpE2tdvXK5LYZbBCpeO/UFMgbIakxskJC56XjxvqGDN0H1WNZluMymDCeitgH3lOrOgO9BeondFwKxmAZbBWRgCqJtWsoUmZo5bewWKoM6w8bQIYRSSIPrUD2QGNs0zOYgIRGJGPgtpEpfqHRGpbV/8pH9UW4lX08waADLtEodI+hDVISR4K3EUO6MoTcf4EMtIpvmkcEW8KmAzaUQypDgcHeyqAFgXaWWv8TOODavyGFoC122yRkHTBjJbk5srSpMgTYwbxMQPwIHUP4ZwJseodr9RB1hmgEtYw2lU/CP239/LlHbxqwZtzOTxQOIU4+FIVVPZPZN1Loy5LCuF0XH6WPZA97D7aKqc3T+FLzgW4UClIrRM2ZynPJLsjefN2b/XAGmzYRNoU1qERmVKUI6bZhh+SBmr7ac2llCLB1cag79ZYp7/yNkdF+autpz6XjiIknFTBrBLP5u7Foxro2OXbyofoVXKsCfrRxq71sA2TlF1gJivdXq13OeWoGO9f/O72BeCF2nWCRYwCXMvGozDwBxJqLfwC3Xx8QFU4bsQAAAABJRU5ErkJgggAA";

      var img$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAABQCAYAAADSm7GJAAAAAXNSR0IArs4c6QAAAshJREFUeF7tm81NxDAQhb0iB05QAGL7QKIXKqADjnRABfSCRB8gCoATh0WglbhlIr3k5cee/TiiceJ53zx74mR3hb/UCuxSZ0dyBcDJiwDAAE6uQPL0cDCAkyuQPD0cDODkCiRPDwcDOLkCydPDwQBOrkDy9HAwgJMrkDw9HAzg5AokTw8HAzi5AsnTw8EATq5AKeXwtP/tZXmx7/2ru3tpzhDNTXiJcgPwEqpWdE0AVwRjiakAeAlVK7omgCuC4U7l8Hzbb6i+3rTLNth4nVyTBWCtlpuNAnCz6LSJA1jTqdkoAC+ALupSD58fvTudP/zM2hN8P571Gqru8krLMGioitiMdfdvs+ahTTiOWmUiAHYQeWMBPKQfDtYrCwfrWs0diYNx8LiamruxUV/ROd1x1PDJzZgoz1aN1+wOBnBMHMBHXYyzXhy80mMSDsbBw7sWDhZ3dD3M2oPD96jBvddoYvSUxcig2A7vr73BTjMW7cvRVqM2mlFmAB7xmATgAbFwsL4v42BxhbXDWKIHvidmD5Zrq6o9eJWGyjjgl1UVA8Nt5fqmP1p8hRje1shXPTiRmywAl9IBuBSroTIqWjSmHIaDl+iYAVzm/mqEJXpMoWZZoq3zZHURrN2t6rdbFeUbNV6hgwFcinMEOXfHrNYQgMcsxzhYrauBOJZouaFSlcbBp+hg9QAj+tpCbenVCqwpznqeVxNZYRXbATimAeCjLs45rFrlG8UBGMB+6bFE+xpOvcLpOXiqUozbVAG9ydp0mtx8qgIAnqpcI+MA3AioqdME8FTlGhkH4C1BVfWYtKUQWe8N4Kxk//MCMIBdBdiDXQWd8TjYUW+lsSv8xMXJBAc76h3HAthVsPLxAK4ckDs9ALsKVj4ewJUDWmJ6anesxhlzpMkyxBscqoJT44w5AtgQD8BLiNfCNVVnqnFGzjjYEK8FB/8B2TwUOyr+yDQAAAAASUVORK5CYIIA";

      var img$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAABQCAYAAADSm7GJAAAAAXNSR0IArs4c6QAAAr1JREFUeF7tnMFNw0AQRdfCB05QACJ9UA0V0AFHOkhLSPQRRAFw4hAEQsFKOJD/h0wU7+hx3dGu5/954/XaZGj8lVZgKJ0dyTUMLl4EGIzBxRUonh4EY3BxBYqnB8EYXFyB4ulBMAYXV6B4ehCMwcUVKJ4eBGNwcQWKpwfBGFxcgeLpQTAG11VgvVx8quzGu1XXEHR98cocNY7BSqHOxzG4cwPV5WOwUqjzcQzu3EB1+RisFOp8HIM7N1BdPgYrhTofx+BkA98fzuTBwvn9R8qzubPWeHklM1y/vsiYrGuWC/0jIEVMd11H9CyxnLUw2HXOjHNEx2BTTDMMgoVQtGizkr7DIDggVlIoBENwUilBcJ6QgZkgGIID5SJCuQfnaenOlEawcyrkXJSzax2vb/RUbysdkxVxsZAzjbePaVrLxXYC0hbF4P2yY/CPPhAc4VPHQrDWSEfQorVGUwQE+1o5kRDsqKRiIFgptB2HYF8rJxKCHZVUDAQrhSDYVygWaRFsPeMaVdxmdviwfn6SajkfBchJEgOi/0qDwUJ8DJ4EguBETv+eCoIDBUeLno4PjX+zbBAMwWyyDq8BWjQt+lcVsYtmF90az8GHt9asGcIt2vmMJu0LCmMj1uPO1jHvVGfsAwY79hweg8HTI1mHx4eO/RiMwS3tVrhTcbRoB7+EGAiGYAieQJrbGx4HcAiGYAiG4Nai5/mDdUrl9CAjxmpTxu9mGEvlhRiHM5boSfNENcRgVQpJxmS9TsVgZVh0HIN9xaLV5898xEgM9sXFYKGV8dVpVEPuwao+IVgptB2PVp8/8xEjMdgXF4Np0W12x5AQvKnKLuk0mo+Vl/GbIaf6UiVtk2UJMbdTKgw2FJheEhg/uzu79mukZxUuBG+UxOD9FXUMfWjRgmIIpkVb73HZZBn3w1OEQDAEz5rgL/wOaufG8L64AAAAAElFTkSuQmCC";

      var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAABQCAYAAADSm7GJAAAAAXNSR0IArs4c6QAAAmJJREFUeF7tm8FNxEAMRWelnKEAxPZBNVRANbREJStRwHJeCU5c4OLvH8mO93G2NZ738jNZopwWf6MJnEbvjs0tBA+/CBCM4OEEhm+PBCN4OIHh2yPBCB5OYPj2SDCChxMYvj0SjODhBIZvjwQjeDiB4du7uwTf3s/fWafb2+VwvA43cFbObx+CXYLN+xHcXJA7HoJdgs37EdxckDsegl2CzfsR3FyQOx6CXYLN+xHcXJA7HoJdgs37EdxckDsegl2CzfsR3FyQOx6CXYLN+xEsCHJgrYezsNKf0q9Luvd2/Uz3bs8v+d7Xj5I3d9aiCI773hAch7VIcBgWCQ6jWotbtACLM1iBla8lwQI7EizAIsEKrHwtCRbYkWABFglWYOVrSbDAjgQLsEiwAitfS4IFdiRYgEWCFVj5WhIssCPBAiwSrMDK156cN0LWq7fHp/TUVeumB15rVc2MYMea0IvgA8ASRvxXimCBXhUsYUQEb5zB4evFYcUZHMbsFVbddRDseQt3IziMqu4nhzAiZ7BzrlSlAcECAQTHYTmsOIPjnK3KqrsOgi1t8WYEx1mV/V9XGJGHLOdcqUoDggUCCI7DclhZZ3DVO904mn0rrTuH8WWi8y0WgoVrAMECLOeqVJbZsxbBCk3jE1BlmT1rEazQRHCclsGKMziO2fv9zUOWQLqolFu0At647SjL7FmLYIUmguO0DFacwXHMnMECq8XvYIEWCRZgGaWcwQo846pUltmzFsEKTQTHaRmseMiKY77DhywBDqU1BLwE18zMqgIBBAuwjliK4CNaE2ZGsADriKU/CCIQ8w+JyEIAAAAASUVORK5CYIIA";

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ComponentViewElementSizeSelection extends Component {

          static CLASS_SELECTED = 'selected-size';

          static SIZES = [
              { scale: 0.75,  image: img$3, description: 'Very small Cheese' },
              { scale: 0.5,   image: img$2, description: 'Small Cheese' },
              { scale: 0.375, image: img$1, description: 'Medium Cheese' },
              { scale: 0.25,  image: img, description: 'Chonky Cheese' },
              { scale: 0.1,  image: img, description: 'Chonkyest Cheese' },
          ];


          #nodes = [];

          #selected = null;
          #selectedScale = null;

          createNode(controller) {
              for (let sizeDef of ComponentViewElementSizeSelection.SIZES) {
                  let node = this.#createSizeCard(sizeDef.scale, sizeDef.image, sizeDef.description);

                  // initial scale
                  if (sizeDef.scale === controller.getCurrentScale()) {
                      this.#mark(node, sizeDef.scale);
                  }

                  node.on('click', e => {
                      this.#select(node, sizeDef.scale, controller);
                  });

                  this.#nodes.push(node);
              }

              return DomBuilder.div(null, [
                  DomBuilder.par(null, "Increasing the size of the elements will result in the top and right" +
                      " parts of the canvas being clipped."),
                  DomBuilder.par(null, "Reducing the size of the elements will result in an expansion of" +
                      " the canvas in the upper and right parts."),
                  DomBuilder.par(null, "Only the scale of the current scene and the initial setting for new" +
                      " scenes will be changed. Scene can be regenerated by clicking on the scene card."),

                  DomBuilder.div({ class: 'element-size-options' }, this.#nodes)
              ]);
          }

          #select(node, newScale, controller) {
              if (this.#selectedScale === newScale) {
                  return;  // already selected
              }

              // mark selected
              if (this.#selected) {
                  this.#selected.removeClass(ComponentViewElementSizeSelection.CLASS_SELECTED);
              }
              this.#mark(node, newScale);

              // change scale
              let w = Math.trunc(controller.getCurrentWidthPoints() / controller.getCurrentScale() * newScale);
              let h = Math.trunc(controller.getCurrentHeightPoints() / controller.getCurrentScale() * newScale);
              controller.changeCanvasSize(w, h, newScale);

              Analytics.triggerFeatureUsed(Analytics.FEATURE_SWITCH_SCALE);
          }

          #mark(node, scale) {
              node.addClass(ComponentViewElementSizeSelection.CLASS_SELECTED);
              this.#selected = node;
              this.#selectedScale = scale;
          }

          /**
           *
           * @param scale {number}
           * @param image {string}
           * @param description {string}
           */
          #createSizeCard(scale, image, description) {
              return DomBuilder.div({ class: 'card' }, [
                  DomBuilder.element('img', { src: image, alt: description })
              ]);
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ActionDialogChangeElementSize extends Action {

          performAction(controller) {
              let elementSizeComponent = new ComponentViewElementSizeSelection();

              let dialog = new DomBuilder.BootstrapDialog();
              dialog.setHeaderContent('Adjust Scale');
              dialog.setBodyContent(DomBuilder.div({ class: 'sand-game-component' }, [
                  elementSizeComponent.createNode(controller)
              ]));
              dialog.addSubmitButton("Set size manually", () => {
                  new ActionDialogChangeCanvasSize().performAction(controller);
              });
              dialog.addCloseButton('Close');
              dialog.show(controller.getDialogAnchor());
          }
      }

      var _ASSET_SVG_ADJUST_SCALE = "<!-- @author Patrik Harag -->\r\n<svg width=\"64\" height=\"64\" viewBox=\"0 0 64 64\" xmlns=\"http://www.w3.org/2000/svg\">\r\n <g>\r\n  <rect stroke=\"#505050\" stroke-width=\"4\" id=\"svg_1\" height=\"24\" width=\"24\" y=\"35.5\" x=\"4.5\" fill=\"none\"/>\r\n  <rect stroke=\"#505050\" stroke-width=\"2\" stroke-dasharray=\"3,5\" id=\"svg_2\" height=\"54\" width=\"54\" y=\"4.5\" x=\"4.5\" fill=\"none\"/>\r\n  <line stroke=\"#505050\" id=\"svg_3\" y2=\"10.65089\" x2=\"51.9999\" y1=\"27.9524\" x1=\"34.38094\" stroke-width=\"4\" fill=\"none\"/>\r\n  <line stroke=\"#505050\" id=\"svg_4\" y2=\"11.28581\" x2=\"50.73007\" y1=\"13.98421\" x1=\"37.87298\" stroke-width=\"4\" fill=\"none\"/>\r\n  <line stroke=\"#505050\" id=\"svg_5\" y2=\"11.762\" x2=\"51.36499\" y1=\"23.82543\" x1=\"48.82531\" stroke-width=\"4\" fill=\"none\"/>\r\n </g>\r\n</svg>";

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class ComponentButtonAdjustScale extends Component {

          createNode(controller) {
              return DomBuilder.button(DomBuilder.create(_ASSET_SVG_ADJUST_SCALE), {
                  class: 'btn btn-outline-secondary adjust-scale',
                  'aria-label': 'Adjust scale'
              }, () => {
                  new ActionDialogChangeElementSize().performAction(controller);
              });
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-19
       */
      class MainComponent extends Component {

          #init;
          #enableTestTools = false;

          constructor(init) {
              super();
              this.#init = init;
          }

          enableTestTools() {
              this.#enableTestTools = true;
          }

          createNode(controller) {
              let componentNode = DomBuilder.div({ class: 'sand-game-component' });

              controller.registerDialogAnchor(componentNode);

              componentNode.append(new ComponentViewTools(Tools.DEFAULT_TOOLS, true).createNode(controller));
              componentNode.append(new ComponentViewCanvas().createNode(controller));
              componentNode.append(new ComponentViewOptions().createNode(controller));
              componentNode.append(DomBuilder.div({ class: 'sand-game-views' }, [
                  DomBuilder.div(null, [
                      new ComponentButtonAdjustScale().createNode(controller),
                      DomBuilder.span('Scenes', { class: 'scenes-label' }),
                      new ComponentViewSceneSelection(controller, this.#init.scene).createNode(controller),
                  ]),
                  this.#enableTestTools ? new ComponentViewTestTools().createNode(controller) : null,
              ]));

              return componentNode;
          }
      }

      /**
       *
       * @author Patrik Harag
       * @version 2023-08-20
       */

      const brushes = {};
      for (let brush of Brushes.LIST) {
          brushes[brush.codeName] = brush.brush;
      }

      function determineSize(root) {
          let parentWidth;
          if (window.innerWidth <= 575) {
              parentWidth = window.innerWidth;  // no margins
          } else {
              parentWidth = root.width();
          }

          let width = Math.min(1400, parentWidth);
          let height = Math.min(800, Math.trunc(window.innerHeight * 0.70));
          if (width / height < 0.75) {
              height = Math.trunc(width / 0.75);
          }
          return {width, height};
      }

      function determineMaxNumberOfPoints() {
          const touchDevice = (navigator.maxTouchPoints || 'ontouchstart' in document.documentElement);
          if (touchDevice) {
              // probably a smartphone
              return 75000;
          } else {
              return 125000;
          }
      }

      function determineOptimalScale(width, height, maxPoints) {
          function countPointsWithScale(scale) {
              return Math.trunc(width * scale) * Math.trunc(height * scale);
          }

          if (countPointsWithScale(0.750) < maxPoints) {
              return 0.750;
          } else if (countPointsWithScale(0.5) < maxPoints) {
              return 0.5;
          } else if (countPointsWithScale(0.375) < maxPoints) {
              return 0.375;
          } else {
              return 0.25;
          }
      }

      function initStandard(root) {
          const {width, height} = determineSize(root);
          const scale = determineOptimalScale(width, height, determineMaxNumberOfPoints());

          const init = {
              scale: scale,
              canvasWidthPx: width,
              canvasHeightPx: height,
              scene: (Math.random() > 0.1) ? 'landscape_1' : 'landscape_2'
          };

          const controller = new Controller(init);
          const mainComponent = new MainComponent(init);
          const node = mainComponent.createNode(controller);
          root.append(node);

          controller.setup();
          controller.getIOManager().initFileDragAndDrop(node);
          controller.enableGlobalShortcuts();
          controller.start();

          Analytics.triggerFeatureUsed(Analytics.FEATURE_APP_INITIALIZED);

          return controller;
      }

      function initTest(root) {
          const {width, height} = determineSize(root);
          const scale = determineOptimalScale(width, height, determineMaxNumberOfPoints());

          const init = {
              scale: scale,
              canvasWidthPx: width,
              canvasHeightPx: height,
              scene: 'landscape_1'
          };

          const controller = new Controller(init);
          const mainComponent = new MainComponent(init);
          mainComponent.enableTestTools();
          const node = mainComponent.createNode(controller);
          root.append(node);

          controller.setup();
          controller.getIOManager().initFileDragAndDrop(node);
          controller.enableGlobalShortcuts();
          controller.start();

          Analytics.triggerFeatureUsed(Analytics.FEATURE_APP_INITIALIZED);

          return controller;
      }

      exports.brushes = brushes;
      exports.initStandard = initStandard;
      exports.initTest = initTest;

      Object.defineProperty(exports, '__esModule', { value: true });

  }));</script>
  <style>

    /*
     * @author Patrik Harag
     * @version 2023-08-10
     */
    body{
    
        background-image: url('data:image/png;base64,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');
    }
    .sand-game-component.drag-and-drop-highlight {
        outline: rgba(0, 129, 255, 0.76) dashed thick;
        outline-offset: 2px;
    }

    .sand-game-component .sand-game-canvas-component .sand-game-canvas {
        outline: 1px solid #b7b7b7;
    }

    @media (max-width: 575px) {
        .sand-game-component .sand-game-canvas-component {
            margin-left: -15px;
            margin-right: -15px;
        }

        .sand-game-component .sand-game-canvas-component .sand-game-canvas {
            outline: none;
        }
    }

    .sand-game-component .sand-game-canvas-overlay {
        cursor: crosshair;
        user-select: none;
    }

    .sand-game-component .sand-game-tools {
        display: inline-block;
        user-select: none;
        margin-bottom: 4pt;
    }

    .sand-game-component .sand-game-tools .badge {
        margin-right: 3pt;
        padding: 0.4em 0.4em;
        border: none;
    }

    .sand-game-component .badge.air {
        background-color: rgb(230, 230, 230);
        color: black;
        margin-right: 0.8em;
    }

    .sand-game-component .badge.sand {
        background-color: rgb(228,211,162);
    }

    .sand-game-component .badge.soil {
        background-color: rgb(249,192,46);
    }

    .sand-game-component .badge.gravel {
        background-color: rgb(229,172,26);
    }

    .sand-game-component .badge.wall {
        background-color: rgb(248, 132, 3);
    }

    .sand-game-component .badge.wood {
        background-color: rgb(221,180,117);
    }
    .sand-game-component .badge.wax {
        background-color: #A12727;
    }
    .sand-game-component .badge.red_sand {
        background-color: #bc714b;
    }
    .sand-game-component .badge.blue_stone {
        background-color: #ebe1c1;
    }
    .sand-game-component .badge.tree {
        background-color: rgb(221,180,117);
    }
    .sand-game-component .badge.glitch {
        background-color: #ff00ff;
    }
    .sand-game-component .badge.real_wood {
        background-color: rgb(244, 206, 149);
    }
    .sand-game-component .badge.fish {
        background-color: #4a400e;
    }

    .sand-game-component .badge.water {
        background-color: rgb(255, 166, 0);
    }
    .sand-game-component .badge.sauce {
        background-color: #C5A24E;
    }

    .sand-game-component .badge.fire {
        background-color: #FCB05A;
    }

    .sand-game-component .badge.fire.selected {
        outline: black solid 1px;
    }
    .sand-game-component .badge.grass {
        background-color: #DA7403;
    }
    .sand-game-component .badge.rock {
        background-color: #FC931E;
    }

    .sand-game-component .badge.meteor {
        background-color: #FCB05A;
    }

    .sand-game-component .badge.meteor.selected {
        outline: black solid 1px;
    }

    .sand-game-component .badge.template {
        background-color: #DBC673;
        margin-left: 0.4em;
    }

    .sand-game-component .badge.selected {
        outline: rgb(0, 0, 0) solid 1px;
    }

    .sand-game-component .sand-game-options {
        white-space: nowrap;
        display: inline-block;
    }

    .sand-game-component .sand-game-options .btn {
        color: gray;
        padding: 0 0.5em 0 0.5em;
        margin-right: 0.5em;
        vertical-align: baseline;
        font-size: 75%;
    }

    .sand-game-component .sand-game-options .btn .bi {
        width: 12px;
        height: 12px;
        vertical-align: -1px;
    }

    .sand-game-component .sand-game-options .dropdown-menu .btn {
        font-size: 100%;
    }

    .sand-game-component .sand-game-options .dropdown-menu {
        user-select: none;
        font-size: small;
    }

    @media (max-width: 575px) {
        .sand-game-component .sand-game-options .status-label {
            display: none;
        }
    }

    .sand-game-component .sand-game-options .status-stopped {
        color: blue;
    }

    .sand-game-component .sand-game-options .status-best {
        color: green;
    }

    .sand-game-component .sand-game-options .status-good {
        color: green;
    }

    .sand-game-component .sand-game-options .status-medium {
        color: #ffcc00;
    }

    .sand-game-component .sand-game-options .status-low {
        color: #ff4400;
    }

    .sand-game-component .sand-game-options .status-poor {
        color: red;
    }

    .sand-game-component .sand-game-views:has(div) {
        margin: 1em 0 2em;
    }

    .sand-game-component .sand-game-views .btn-outline-secondary:hover {
        background-color: #ebebeb;
    }

    .sand-game-component .sand-game-views .adjust-scale {
        vertical-align: top;
        margin-right: 0.5em;
        height: 46px;
    }

    .sand-game-component .sand-game-views .adjust-scale svg {
        width: 30px;
        height: 30px;
    }

    .sand-game-component .sand-game-views .scenes-label {
        color: gray;
        font-size: small;
        transform: rotate(-70deg);
        display: inline-block;
        user-select: none;

        padding-left: 6px;
        margin-left: -6px;
        margin-right: -3px;
    }

    .sand-game-component .sand-game-views .scenes {
        display: inline;
    }

    .sand-game-component .sand-game-views .scenes .scene {
        color: black;
        cursor: pointer;
        display: inline-block;
        margin: 0 0.5em 0.5em 0;
        height: 46px;
        user-select: none;
        white-space: nowrap;
    }

    .sand-game-component .sand-game-views .scenes .scene .card-title {
        font-weight: 500;
        font-size: 100%;
    }

    .sand-game-component .sand-game-views .scenes .scene.visited-scene {
        background-color: #ebebeb;
    }

    .sand-game-component .sand-game-views .scenes .scene.visited-scene:hover {
        background-color: #dedede;
    }

    .sand-game-component .sand-game-views .scenes .scene.selected-scene {
        background-color: #ffffbd;
    }

    .sand-game-component .sand-game-views .scenes .scene.selected-scene:hover {
        background-color: #e8e8a5;
    }

    .sand-game-component .sand-game-views .card {
        margin: 0.5em 0;
    }

    .sand-game-component .element-size-options {
        white-space: nowrap;
    }

    .sand-game-component .element-size-options .card {
        cursor: pointer;
        display: inline-block;
        margin: 0.5em 0.5em 0.5em 0;
        width: 48pt;
        height: 32pt;
        user-select: none;
    }

    .sand-game-component .element-size-options .card img {
        width: 47pt;
        height: 31pt;
        border-radius: 0.25rem;
    }

    .sand-game-component .element-size-options .card:hover {
        background-color: #ebebeb;
    }

    .sand-game-component .element-size-options .card.selected-size {
        background-color: #ffffbd;
    }

    .sand-game-component .element-size-options .card.selected-size:hover {
        background-color: #e8e8a5;
    }

    .sand-game-component .test-tools .btn {
        margin-right: 0.5em;

        padding: 0 0.5em 0 0.5em;
        font-size: 75%;
    }

    .sand-game-component .sand-game-templates .template-button {
        margin-right: 0.5em;
        margin-top: 0.5em;
        background-position: center top;
        background-repeat: no-repeat;
        background-position-y: 5px;
        width: 100px;
        height: 100px;
        padding-top: 50px;  /* Label location */
    }

  </style>
  <script>
      // global variables, accessible from browser console
      var sandGame = null;
      var brushes = null;

      $(() => {
          let root = $('#sand-game-root');
          root.empty();

          // const controller = SandGameJS.initStandard(root);
          const controller = SandGameJS.initTest(root);
          sandGame = controller.getSandGame();
          controller.addOnInitialized(s => {
              sandGame = s;
          });
          if (SandGameJS.brushes !== undefined) {
            brushes = SandGameJS.brushes;
            console.log('Globals:');
            console.log('  sandGame, brushes');
            console.log('Examples:');
            console.log('  sandGame.graphics().drawLine(10, 10, 300, 150, 2, brushes.sand);');
            console.log('  sandGame.graphics().draw(100, 20, brushes.meteor);');
          }
      });
  </script>
</head>
<body></audio>
<main role="main" class="container">
  <h1>Cheese game</h1>
  <div id="sand-game-root">
    <!-- Sand Game JS placeholder -->
    <div style="user-select: none;">
      <div>
        <button disabled class="badge badge-secondary" type="button" style="min-width: 4em; padding: 0.4em 0.4em; border: none; background-color: rgb(230, 230, 230); color: black;">&nbsp;</button>
      </div>
      <div style="height: 70vh; display: flex; align-items: center; justify-content: center; margin-top: 4pt; padding: 2em; outline: 1px solid #b7b7b7;">
        <div>
          Loading...
        </div>
      </div>
      <div style="height: 20vh"></div>
    </div>
  </div>
</main>
<footer class="container" style="font-size: small">
  <p>
    <a href="https://github.com/Hartrik/sand-game-js">https://github.com/Hartrik/sand-game-js</a>
  </p>
</footer>
<!--
  cr**py script
<script>
  function addEvent(){
     document.body.addEventListener("onmousedown", play)
   }
  function play() {
    var audio = document.getElementById("audio");
    audio.play();
  }
  function pause() {
    var audio = document.getElementById("audio");
    audio.pause();
  }
</script>
<audio id="audio" src="ff.mp3" loop="true"></audio>
dis needs to go in the body, or something
 onmousedown="play() "onmouseup="pause()"
-->
</body>
</html>